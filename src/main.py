# ============================
#  Florabis's Royal Bot
# ============================
# Replit-ready single file
# Deps: discord.py, firebase-admin, requests

# ---------- IMPORTS ----------
import json
import math
import os
import time
import asyncio
import requests
import discord
from discord import app_commands
from discord.ext import commands, tasks
from datetime import datetime, timedelta, timezone
from google.cloud.firestore_v1.base_query import FieldFilter
from concurrent.futures import ThreadPoolExecutor
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend for server
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from io import BytesIO
import tempfile
import aiohttp
from dotenv import load_dotenv
from access_control import (
    ADMIN_ROLE_ID,
    ALCALDE_MAYOR_ROLE_ID,
    BANCQUERO_ROLE_ID,
    BETTING_MANAGER_ROLE_ID,
    CAPITAN_ROLE_ID,
    MAGISTRATE_ROLE_ID,
    REPORTER_ROLE_ID,
    ROYAL_COUNCILOR_ROLE_ID,
    SOBERANTE_ROLE_ID,
    TREASURY_MANAGER_ROLE_ID,
    WARRANT_MANAGER_ROLE_2_ID,
    WARRANT_MANAGER_ROLE_ID,
    has_admin_role,
    has_citizen_role,
    has_magistrate_role,
    has_snitch_hit,
    has_warrant_role,
    is_citizen,
    is_citizen_by_role,
)
from bill_helpers import (
    find_bill_by_id_sync,
    get_bill_embed,
    get_next_bill_number,
    int_to_roman,
    parse_reward_with_emojis,
    results_embed,
    two_thirds_threshold,
    vote_counts,
)
from bill_ui import BillConsole
from bill_workflow import finalize_bill
from constants import (
    BILL_CATEGORIES,
    BILL_STATUSES,
    CATEGORY_EMOJIS,
    DOMAINS,
    SPAN,
    STATUS_EMOJIS,
    get_display_status,
    get_translation_dict,
    get_user_language,
    t,
)
from firestore_setup import db, ensure_firestore
from logging_setup import (
    asyncio_exception_handler,
    install_exception_handlers,
    logger,
    log_panel_error,
    safe_interaction,
)
from settings import (
    ATTORNEY_ROLE_ID,
    BANK_ACCOUNTS_COLLECTION,
    BANK_TRANSACTIONS_COLLECTION,
    BILL_COLLECTION_NAME,
    BETTING_BETS_COLLECTION,
    BETTING_EVENTS_COLLECTION,
    BETTING_LEADERBOARD_COLLECTION,
    CITIZENS_COLLECTION,
    CITIZEN_ROLE_ID,
    CIVIL_CASES_CHANNEL_ID,
    CONTRACTS_COLLECTION,
    CONTRACT_BIDS_COLLECTION,
    COURT_CASES_CHANNEL_ID,
    COURT_CASES_COLLECTION,
    COURT_CHANNEL_ID,
    COURT_STATUS_CHANNEL_ID,
    CRIMINAL_CASES_CHANNEL_ID,
    CRIMINAL_RECORDS_COLLECTION,
    DIAMOND_BLOCK_EMOJI,
    DIAMOND_EMOJI,
    DISCORD_BOT_TOKEN,
    ECONOMIC_CYCLES_COLLECTION,
    ECONOMIC_REPORTS_COLLECTION,
    EMBED_THUMBNAIL_URL,
    EMERALD_BLOCK_EMOJI,
    EMERALD_EMOJI,
    ESSENCE_CERTIFICATES_COLLECTION,
    ESSENCE_EMOJI,
    FLORABIS_REGIONS,
    GOLD_BLOCK_EMOJI,
    GOLD_EMOJI,
    IRON_BLOCK_EMOJI,
    IRON_EMOJI,
    LAWYER_NOTIFICATIONS_CHANNEL_ID,
    LAWYERS_COLLECTION,
    MARKET_PRICES_COLLECTION,
    MIN_VOTES_TO_FINALIZE,
    MONARCH_ROLE_ID,
    MORTGAGES_COLLECTION,
    PANEL_JOBS_COLLECTION,
    PEARL_EMOJI,
    PEARLS_COLLECTION,
    PEARL_PANELS_COLLECTION,
    PORTAL_PANELS_COLLECTION,
    POS_CHANNEL_ID,
    PRIVATE_RESULTS_CHANNEL_ID,
    PROPERTIES_COLLECTION,
    PROPERTY_IMPROVEMENTS_COLLECTION,
    PROPERTY_LISTINGS_COLLECTION,
    PROPERTY_VALUES_COLLECTION,
    PROPOSED_CHANNEL_ID,
    PUBLIC_DEFENDER_ROLE_ID,
    REFERENDUM_CHANNEL_ID,
    REFERENDUM_VOTER_ROLE_ID,
    REFERENDUMS_COLLECTION,
    REQUIRED_CO_SPONSORS_DEFAULT,
    RESIDENT_ROLE_ID,
    SECONDARY_CITIZEN_ROLE_ID,
    SNITCH_EMOJI,
    SNITCH_LOGS_COLLECTION,
    SNITCH_LOG_CHANNEL_ID,
    STATE_PROSECUTOR_ROLE_ID,
    STOCK_ORDERS_COLLECTION,
    TOTAL_CONSEJEROS,
    TREASURY_BONDS_COLLECTION,
    UNIVERSAL_CITIZEN_ROLE_ID,
    VOTE_NOTIFICATION_CHANNEL_ID,
    VOTING_CHANNEL_ID,
    WARRANTS_COLLECTION,
    WARRANT_CHANNEL_ID,
)
from timezone_utils import EST

# Install global exception handlers
install_exception_handlers()

# ---------- DISCORD BOT ----------
class RoyalCouncilBot(commands.Bot):
    def __init__(self):
        intents = discord.Intents.default()
        intents.members = True
        intents.message_content = True
        
        # Enhanced connection settings to handle network instability
        super().__init__(
            command_prefix='!', 
            intents=intents,
            heartbeat_timeout=90.0,  # Increased from default 60s - more tolerant of network hiccups
            max_messages=500  # Reduced from default 1000 to lower memory pressure
        )
        
        # Pearl essence decrement lock (prevent concurrent runs)
        self.pearl_essence_lock = asyncio.Lock()

    async def rehydrate_views(self):
        """
        Background task to re-register persistent views without blocking bot startup.
        Runs with timeouts and health checks to handle Firestore instability gracefully.
        """
        print("[INFO] Starting background view re-registration...")
        
        # CRITICAL: Check Firestore health first - abort if unhealthy
        try:
            await ensure_firestore()
        except OSError as e:
            print(f"[WARN] Firestore unhealthy during startup, skipping view re-registration: {e}")
            return
        
        # Re-register persistent portal panels
        if db:
            try:
                panels_list = await asyncio.to_thread(lambda: list(db.collection(PORTAL_PANELS_COLLECTION).stream()))
                for doc in panels_list:
                    panel_data = doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists using HTTP fetch
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        self.add_view(BillCreationPanel(), message_id=message_id)
                        print(f"[OK] Re-registered portal panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: doc.reference.delete())
                        print(f"[INFO] Removed stale portal panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload portal panels: {e}")
        
        # Re-register persistent citizen registration panels
        if db:
            try:
                citizen_panels_list = await asyncio.to_thread(lambda: list(db.collection('florabi_citizen_panels').stream()))
                for doc in citizen_panels_list:
                    panel_data = doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        self.add_view(CitizenRegistrationPanel(), message_id=message_id)
                        print(f"[OK] Re-registered citizen panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: doc.reference.delete())
                        print(f"[INFO] Removed stale citizen panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering citizen panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload citizen panels: {e}")
        
        # Re-register persistent court panels
        if db:
            try:
                print("[DEBUG] Checking for court panel in database...")
                court_panel_doc = await asyncio.to_thread(lambda: db.collection(PORTAL_PANELS_COLLECTION).document('court_panel').get())
                if court_panel_doc.exists:
                    print("[DEBUG] Court panel document found")
                    panel_data = court_panel_doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    print(f"[DEBUG] Court panel: guild={guild_id}, channel={channel_id}, msg={message_id}")
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        print(f"[DEBUG] Found channel, fetching message...")
                        await channel.fetch_message(message_id)
                        print("[DEBUG] Message found, registering view...")
                        # Message exists, register the view
                        self.add_view(CourtPanel(), message_id=message_id)
                        print(f"[OK] Re-registered court panel in guild {guild_id}")
                    except discord.NotFound as e:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: court_panel_doc.reference.delete())
                        print(f"[INFO] Removed stale court panel: {e}")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to court channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering court panel: {e}")
                        import traceback
                        traceback.print_exc()
                else:
                    print("[DEBUG] No court panel document in database")
            except Exception as e:
                print(f"[WARN] Could not reload court panel: {e}")
                import traceback
                traceback.print_exc()
        
        # Re-register lawyer claim views for pending cases
        if db:
            try:
                print("[DEBUG] Re-registering lawyer claim views for open cases...")
                open_cases = await asyncio.to_thread(lambda: list(
                    db.collection(COURT_CASES_COLLECTION)
                    .where(filter=FieldFilter('status', 'in', ['filed', 'in_progress', 'pending']))
                    .stream()
                ))
                for case_doc in open_cases:
                    case_data = case_doc.to_dict()
                    case_id = case_data.get('caseId', case_doc.id)
                    case_type = case_data.get('caseType', 'Criminal')
                    # Register the view without needing message_id (buttons use custom_id)
                    self.add_view(LawyerCaseClaimView(case_id, case_type))
                print(f"[OK] Re-registered {len(open_cases)} lawyer claim views")
            except Exception as e:
                print(f"[WARN] Could not reload lawyer claim views: {e}")
        
        # Re-register persistent betting panel
        if db:
            try:
                betting_panel_doc = await asyncio.to_thread(lambda: db.collection(PORTAL_PANELS_COLLECTION).document('betting_panel').get())
                if betting_panel_doc.exists:
                    panel_data = betting_panel_doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        self.add_view(BettingPanel(), message_id=message_id)
                        print(f"[OK] Re-registered betting panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: betting_panel_doc.reference.delete())
                        print(f"[INFO] Removed stale betting panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to betting channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering betting panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload betting panel: {e}")
        
        # Re-register persistent warrant panel
        if db:
            try:
                warrant_panel_doc = await asyncio.to_thread(lambda: db.collection(PORTAL_PANELS_COLLECTION).document('warrant_panel').get())
                if warrant_panel_doc.exists:
                    panel_data = warrant_panel_doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        self.add_view(WarrantPanel(), message_id=message_id)
                        print(f"[OK] Re-registered warrant panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: warrant_panel_doc.reference.delete())
                        print(f"[INFO] Removed stale warrant panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to warrant channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering warrant panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload warrant panel: {e}")
        
        # Re-register persistent bank panel
        if db:
            try:
                bank_panel_doc = await asyncio.to_thread(lambda: db.collection(PORTAL_PANELS_COLLECTION).document('bank_panel').get())
                if bank_panel_doc.exists:
                    panel_data = bank_panel_doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        # ARCHIVED: self.add_view(BankPanel(), message_id=message_id)
                        pass  # Bank panel archived
                        print(f"[OK] Re-registered bank panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: bank_panel_doc.reference.delete())
                        print(f"[INFO] Removed stale bank panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to bank channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering bank panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload bank panel: {e}")
        
        # Re-register persistent economy panel
        if db:
            try:
                economy_panel_doc = await asyncio.to_thread(lambda: db.collection(PORTAL_PANELS_COLLECTION).document('economy_panel').get())
                if economy_panel_doc.exists:
                    panel_data = economy_panel_doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        self.add_view(EconomyPanel(), message_id=message_id)
                        print(f"[OK] Re-registered economy panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: economy_panel_doc.reference.delete())
                        print(f"[INFO] Removed stale economy panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to economy channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering economy panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload economy panel: {e}")
        
        # Re-register persistent market panel
        if db:
            try:
                market_panel_doc = await asyncio.to_thread(lambda: db.collection(PORTAL_PANELS_COLLECTION).document('market_panel').get())
                if market_panel_doc.exists:
                    panel_data = market_panel_doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        self.add_view(MarketPanel(), message_id=message_id)
                        print(f"[OK] Re-registered market panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: market_panel_doc.reference.delete())
                        print(f"[INFO] Removed stale market panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to market channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering market panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload market panel: {e}")
        
        # Re-register persistent pearl panel
        if db:
            try:
                pearl_panel_doc = await asyncio.to_thread(lambda: db.collection(PEARL_PANELS_COLLECTION).document('pearl_panel').get())
                if pearl_panel_doc.exists:
                    panel_data = pearl_panel_doc.to_dict()
                    message_id = panel_data.get('messageId')
                    guild_id = panel_data.get('guildId')
                    channel_id = panel_data.get('channelId')
                    
                    # Verify the message still exists
                    try:
                        channel = await self.fetch_channel(channel_id)
                        await channel.fetch_message(message_id)
                        # Message exists, register the view
                        self.add_view(PearlPublicPanel(), message_id=message_id)
                        print(f"[OK] Re-registered pearl panel in guild {guild_id}")
                    except discord.NotFound:
                        # Message or channel was deleted, remove from DB
                        await asyncio.to_thread(lambda: pearl_panel_doc.reference.delete())
                        print(f"[INFO] Removed stale pearl panel (message/channel deleted)")
                    except discord.Forbidden:
                        # No access to channel
                        print(f"[WARN] No access to pearl channel {channel_id}, keeping record")
                    except Exception as e:
                        print(f"[WARN] Error re-registering pearl panel: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload pearl panel: {e}")
        
        # Lawyer registration now integrated into court panel
        
        # Re-register persistent views for active court cases
        if db:
            try:
                print("[DEBUG] Checking for active court cases to re-register...")
                # Get cases with status 'pending' (active cases waiting for action)
                cases_list = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(filter=FieldFilter('status', '==', 'pending')).stream()))
                case_count = 0
                for doc in cases_list:
                    case_count += 1
                    case_data = doc.to_dict()
                    case_id = case_data.get('caseId')
                    action_panel_message_id = case_data.get('actionPanelMessageId')
                    courtroom_thread_id = case_data.get('courtroomThreadId')
                    case_type = case_data.get('caseType')
                    
                    if action_panel_message_id and case_id and case_type:
                        # Re-register the courtroom action panel view (in the private thread)
                        self.add_view(CourtroomActionPanel(case_id, case_type), message_id=action_panel_message_id)
                        print(f"[OK] Re-registered courtroom action panel for case {case_id}")
                    else:
                        print(f"[DEBUG] Case {case_id} missing actionPanelMessageId, skipping re-registration")
                
                if case_count == 0:
                    print("[DEBUG] No pending court cases found for re-registration")
                else:
                    print(f"[OK] Re-registered {case_count} court case(s)")
            except Exception as e:
                print(f"[WARN] Could not reload court case views: {e}")
                import traceback
                traceback.print_exc()
        
        # Re-register persistent views for active trial threads
        if db:
            try:
                trials_list = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(filter=FieldFilter('trialThreadId', '!=', None)).stream()))
                for doc in trials_list:
                    case_data = doc.to_dict()
                    case_id = case_data.get('caseId') or case_data.get('id')  # Support both new and legacy schemas
                    trial_thread_id = case_data.get('trialThreadId')
                    
                    if trial_thread_id and case_id:
                        # Re-register the trial action view for the trial thread
                        # We need to find the message in the thread (it should be the first message from the bot)
                        try:
                            thread = await self.fetch_channel(trial_thread_id)
                            async for message in thread.history(limit=10, oldest_first=True):
                                if message.author == self.user and len(message.embeds) > 0:
                                    # This is likely the trial introduction message
                                    self.add_view(TrialActionView(case_id), message_id=message.id)
                                    print(f"[OK] Re-registered trial view for case {case_id}")
                                    break
                        except Exception as e:
                            print(f"[WARN] Could not re-register trial view for case {case_id}: {e}")
            except Exception as e:
                print(f"[WARN] Could not reload trial views: {e}")
        
        # Re-register BillConsole views for active bills (voting, passed, and law)
        if db:
            try:
                voting_bills_list = await asyncio.to_thread(lambda: list(db.collection(BILL_COLLECTION_NAME).where(
                    filter=FieldFilter('status', 'in', ['Voting', 'Vetoed', 'Passed', 'Bill is Now Law'])
                ).stream()))
                
                for doc in voting_bills_list:
                    bill_data = doc.to_dict()
                    bill_id = bill_data.get('id')
                    message_id = bill_data.get('messageId')
                    
                    if bill_id and message_id:
                        # Re-register the voting console
                        self.add_view(BillConsole(bill_id), message_id=int(message_id))
                        print(f"[OK] Re-registered voting panel for bill {bill_id}")
            except Exception as e:
                print(f"[WARN] Could not reload voting bills: {e}")
        
        print("[OK] Background view re-registration completed!")
    
    async def on_ready(self):
        """Minimal on_ready - immediately ready for slash commands"""
        # Install asyncio exception handler
        loop = asyncio.get_event_loop()
        loop.set_exception_handler(asyncio_exception_handler)
        print(f"[OK] Installed asyncio exception handler")
        
        print(f"[OK] Logged in as {self.user}")
        
        # Guild-specific sync for instant command updates (no 1-hour cache delay)
        try:
            # Copy global commands to each guild and sync for instant updates
            for guild in self.guilds:
                try:
                    self.tree.copy_global_to(guild=guild)
                    synced = await self.tree.sync(guild=guild)
                    print(f"[OK] Synced {len(synced)} commands to guild: {guild.name}")
                except Exception as e:
                    print(f"[WARN] Failed to sync to guild {guild.name}: {e}")
            
            # Also do global sync as backup for any new guilds
            try:
                global_synced = await self.tree.sync()
                print(f"[OK] Global sync: {len(global_synced)} commands")
            except Exception as e:
                print(f"[WARN] Global sync failed: {e}")
                
        except Exception as e:
            print(f"[ERR] Command sync failed: {e}")
        
        # Schedule view re-registration as background task - DON'T BLOCK ON IT
        self.loop.create_task(self.rehydrate_views())
        print("[INFO] Scheduled background view re-registration task")
        
        # Bot is now ready - slash commands will respond immediately
    
    async def on_error(self, event, *args, **kwargs):
        """Global error handler to prevent bot crashes"""
        import traceback
        print(f"[ERR] Error in {event}:")
        traceback.print_exc()
        # Don't crash the bot - just log and continue
    
    async def on_command_error(self, ctx, error):
        """Handle command errors"""
        print(f"[ERR] Command error: {error}")
        # Don't crash - just log
    
    async def setup_hook(self):
        """Setup hook - ONLY for error handling. All view registration happens in background task."""
        @self.tree.error
        async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
            """Handle slash command errors without crashing"""
            import traceback
            command_name = interaction.command.name if interaction.command else 'unknown'
            
            # Log detailed error information
            print(f"[ERR] ========== SLASH COMMAND ERROR ==========")
            print(f"[ERR] Command: /{command_name}")
            print(f"[ERR] User: {interaction.user}")
            print(f"[ERR] Error Type: {type(error).__name__}")
            print(f"[ERR] Error Message: {str(error)}")
            print(f"[ERR] Full Traceback:")
            traceback.print_exception(type(error), error, error.__traceback__)
            print(f"[ERR] ==========================================")
            
            # Try to respond to the user if possible
            try:
                if interaction.response.is_done():
                    await interaction.edit_original_response(content=
                        f"‚ùå Error in command: {str(error)[:200]}\n\nThe bot is still running. Contact an admin if this persists.")
                else:
                    await interaction.response.send_message(
                        f"‚ùå Error in command: {str(error)[:200]}\n\nThe bot is still running. Contact an admin if this persists.", ephemeral=True)
            except Exception as e:
                print(f"[ERR] Could not send error message to user: {e}")
                pass  # If we can't respond, at least we logged the error
        
        # Start background tasks
        if not self.auto_finalize_bills.is_running():
            self.auto_finalize_bills.start()
            print("[OK] Auto-finalization task started (checks every 5 minutes)")
        
        # Start vote reminder task
        if not self.vote_reminder_task.is_running():
            self.vote_reminder_task.start()
            print("[OK] Vote reminder task started (runs every 2 hours)")
        
        # Start panel job processor
        if not self.panel_job_processor.is_running():
            self.panel_job_processor.start()
            print("[OK] Panel job processor started (polls every 30 seconds)")
        
        # Start pearl essence decrement task
        if not self.decrement_pearl_essence.is_running():
            self.decrement_pearl_essence.start()
            print("[OK] Pearl essence decrement task started (runs hourly)")
        
        if not self.expire_criminal_records.is_running():
            self.expire_criminal_records.start()
            print("[OK] Criminal record expiry task started (runs every 6 hours)")
        
        if not self.sync_government_officials.is_running():
            self.sync_government_officials.start()
            print("[OK] Government officials sync task started (runs every 10 minutes)")
        
        # Referendum system removed

    @tasks.loop(minutes=5)
    async def auto_finalize_bills(self):
        """Check for bills that have been open for 24+ hours and auto-finalize them"""
        if not db:
            return
        
        try:
            # Query for bills in Voting or Vetoed status (use UTC timezone-aware datetime)
            now = datetime.now(timezone.utc)
            cutoff = now - timedelta(hours=24)
            
            # Get all active voting bills
            q_list = await asyncio.to_thread(lambda: list(db.collection(BILL_COLLECTION_NAME).where(filter=FieldFilter('status', 'in', ['Voting', 'Vetoed'])).stream()))
            
            for doc in q_list:
                bill = doc.to_dict()
                voting_start = bill.get('votingStartAt')
                
                # Skip if no timestamp (old bills before this feature)
                if not voting_start:
                    continue
                
                # Check if 24 hours have passed
                if voting_start < cutoff:
                    bill_id = bill.get('id', 'UNKNOWN')
                    print(f"[AUTO-FINALIZE] Processing bill {bill_id} (started {voting_start})")
                    
                    # Get the guild and channel from stored IDs
                    guild_id = bill.get('guildId', 0)
                    channel_id = bill.get('channelId', 0)
                    
                    guild = self.get_guild(guild_id) if guild_id else None
                    channel = self.get_channel(channel_id) if channel_id else None
                    
                    # Fallback if stored IDs don't work
                    if not guild and self.guilds:
                        guild = self.guilds[0]
                    if not channel and guild:
                        channel = next((ch for ch in guild.text_channels if ch.permissions_for(guild.me).send_messages), None)
                    
                    if channel:
                        success, message = await finalize_bill(doc.reference, bill, guild, channel, is_auto=True)
                        if success:
                            print(f"[AUTO-FINALIZE] ‚úÖ Finalized bill {bill_id}")
                        else:
                            print(f"[AUTO-FINALIZE] ‚ö†Ô∏è Could not finalize bill {bill_id}: {message}")
                    else:
                        print(f"[AUTO-FINALIZE] ‚ö†Ô∏è No channel available for bill {bill_id}")
        
        except Exception as e:
            print(f"[AUTO-FINALIZE] Error: {e}")
    
    @auto_finalize_bills.before_loop
    async def before_auto_finalize(self):
        await self.wait_until_ready()
    
    @auto_finalize_bills.error
    async def auto_finalize_error(self, error):
        """Handle errors in auto_finalize_bills task"""
        logger.error(f"Background task 'auto_finalize_bills' crashed: {error}", exc_info=error)

    @tasks.loop(hours=2)
    async def vote_reminder_task(self):
        """Remind councilors about bills approaching deadline (18+ hours old)"""
        if not db:
            return
        
        try:
            now = datetime.now(timezone.utc)
            reminder_threshold = now - timedelta(hours=18)
            
            q_list = await asyncio.to_thread(
                lambda: list(db.collection(BILL_COLLECTION_NAME).where(
                    filter=FieldFilter('status', '==', 'Voting')
                ).stream())
            )
            
            for doc in q_list:
                bill = doc.to_dict()
                voting_start = bill.get('votingStartAt')
                
                if not voting_start:
                    continue
                
                if hasattr(voting_start, 'replace') and voting_start.tzinfo is None:
                    voting_start = voting_start.replace(tzinfo=timezone.utc)
                
                if voting_start < reminder_threshold:
                    if bill.get('reminderSent'):
                        continue
                    
                    bill_id = bill.get('id', 'UNKNOWN')
                    guild_id = bill.get('guildId', 0)
                    channel_id = bill.get('channelId', 0)
                    
                    guild = self.get_guild(guild_id) if guild_id else None
                    channel = self.get_channel(channel_id) if channel_id else None
                    
                    if channel and guild:
                        votes = bill.get('votes', {'yes': [], 'no': [], 'abstain': []})
                        voted_ids = set(votes.get('yes', []) + votes.get('no', []) + votes.get('abstain', []))
                        
                        councilor_role = guild.get_role(ROYAL_COUNCILOR_ROLE_ID)
                        if councilor_role:
                            not_voted = [m for m in councilor_role.members if m.id not in voted_ids]
                            not_voted_count = len(not_voted)
                            
                            if not_voted_count > 0:
                                bill_title = bill.get('title', 'Untitled')
                                await channel.send(
                                    f"**Vote Reminder!** <@&{ROYAL_COUNCILOR_ROLE_ID}>\n\n"
                                    f"**{bill_title}** has {not_voted_count} councilor(s) who haven't voted yet.\n"
                                    f"Voting closes automatically in ~6 hours.\n"
                                    f"Bill ID: \`{bill_id}\`"
                                )
                                
                                await asyncio.to_thread(lambda: doc.reference.update({'reminderSent': True}))
                                print(f"[REMINDER] Sent vote reminder for bill {bill_id}")
        
        except Exception as e:
            print(f"[REMINDER] Error: {e}")
    
    @vote_reminder_task.before_loop
    async def before_vote_reminder(self):
        await self.wait_until_ready()
    
    @vote_reminder_task.error
    async def vote_reminder_error(self, error):
        logger.error(f"Background task 'vote_reminder_task' crashed: {error}", exc_info=error)

    
    @tasks.loop(minutes=5)
    async def auto_close_referendums(self):
        """Check for expired referendums and announce results"""
        if not db:
            return
        
        try:
            now = datetime.now(timezone.utc)
            
            # Get all active referendums - wrap blocking .stream() call
            q_list = await asyncio.to_thread(lambda: list(db.collection(REFERENDUMS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream()))
            
            for doc in q_list:
                ref_data = doc.to_dict()
                end_time = ref_data.get('endTime')
                
                # Check if voting period has ended
                if end_time and now > end_time:
                    ref_id = ref_data.get('id', 'UNKNOWN')
                    print(f"[AUTO-CLOSE] Processing referendum {ref_id}")
                    
                    # Calculate results
                    votes = ref_data.get('votes', {'yes': [], 'no': [], 'abstain': []})
                    yes_count = len(votes['yes'])
                    no_count = len(votes['no'])
                    abstain_count = len(votes['abstain'])
                    total_votes = yes_count + no_count + abstain_count
                    
                    # Determine outcome (simple majority)
                    passed = yes_count > no_count
                    
                    # Update status
                    await asyncio.to_thread(lambda: doc.reference.update({'status': 'closed', 'result': 'passed' if passed else 'failed'}))
                    
                    # Post results in referendum channel
                    channel = self.get_channel(REFERENDUM_CHANNEL_ID)
                    if channel:
                        try:
                            # Convert end time to EST
                            est_tz = timezone(timedelta(hours=-5))
                            end_time_est = end_time.astimezone(est_tz)
                            
                            result_embed = discord.Embed(
                                title=f"üìú REFERENDUM RESULTS #{ref_id}",
                                description=f"**{ref_data.get('title')}**\n\n{ref_data.get('description')}",
                                color=0x00FF00 if passed else 0xFF0000
                            )
                            result_embed.add_field(name="Result", value="‚úÖ **PASSED**" if passed else "‚ùå **FAILED**", inline=False)
                            result_embed.add_field(name="‚úÖ Yes", value=str(yes_count), inline=True)
                            result_embed.add_field(name="‚ùå No", value=str(no_count), inline=True)
                            result_embed.add_field(name="‚è∏Ô∏è Abstain", value=str(abstain_count), inline=True)
                            result_embed.add_field(name="Total Votes", value=str(total_votes), inline=True)
                            result_embed.add_field(name="Voting Closed", value=end_time_est.strftime("%b %d, %Y at %I:%M %p EST"), inline=True)
                            result_embed.set_footer(text=f"Referendum ID: {ref_id}")
                            
                            await channel.send(f"<@&{REFERENDUM_VOTER_ROLE_ID}> **Referendum Closed!**", embed=result_embed)
                            print(f"[AUTO-CLOSE] ‚úÖ Closed referendum {ref_id} - {'PASSED' if passed else 'FAILED'}")
                        except Exception as e:
                            print(f"[AUTO-CLOSE] ‚ö†Ô∏è Error posting results for {ref_id}: {e}")
                    else:
                        print(f"[AUTO-CLOSE] ‚ö†Ô∏è Referendum channel not found")
        
        except Exception as e:
            print(f"[AUTO-CLOSE] Error: {e}")
    
    @auto_close_referendums.before_loop
    async def before_auto_close(self):
        await self.wait_until_ready()
    
    @auto_close_referendums.error
    async def auto_close_error(self, error):
        """Handle errors in auto_close_referendums task"""
        logger.error(f"Background task 'auto_close_referendums' crashed: {error}", exc_info=error)
    
    @tasks.loop(seconds=30)
    async def panel_job_processor(self):
        """Process pending panel posting jobs from queue"""
        if not db:
            return
        
        try:
            # Ensure Firestore client is healthy before querying
            current_db = await ensure_firestore()
            
            # Get pending jobs - wrap blocking .stream() call
            pending_jobs = await asyncio.to_thread(lambda: list(current_db.collection(PANEL_JOBS_COLLECTION).where(
                filter=FieldFilter('status', '==', 'pending')
            ).limit(5).stream()))
            
            for job_doc in pending_jobs:
                job_data = job_doc.to_dict()
                job_id = job_doc.id
                panel_type = job_data.get('panel_type')  # 'pearl' or 'warrant'
                guild_id = job_data.get('guild_id')
                channel_id = job_data.get('channel_id')
                user_id = job_data.get('user_id')
                
                # Mark as processing
                await asyncio.to_thread(lambda: job_doc.reference.update({'status': 'processing', 'processedAt': datetime.now(timezone.utc)}))
                
                try:
                    # Get guild and channel
                    guild = self.get_guild(guild_id)
                    if not guild:
                        raise Exception(f"Guild {guild_id} not found")
                    
                    channel = guild.get_channel(channel_id)
                    if not channel:
                        raise Exception(f"Channel {channel_id} not found")
                    
                    # Process based on panel type
                    if panel_type == 'pearl':
                        await self.process_pearl_panel_job(job_data, guild, channel)
                    elif panel_type == 'warrant':
                        await self.process_warrant_panel_job(job_data, guild, channel)
                    elif panel_type == 'economy':
                        await self.process_economy_panel_job(job_data, guild, channel)
                    else:
                        raise Exception(f"Unknown panel type: {panel_type}")
                    
                    # Mark as completed
                    await asyncio.to_thread(lambda: job_doc.reference.update({'status': 'completed', 'completedAt': datetime.now(timezone.utc)}))
                    print(f"[PANEL-JOB] ‚úÖ Completed {panel_type} panel job {job_id}")
                    
                except Exception as job_err:
                    # Mark as failed
                    await asyncio.to_thread(lambda: job_doc.reference.update({
                        'status': 'failed',
                        'error': str(job_err),
                        'failedAt': datetime.now(timezone.utc)
                    }))
                    print(f"[PANEL-JOB] ‚ùå Failed {panel_type} panel job {job_id}: {job_err}")
                    
        except Exception as e:
            print(f"[PANEL-JOB] Error processing jobs: {e}")
    
    @panel_job_processor.before_loop
    async def before_panel_jobs(self):
        await self.wait_until_ready()
    
    @panel_job_processor.error
    async def panel_job_error(self, error):
        """Handle errors in panel_job_processor task"""
        logger.error(f"Background task 'panel_job_processor' crashed: {error}", exc_info=error)
    
    @tasks.loop(hours=1)
    async def decrement_pearl_essence(self):
        """Hourly task to decrement essence for all active pearls (self-healing)"""
        if not db:
            return
        
        async with self.pearl_essence_lock:  # Prevent concurrent runs
            try:
                # Ensure Firestore client is healthy
                current_db = await ensure_firestore()
                
                # Get all active pearls - wrap blocking .stream() call
                active_pearls = await asyncio.to_thread(lambda: list(current_db.collection(PEARLS_COLLECTION).where(
                    filter=FieldFilter('status', '==', 'active')
                ).stream()))
                
                if not active_pearls:
                    return
                
                now = datetime.now(timezone.utc)
                batch_updates = []  # Collect updates for batched write
                auto_releases = []  # Track auto-releases for alert
                anomalies = []  # Track multi-day catch-ups
                
                for pearl_doc in active_pearls:
                    pearl = pearl_doc.to_dict()
                    ign = pearl.get('ign', 'UNKNOWN')
                    last_update = pearl.get('lastEssenceUpdate')
                    
                    # Skip unmigrated pearls
                    if not last_update:
                        print(f"[ESSENCE-CRON] ‚è≠Ô∏è Skipping {ign}: Not migrated (no lastEssenceUpdate)")
                        continue
                    
                    # Calculate elapsed days (self-healing: handles missed runs)
                    elapsed_seconds = (now - last_update).total_seconds()
                    elapsed_days = int(elapsed_seconds // 86400)
                    
                    if elapsed_days < 1:
                        continue  # Not 24h yet
                    
                    # Get pearl data
                    pearl_start = pearl.get('pearlStartDate')
                    essence_remaining = pearl.get('essenceRemaining', 0.0)
                    essence_capacity = pearl.get('essenceCapacity', 0.0)
                    
                    if not pearl_start:
                        print(f"[ESSENCE-CRON] ‚ö†Ô∏è Skipping {ign}: No pearlStartDate")
                        continue
                    
                    # Calculate total decrement for all elapsed days (self-healing)
                    total_decrement = 0.0
                    base_days_held = (last_update - pearl_start).days
                    
                    for day_offset in range(elapsed_days):
                        days_held_at_that_point = base_days_held + day_offset + 1
                        daily_cost = calculate_pearl_essence_cost(days_held_at_that_point)
                        total_decrement += daily_cost
                    
                    new_essence = essence_remaining - total_decrement
                    
                    # Log anomalies (multi-day catch-up)
                    if elapsed_days > 1:
                        anomalies.append(f"{ign}: Caught up {elapsed_days} days ({total_decrement:.0f} es)")
                    
                    # Check if essence depleted (auto-release)
                    if new_essence <= 0:
                        batch_updates.append({
                            'doc_ref': pearl_doc.reference,
                            'data': {
                                'status': 'released',
                                'releasedAt': now,
                                'releasedBy': 'SYSTEM',
                                'releasedReason': 'Essence Depleted',
                                'essenceRemaining': 0.0,
                                'lastEssenceUpdate': now
                            }
                        })
                        auto_releases.append(f"üîì {ign} (essence depleted)")
                        print(f"[ESSENCE-CRON] üîì Auto-released {ign}: essence depleted")
                    else:
                        # Normal decrement
                        batch_updates.append({
                            'doc_ref': pearl_doc.reference,
                            'data': {
                                'essenceRemaining': new_essence,
                                'lastEssenceUpdate': now
                            }
                        })
                        print(f"[ESSENCE-CRON] {ign}: {essence_remaining:.0f}/{essence_capacity:.0f} ‚Üí {new_essence:.0f}/{essence_capacity:.0f} (-{total_decrement:.0f} es over {elapsed_days}d)")
                
                # Apply updates in batched writes (‚â§400 docs per batch)
                BATCH_SIZE = 400
                for i in range(0, len(batch_updates), BATCH_SIZE):
                    chunk = batch_updates[i:i + BATCH_SIZE]
                    batch = current_db.batch()
                    
                    for update in chunk:
                        batch.update(update['doc_ref'], update['data'])
                    
                    try:
                        await asyncio.to_thread(lambda: batch.commit())
                        print(f"[ESSENCE-CRON] ‚úÖ Committed batch {i//BATCH_SIZE + 1} ({len(chunk)} updates)")
                    except Exception as batch_err:
                        print(f"[ESSENCE-CRON] ‚ùå Batch commit failed, falling back to individual updates: {batch_err}")
                        # Fallback to individual updates
                        for update in chunk:
                            try:
                                await asyncio.to_thread(lambda u=update: u['doc_ref'].update(u['data']))
                            except Exception as individual_err:
                                print(f"[ESSENCE-CRON] ‚ùå Individual update failed: {individual_err}")
                
                # Send Discord alert for auto-releases (if any)
                if auto_releases:
                    # Try to find a staff/admin channel to post alert
                    for guild in self.guilds:
                        # Look for channels like "admin-alerts", "mod-chat", etc.
                        alert_channel = discord.utils.get(guild.text_channels, name="admin-alerts") or \
                                      discord.utils.get(guild.text_channels, name="mod-chat") or \
                                      discord.utils.get(guild.text_channels, name="admin-chat")
                        
                        if alert_channel:
                            alert_embed = discord.Embed(
                                title="‚öôÔ∏è PEARL AUTO-RELEASE ALERT",
                                description="\n".join(auto_releases),
                                color=discord.Color.orange()
                            )
                            alert_embed.set_footer(text=f"Released: {now.strftime('%b %d, %Y at %I:%M %p UTC')} | Automated System")
                            try:
                                await alert_channel.send(embed=alert_embed)
                                break  # Only send to first guild with alert channel
                            except Exception as alert_err:
                                print(f"[ESSENCE-CRON] ‚ö†Ô∏è Failed to send alert: {alert_err}")
                
                # Log summary
                if batch_updates:
                    print(f"[ESSENCE-CRON] üìä Summary: {len(batch_updates)} updates, {len(auto_releases)} auto-releases, {len(anomalies)} anomalies")
                    if anomalies:
                        for anomaly in anomalies:
                            print(f"[ESSENCE-CRON] ‚ö†Ô∏è ANOMALY: {anomaly}")
                
            except Exception as e:
                logger.error(f"[ESSENCE-CRON] Task error: {e}", exc_info=e)
                print(f"[ESSENCE-CRON] ‚ùå Error: {e}")
    
    @decrement_pearl_essence.before_loop
    async def before_essence_decrement(self):
        await self.wait_until_ready()
    
    @decrement_pearl_essence.error
    async def essence_decrement_error(self, error):
        """Handle errors in decrement_pearl_essence task"""
        logger.error(f"Background task 'decrement_pearl_essence' crashed: {error}", exc_info=error)

    @tasks.loop(hours=6)
    async def expire_criminal_records(self):
        """Background task to auto-expire criminal records past their expiry date."""
        await self.wait_until_ready()
        try:
            current_db = await ensure_firestore()
            if not current_db:
                return
            
            now = datetime.now(timezone.utc)
            
            # Find all ACTIVE records that have expired
            all_active = await asyncio.to_thread(lambda: list(
                current_db.collection(CRIMINAL_RECORDS_COLLECTION).where(
                    filter=FieldFilter('status', '==', 'ACTIVE')
                ).stream()
            ))
            
            expired_count = 0
            for rec_doc in all_active:
                r = rec_doc.to_dict()
                expires_at = r.get('expiresAt')
                if expires_at:
                    # Normalize Firestore timestamp to datetime
                    if hasattr(expires_at, 'replace'):
                        if expires_at.tzinfo is None:
                            expires_at = expires_at.replace(tzinfo=timezone.utc)
                    elif hasattr(expires_at, 'timestamp'):
                        expires_at = datetime.fromtimestamp(expires_at.timestamp(), tz=timezone.utc)
                    
                    if expires_at <= now:
                        await asyncio.to_thread(lambda doc=rec_doc: doc.reference.update({
                        'status': 'EXPIRED',
                        'autoExpiredAt': now
                    }))
                    expired_count += 1
                    print(f"[OK] Auto-expired criminal record {rec_doc.id} for {r.get('ign')}")
            
            if expired_count > 0:
                print(f"[INFO] Criminal record sweep: {expired_count} records auto-expired")
                
        except Exception as e:
            print(f"[ERR] Criminal record expiry task failed: {e}")
    
    @expire_criminal_records.error
    async def expire_criminal_records_error(self, error):
        logger.error(f"Background task 'expire_criminal_records' crashed: {error}", exc_info=error)

    @tasks.loop(minutes=10)
    async def sync_government_officials(self):
        """Background task to sync government officials from Discord roles to Firestore for website."""
        await self.wait_until_ready()
        try:
            current_db = await ensure_firestore()
            if not current_db:
                return
            
            # Find the guild
            guild = None
            for g in self.guilds:
                if g.get_role(SOBERANTE_ROLE_ID):
                    guild = g
                    break
            
            if not guild:
                return
            
            officials_data = {
                'soberante': None,
                'alcalde_mayor': None,
                'capitan': None,
                'councilors': [],
                'magistrates': [],
                'last_sync': datetime.now(timezone.utc).isoformat()
            }
            
            # Get members with each role
            for member in guild.members:
                role_ids = [r.id for r in member.roles]
                display_name = member.display_name or member.name
                
                if SOBERANTE_ROLE_ID in role_ids:
                    officials_data['soberante'] = display_name
                
                if ALCALDE_MAYOR_ROLE_ID in role_ids:
                    officials_data['alcalde_mayor'] = display_name
                
                if CAPITAN_ROLE_ID in role_ids:
                    officials_data['capitan'] = display_name
                
                if ROYAL_COUNCILOR_ROLE_ID in role_ids:
                    officials_data['councilors'].append(display_name)
                
                if MAGISTRATE_ROLE_ID in role_ids:
                    # Determine magistrate type based on other roles
                    if SOBERANTE_ROLE_ID in role_ids:
                        mag_type = "supreme"  # Supreme Magistrate (Soberante)
                        mag_order = 0
                    elif ROYAL_COUNCILOR_ROLE_ID in role_ids:
                        mag_type = "council"  # Council Magistrate
                        mag_order = 1
                    else:
                        mag_type = "citizen"  # Citizen Magistrate
                        mag_order = 2
                    officials_data["magistrates"].append({
                        "name": display_name,
                        "type": mag_type,
                        "order": mag_order
                    })
            
            # Sort councilors and magistrates alphabetically
            officials_data['councilors'].sort()
            officials_data['magistrates'].sort(key=lambda m: m['order'])
            
            # Save to Firestore
            await asyncio.to_thread(
                lambda: current_db.collection('florabi_config').document('government_officials').set(officials_data)
            )
            print(f"[OK] Synced government officials: Soberante={officials_data['soberante']}, {len(officials_data['councilors'])} councilors, {len(officials_data['magistrates'])} magistrates")
            
        except Exception as e:
            print(f"[ERR] Government officials sync failed: {e}")
    
    @sync_government_officials.before_loop
    async def before_sync_government_officials(self):
        await self.wait_until_ready()
    
    @sync_government_officials.error
    async def sync_government_officials_error(self, error):
        logger.error(f"Background task 'sync_government_officials' crashed: {error}", exc_info=error)
    
    async def process_pearl_panel_job(self, job_data, guild, channel):
        """Process a pearl panel posting job with full retry logic"""
        user_id = job_data.get('user_id')
        
        # Ensure Firestore client is healthy before querying
        current_db = await ensure_firestore()
        
        # Get active pearls - wrap blocking .stream() call
        active_pearls = await asyncio.to_thread(lambda: list(current_db.collection(PEARLS_COLLECTION).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream()))
        
        # Build embed (same logic as before)
        if not active_pearls:
            embed = discord.Embed(
                title="<:pearl:1428919990194536458> PEARL FACILITY - FLORAB√çS STATE",
                description="‚úÖ No players currently pearled.\n*All pearled players are held in the Nether*",
                color=discord.Color.green()
            )
            embed.set_footer(text="<:pearl:1428919990194536458> Florab√≠s State Pearl System | Held in the Nether ‚Ä¢ Click Refresh to update")
        else:
            pearl_entries = []
            total_essence_remaining = 0
            daily_consumption = 0
            
            for pearl_doc in active_pearls:
                pearl = pearl_doc.to_dict()
                pearl_start = pearl.get('pearlStartDate')
                release_date = pearl.get('expectedReleaseDate')
                if pearl_start and release_date:
                    days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days
                    remaining_days = max((release_date - datetime.now(timezone.utc)).days, 0)
                    essence_needed = sum(calculate_pearl_essence_cost(days_held_so_far + day + 1) for day in range(remaining_days))
                    total_essence_remaining += essence_needed
                    daily_cost = calculate_pearl_essence_cost(days_held_so_far + 1)
                    daily_consumption += daily_cost
            
            MAX_DISPLAY = 8
            for idx, pearl_doc in enumerate(active_pearls):
                if idx >= MAX_DISPLAY:
                    break
                    
                pearl = pearl_doc.to_dict()
                ign = pearl.get('ign')
                release_date = pearl.get('expectedReleaseDate')
                duration = pearl.get('pearlDuration', 0)
                
                if release_date:
                    days_left = max((release_date - datetime.now(timezone.utc)).days, 0)
                    pearl_start = pearl.get('pearlStartDate')
                    
                    # NEW ESSENCE SYSTEM: Read from database if available, otherwise calculate fallback
                    essence_capacity = pearl.get('essenceCapacity')
                    essence_remaining = pearl.get('essenceRemaining')
                    
                    # Fallback for old pearls without new fields
                    # STANDARD CAPACITY: All pearls show /336 essence (112-day equivalent fuel tank)
                    if essence_capacity is None or essence_remaining is None:
                        essence_capacity = 336.0  # Standard fuel tank size (112 days * 3 ess)
                        if pearl_start:
                            days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days
                            # Calculate essence consumed so far
                            essence_consumed = 0.0
                            for day in range(1, days_held_so_far + 1):
                                essence_consumed += calculate_pearl_essence_cost(day)
                            # Remaining = capacity - consumed
                            essence_remaining = max(0.0, essence_capacity - essence_consumed)
                        else:
                            # If no start date, assume full tank
                            essence_remaining = essence_capacity
                    
                    # Use helper function for consistent formatting
                    duration_text, release_text, fuel_text = format_pearl_display(
                        duration, release_date, pearl_start, essence_remaining, essence_capacity, days_left
                    )
                    
                    pearl_entries.append(
                        f"<:pearl:1428919990194536458> **{ign}**\n"
                        f"**Sentence:** {duration_text} ‚Ä¢ **Release:** {release_text}\n"
                        f"{fuel_text}"
                    )
                else:
                    pearl_entries.append(f"<:pearl:1428919990194536458> **{ign}** ‚Äî *Awaiting Sentencing*")
            
            description_text = "*All pearled players are held in the Nether*\n\n" + "\n\n".join(pearl_entries)
            if len(description_text) > 3500:
                description_text = description_text[:3500] + "\n\n*...List truncated. Too many pearls to display.*"
            
            embed = discord.Embed(
                title="<:pearl:1428919990194536458> PEARL FACILITY - FLORAB√çS STATE",
                description=description_text,
                color=0xDC143C
            )
            embed.add_field(
                name="üìä Facility Status",
                value=(
                    f"**Pearled:** {len(active_pearls)} ‚Ä¢ **Fuel:** {ESSENCE_EMOJI} {total_essence_remaining:.0f} es\n"
                    f"**Consumption:** {daily_consumption:.0f} es/day ‚Ä¢ **Location:** Nether ‚Ä¢ **View:** PUBLIC"
                ),
                inline=False
            )
            now_est = datetime.now(timezone.utc).astimezone(EST)
            embed.set_footer(text=f"<:pearl:1428919990194536458> Updated: {now_est.strftime('%I:%M %p EST')} | Florab√≠s Pearl System ‚Ä¢ Click Refresh to update")
        
        # Post panel with retry logic (no timeout constraints in background worker!)
        from discord import ui
        message = None
        for attempt in range(20):  # More retries since we have no timeout
            try:
                if attempt > 0:
                    await asyncio.sleep(min(5 * attempt, 60))
                
                message = await channel.send(embed=embed, view=PearlPublicPanel())
                print(f"[PANEL-JOB] ‚úÖ Posted pearl panel after {attempt + 1} attempt(s)")
                break
            except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError) as io_err:
                print(f"[PANEL-JOB] I/O error (attempt {attempt + 1}/20): {io_err}")
                try:
                    await self.http.recreate()
                except:
                    pass
            except Exception as e:
                print(f"[PANEL-JOB] Error (attempt {attempt + 1}/20): {e}")
        
        if message:
            # Save panel location for re-registration on restart
            await asyncio.to_thread(lambda: db.collection(PEARL_PANELS_COLLECTION).document('pearl_panel').set({
                'guildId': guild.id,
                'channelId': channel.id,
                'messageId': message.id
            }))
        else:
            raise Exception("Failed to post panel after 20 attempts")
    
    async def process_warrant_panel_job(self, job_data, guild, channel):
        """Process a warrant panel posting job with full retry logic"""
        user_id = job_data.get('user_id')
        
        # Ensure Firestore client is healthy before querying
        current_db = await ensure_firestore()
        
        # Get all active pearls ONCE (for marking pearled players)
        pearled_igns = set()
        pearl_docs = await asyncio.to_thread(
            lambda: list(current_db.collection(PEARLS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
        )
        for pearl_doc in pearl_docs:
            pearled_igns.add(pearl_doc.to_dict().get('ign'))
        
        # Get all active warrants
        warrants = []
        warrant_docs = await asyncio.to_thread(
            lambda: list(current_db.collection(WARRANTS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
        )
        for doc in warrant_docs:
            data = doc.to_dict()
            issued_at = data.get('issuedAt')
            if isinstance(issued_at, datetime):
                issued_date = issued_at.astimezone(EST).strftime('%b %d, %Y')
            else:
                issued_date = 'Unknown'
            charge = data.get('charge') or data.get('reason', 'No charge')
            ign = data.get('ign')
            
            # Check if this person is pearled
            pearl_indicator = f" {PEARL_EMOJI} **PEARLED**" if ign in pearled_igns else ""
            warrants.append(f"**{ign}** - {charge} - *{issued_date}*{pearl_indicator}")
        
        # Build embed
        if warrants:
            description = "\n".join(warrants)
            if len(description) > 3500:
                description = description[:3500] + "\n\n*...List truncated. Use `/warrant list` to see all.*"
        else:
            description = "‚úÖ No active warrants at this time."
        
        embed = discord.Embed(
            title=f"üö® ACTIVE WARRANTS ({len(warrants)})",
            description=description,
            color=discord.Color.red() if warrants else discord.Color.green()
        )
        embed.set_footer(text="Pearl on Sight (POS) List ‚Ä¢ Click Refresh to update")
        
        # Try to edit existing panel first, fall back to new message
        old_panel_doc = await asyncio.to_thread(
            lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('warrant_panel').get()
        )
        
        message = None
        if old_panel_doc.exists:
            old_data = old_panel_doc.to_dict()
            if old_data.get('guildId') == guild.id and old_data.get('channelId') == channel.id:
                try:
                    old_message = await channel.fetch_message(old_data.get('messageId'))
                    await old_message.edit(embed=embed, view=WarrantPanel())
                    message = old_message
                    print(f"[PANEL-JOB] ‚úÖ Edited existing warrant panel")
                except:
                    pass  # Fall back to new message
        
        # If edit failed or no existing panel, send new message
        last_error = None
        if not message:
            for attempt in range(12):
                try:
                    await asyncio.sleep(0.3 * attempt)  # Progressive backoff
                    message = await channel.send(embed=embed, view=WarrantPanel())
                    break
                except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError) as send_err:
                    last_error = send_err
                    print(f"[PANEL-JOB] Warrant panel send I/O error (attempt {attempt + 1}/12): {send_err}")
                    if attempt < 11:
                        try:
                            await self.http.recreate()  # Recreate broken Discord connection
                        except Exception as recreate_err:
                            print(f"[WARN] HTTP recreate failed: {recreate_err}")
                        await asyncio.sleep(2 ** min(attempt, 6))  # Exponential backoff
                except Exception as send_err:
                    last_error = send_err
                    print(f"[PANEL-JOB] Warrant panel send error (attempt {attempt + 1}/12): {send_err}")
                    if attempt < 11:
                        await asyncio.sleep(2 ** min(attempt, 4))
        
        if not message:
            error_details = f": {type(last_error).__name__} - {str(last_error)}" if last_error else ""
            raise Exception(f"Failed to post warrant panel after 12 attempts{error_details}")
        
        # Store panel location
        await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('warrant_panel').set({
            'guildId': guild.id,
            'channelId': channel.id,
            'messageId': message.id
        }))
    
    async def process_economy_panel_job(self, job_data, guild, channel):
        """Process economy panel posting job with ALL heavy Firestore work in background"""
        user_id = job_data.get('user_id')
        
        # Ensure Firestore client is healthy
        current_db = await ensure_firestore()
        
        # ALL DATABASE QUERIES IN asyncio.to_thread()
        # Get market prices
        def get_all_market_data():
            essence_price = get_market_price('essence')
            iron_price = get_market_price('iron')
            gold_price = get_market_price('gold')
            emerald_price = get_market_price('emerald')
            iron_block_price = get_market_price('iron_block')
            gold_block_price = get_market_price('gold_block')
            emerald_block_price = get_market_price('emerald_block')
            
            diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread = get_market_rate('diamond')
            essence_rate, essence_unit, essence_buy, essence_sell, essence_spread = get_market_rate('essence')
            iron_rate, iron_unit, iron_buy, iron_sell, iron_spread = get_market_rate('iron')
            gold_rate, gold_unit, gold_buy, gold_sell, gold_spread = get_market_rate('gold')
            emerald_rate, emerald_unit, emerald_buy, emerald_sell, emerald_spread = get_market_rate('emerald')
            iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, iron_block_spread = get_market_rate('iron_block')
            gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, gold_block_spread = get_market_rate('gold_block')
            emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, emerald_block_spread = get_market_rate('emerald_block')
            
            # Get treasury reserves
            treasury_items = list(current_db.collection(TREASURY_COLLECTION).stream())
            treasury_reserves = {}
            state_treasury_value = 0
            for doc in treasury_items:
                data = doc.to_dict()
                resource = doc.id
                amount = data.get('amount', 0)
                if amount > 0:
                    treasury_reserves[resource] = amount
                    if resource == 'Diamonds':
                        state_treasury_value += amount
                    elif resource == 'Essence':
                        state_treasury_value += amount * essence_price
                    elif resource == 'Iron':
                        state_treasury_value += amount * iron_price
                    elif resource == 'Gold':
                        state_treasury_value += amount * gold_price
                    elif resource == 'Emeralds':
                        state_treasury_value += amount // 10
                    elif resource == 'Xp (Bottles)':
                        state_treasury_value += amount // 64
            
            # Get state portfolio
            STATE_USER_ID = 0
            state_holdings = list(current_db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', STATE_USER_ID)).stream())
            state_portfolio_value = 0
            for holding in state_holdings:
                data = holding.to_dict()
                business_name = data.get('businessName', 'Unknown')
                shares = data.get('shares', 0)
                ipo = list(current_db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).limit(1).stream())
                price = ipo[0].to_dict()['pricePerShare'] if ipo else 10.0
                state_portfolio_value += shares * price
            
            # Get all bank accounts
            all_accounts = list(current_db.collection(BANK_ACCOUNTS_COLLECTION).stream())
            total_diamonds = sum(acc.to_dict().get('diamondBalance', acc.to_dict().get('balance', 0)) for acc in all_accounts)
            total_essence = sum(acc.to_dict().get('essenceBalance', 0) for acc in all_accounts)
            total_iron = sum(acc.to_dict().get('ironBalance', 0) for acc in all_accounts)
            total_gold = sum(acc.to_dict().get('goldBalance', 0) for acc in all_accounts)
            total_emerald = sum(acc.to_dict().get('emeraldBalance', 0) for acc in all_accounts)
            total_iron_blocks = sum(acc.to_dict().get('ironBlockBalance', 0) for acc in all_accounts)
            total_gold_blocks = sum(acc.to_dict().get('goldBlockBalance', 0) for acc in all_accounts)
            total_emerald_blocks = sum(acc.to_dict().get('emeraldBlockBalance', 0) for acc in all_accounts)
            
            # Get active bonds and certificates
            active_bonds = list(current_db.collection(TREASURY_BONDS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
            total_bond_principal = sum(bond.to_dict().get('principal', 0) for bond in active_bonds)
            active_certs = list(current_db.collection(ESSENCE_CERTIFICATES_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
            locked_essence = sum(cert.to_dict().get('essenceAmount', 0) for cert in active_certs)
            
            return {
                'prices': {
                    'essence': essence_price, 'iron': iron_price, 'gold': gold_price, 'emerald': emerald_price,
                    'iron_block': iron_block_price, 'gold_block': gold_block_price, 'emerald_block': emerald_block_price
                },
                'rates': {
                    'diamond': (diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread),
                    'essence': (essence_rate, essence_unit, essence_buy, essence_sell, essence_spread),
                    'iron': (iron_rate, iron_unit, iron_buy, iron_sell, iron_spread),
                    'gold': (gold_rate, gold_unit, gold_buy, gold_sell, gold_spread),
                    'emerald': (emerald_rate, emerald_unit, emerald_buy, emerald_sell, emerald_spread),
                    'iron_block': (iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, iron_block_spread),
                    'gold_block': (gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, gold_block_spread),
                    'emerald_block': (emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, emerald_block_spread)
                },
                'treasury': {'reserves': treasury_reserves, 'value': state_treasury_value, 'portfolio': state_portfolio_value},
                'citizen_holdings': {
                    'diamonds': total_diamonds, 'essence': total_essence, 'iron': total_iron, 'gold': total_gold,
                    'emerald': total_emerald, 'iron_blocks': total_iron_blocks, 'gold_blocks': total_gold_blocks,
                    'emerald_blocks': total_emerald_blocks, 'account_count': len(all_accounts)
                },
                'investments': {'bonds': len(active_bonds), 'bond_principal': total_bond_principal, 'certs': len(active_certs), 'locked_essence': locked_essence}
            }
        
        # Run ALL heavy queries in thread pool
        print(f"[PANEL-JOB] Starting economy panel data collection...")
        data = await asyncio.to_thread(get_all_market_data)
        print(f"[PANEL-JOB] Economy data collected, building embed...")
        
        # Build embed (fast, no I/O)
        embed = discord.Embed(title="üèõÔ∏è FLORAB√çS FINANCIAL CENTER", description="*Real-time market data & economic overview*", color=0x2F3136)
        
        def format_spread(buy, sell, rate, unit):
            if buy > 0 and sell > 0:
                return f"‚Üì{buy:.2f}{unit} | ‚Üë{sell:.2f}{unit}"
            return f"{rate:.2f}{unit}"
        
        # Unpack rates
        diamond_rate, diamond_unit, diamond_buy, diamond_sell, _ = data['rates']['diamond']
        essence_rate, essence_unit, essence_buy, essence_sell, _ = data['rates']['essence']
        iron_rate, iron_unit, iron_buy, iron_sell, _ = data['rates']['iron']
        gold_rate, gold_unit, gold_buy, gold_sell, _ = data['rates']['gold']
        emerald_rate, emerald_unit, emerald_buy, emerald_sell, _ = data['rates']['emerald']
        iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, _ = data['rates']['iron_block']
        gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, _ = data['rates']['gold_block']
        emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, _ = data['rates']['emerald_block']
        
        embed.add_field(name="üíπ EXCHANGE RATES", value=(
            f"**{DIAMOND_EMOJI} d** ‚Äî {format_spread(diamond_buy, diamond_sell, diamond_rate, diamond_unit)}\n"
            f"**{ESSENCE_EMOJI} es** ‚Äî {format_spread(essence_buy, essence_sell, essence_rate, essence_unit)}\n"
            f"**{IRON_EMOJI} i** ‚Äî {format_spread(iron_buy, iron_sell, iron_rate, iron_unit)}\n"
            f"**{GOLD_EMOJI} gld** ‚Äî {format_spread(gold_buy, gold_sell, gold_rate, gold_unit)}\n"
            f"**{EMERALD_EMOJI} em** ‚Äî {format_spread(emerald_buy, emerald_sell, emerald_rate, emerald_unit)}"
        ), inline=True)
        
        embed.add_field(name="üì¶ BLOCK RATES", value=(
            f"**{IRON_BLOCK_EMOJI} i-blk** ‚Äî {format_spread(iron_block_buy, iron_block_sell, iron_block_rate, iron_block_unit)}\n"
            f"**{GOLD_BLOCK_EMOJI} gld-blk** ‚Äî {format_spread(gold_block_buy, gold_block_sell, gold_block_rate, gold_block_unit)}\n"
            f"**{EMERALD_BLOCK_EMOJI} em-blk** ‚Äî {format_spread(emerald_block_buy, emerald_block_sell, emerald_block_rate, emerald_block_unit)}"
        ), inline=True)
        
        # Calculate total liquidity
        ch = data['citizen_holdings']
        total_liquidity = (ch['diamonds'] + ch['essence'] * data['prices']['essence'] + ch['iron'] * data['prices']['iron'] +
                          ch['gold'] * data['prices']['gold'] + ch['emerald'] * data['prices']['emerald'] +
                          ch['iron_blocks'] * data['prices']['iron_block'] + ch['gold_blocks'] * data['prices']['gold_block'] +
                          ch['emerald_blocks'] * data['prices']['emerald_block'])
        
        embed.add_field(name="üí∞ CITIZEN LIQUIDITY", value=(
            f"{DIAMOND_EMOJI} **{ch['diamonds']:,.0f} d** (~{ch['diamonds']:,.0f}d)\n"
            f"{ESSENCE_EMOJI} **{ch['essence']:,.0f} es** (~{ch['essence'] * data['prices']['essence']:,.0f}d)\n"
            f"{IRON_EMOJI} **{ch['iron']:,.0f} i** (~{ch['iron'] * data['prices']['iron']:,.0f}d)\n"
            f"{GOLD_EMOJI} **{ch['gold']:,.0f} gld** (~{ch['gold'] * data['prices']['gold']:,.0f}d)\n"
            f"**{DIAMOND_EMOJI} Total:** {total_liquidity:,.0f}d"
        ), inline=False)
        
        treasury_text = ""
        for resource, amount in data['treasury']['reserves'].items():
            if resource == 'Diamonds':
                treasury_text += f"{DIAMOND_EMOJI} **{resource}:** {amount:,.0f}\n"
            elif resource == 'Essence':
                treasury_text += f"{ESSENCE_EMOJI} **{resource}:** {amount:,.0f}\n"
        if not treasury_text:
            treasury_text = "No reserves"
        else:
            treasury_text += f"\nüìä **Treasury Value:** {data['treasury']['value']:,.0f}d"
            if data['treasury']['portfolio'] > 0:
                treasury_text += f"\nüìà **Stock Portfolio:** {data['treasury']['portfolio']:,.0f}d"
        
        embed.add_field(name="üèõÔ∏è STATE TREASURY", value=treasury_text, inline=False)
        embed.add_field(name="üìà INVESTMENTS", value=(
            f"üí∞ **Bonds:** {data['investments']['bonds']} active | {data['investments']['bond_principal']:,.0f}d\n"
            f"üìú **Certificates:** {data['investments']['certs']} active | {data['investments']['locked_essence']:,.0f} es locked"
        ), inline=True)
        
        liquidity_status = "üü¢ Healthy" if total_liquidity > 1000 else "üî¥ Low"
        embed.add_field(name="üìä MARKET STATUS", value=(
            f"**Liquidity:** {liquidity_status}\n"
            f"**Activity:** {'üü¢ Active' if data['investments']['bonds'] > 0 else 'üîµ Calm'}\n"
            f"**Accounts:** {ch['account_count']} citizens"
        ), inline=True)
        
        now_est = datetime.now(timezone.utc).astimezone(EST)
        embed.set_footer(text=f"Updated: {now_est.strftime('%b %d, %Y at %I:%M %p EST')} | Click üîÑ to refresh")
        
        # Delete old panel if exists
        old_panel_doc = await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('economy_panel').get())
        if old_panel_doc.exists:
            old_data = old_panel_doc.to_dict()
            old_channel = guild.get_channel(old_data.get('channelId'))
            if old_channel:
                try:
                    old_message = await old_channel.fetch_message(old_data.get('messageId'))
                    await old_message.delete()
                    print(f"[PANEL-JOB] Deleted old economy panel")
                except:
                    pass
        
        # Post new panel with retry
        message = None
        for attempt in range(12):
            try:
                await asyncio.sleep(0.3 * attempt)
                message = await channel.send(embed=embed, view=EconomyPanel())
                print(f"[PANEL-JOB] ‚úÖ Posted economy panel")
                break
            except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError) as io_err:
                print(f"[PANEL-JOB] Economy panel I/O error (attempt {attempt + 1}/12): {io_err}")
            except Exception as e:
                print(f"[PANEL-JOB] Economy panel error (attempt {attempt + 1}/12): {e}")
        
        if not message:
            raise Exception("Failed to post economy panel after 12 attempts")
        
        # Store panel location
        await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('economy_panel').set({
            'guildId': guild.id,
            'channelId': channel.id,
            'messageId': message.id
        }))

bot = RoyalCouncilBot()

# ---------- PANEL JOB HELPER ----------
async def enqueue_panel_job(panel_type: str, guild_id: int, channel_id: int, user_id: int) -> str:
    """Enqueue a panel posting job to the background worker. Returns job ID."""
    if not db:
        raise Exception("Database not available")
    
    # Ensure Firestore client is healthy
    current_db = await ensure_firestore()
    
    # Create job document
    job_data = {
        'panel_type': panel_type,  # 'pearl' or 'warrant'
        'guild_id': guild_id,
        'channel_id': channel_id,
        'user_id': user_id,
        'status': 'pending',
        'createdAt': datetime.now(timezone.utc)
    }
    
    # Add to queue
    job_ref = await asyncio.to_thread(
        lambda: current_db.collection(PANEL_JOBS_COLLECTION).add(job_data)
    )
    job_id = job_ref[1].id
    
    print(f"[PANEL-JOB] ‚úÖ Enqueued {panel_type} panel job {job_id}")
    return job_id

# ---------- COMMAND GROUPS ----------
# Organize commands into logical groups for cleaner UI
betting_group = app_commands.Group(name="betting", description="üé∞ Tom Brady's Royal Betting Exchange")
warrant_group = app_commands.Group(name="warrant", description="‚öîÔ∏è Warrant & POS management")
pearl_group = app_commands.Group(name="pearl", description="<:pearl:1428919990194536458> Pearl tracking and management")
market_group = app_commands.Group(name="market", description="üìà Business & stock market")
court_group = app_commands.Group(name="court", description="‚öñÔ∏è Court system")
bank_group = app_commands.Group(name="bank", description="üè¶ Florab√≠s State Bank")
economy_group = app_commands.Group(name="economy", description="üí∞ State Economy, Treasury & Investments")
property_group = app_commands.Group(name="property", description="üèòÔ∏è Land Registry & Property Management")
contract_group = app_commands.Group(name="contract", description="üìã Government Contracts & Public Works")
# ========================================
# LAW LIBRARY SYSTEM
# ========================================

law_group = app_commands.Group(name="law", description="üìú Law Library - Search and view passed legislation")

@law_group.command(name="search", description="Search laws by keyword")
@app_commands.describe(keyword="Search term to find in law titles or content")
async def law_search(interaction: discord.Interaction, keyword: str):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database unavailable.")
    
    try:
        # Get all passed laws
        laws = await asyncio.to_thread(lambda: list(
            db.collection(BILL_COLLECTION_NAME)
            .where(filter=FieldFilter('status', 'in', ['Passed', 'Bill is Now Law']))
            .stream()
        ))
        
        # Filter by keyword (case-insensitive search in title and content)
        keyword_lower = keyword.lower()
        matches = []
        for doc in laws:
            data = doc.to_dict()
            title = data.get('title', '').lower()
            content_text = data.get('description', '').lower()
            category = data.get('category', '').lower()
            
            if keyword_lower in title or keyword_lower in content_text or keyword_lower in category:
                matches.append(data)
        
        if not matches:
            return await interaction.followup.send(f"üìú No laws found matching **{keyword}**")
        
        # Sort by date (newest first)
        matches.sort(key=lambda x: x.get('createdAt', datetime.min), reverse=True)
        
        # Limit to 10 results
        matches = matches[:10]
        
        embed = discord.Embed(
            title=f"üìú Law Library - Search Results",
            description=f"**{len(matches)}** laws found matching: **{keyword}**",
            color=0x2E4053
        )
        
        for law in matches:
            law_id = law.get('id', 'Unknown')
            title = law.get('title', 'Untitled')[:50]
            category = law.get('category', 'General')
            passed_date = law.get('votingEndedAt') or law.get('createdAt')
            if passed_date:
                if hasattr(passed_date, 'astimezone'):
                    passed_str = passed_date.astimezone(EST).strftime('%b %d, %Y')
                else:
                    passed_str = "Unknown"
            else:
                passed_str = "Unknown"
            
            embed.add_field(
                name=f"üìã {law_id}: {title}",
                value=f"üìÅ {category} | üìÖ Passed: {passed_str}\nUse `/law view {law_id}` to read",
                inline=False
            )
        
        embed.set_footer(text="Use /law view <id> to read full law text")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Law search failed: {e}")
        await interaction.followup.send(f"‚ùå Search failed: {str(e)}")


@law_group.command(name="view", description="View a specific law by ID")
@app_commands.describe(law_id="The law/bill ID to view")
async def law_view(interaction: discord.Interaction, law_id: str):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database unavailable.")
    
    try:
        # Find the law
        laws = await asyncio.to_thread(lambda: list(
            db.collection(BILL_COLLECTION_NAME)
            .where(filter=FieldFilter('id', '==', law_id.upper()))
            .limit(1)
            .stream()
        ))
        
        if not laws:
            return await interaction.followup.send(f"‚ùå Law **{law_id}** not found.")
        
        law = laws[0].to_dict()
        
        # Check if it's actually passed
        if law.get('status') not in ['Passed', 'Bill is Now Law']:
            return await interaction.followup.send(f"‚ùå **{law_id}** is not a passed law (Status: {law.get('status')})")
        
        title = law.get('title', 'Untitled')
        description = law.get('description', 'No content')
        category = law.get('category', 'General')
        author_name = law.get('author', 'Unknown')
        
        # Get dates
        created_at = law.get('createdAt')
        passed_at = law.get('votingEndedAt') or created_at
        
        if passed_at and hasattr(passed_at, 'astimezone'):
            passed_str = passed_at.astimezone(EST).strftime('%B %d, %Y at %I:%M %p EST')
        else:
            passed_str = "Unknown"
        
        # Get vote counts
        yes_votes = law.get('yesVotes', 0)
        no_votes = law.get('noVotes', 0)
        abstain = law.get('abstainVotes', 0)
        
        embed = discord.Embed(
            title=f"üìú {title}",
            description=f"**Law ID:** {law_id.upper()}",
            color=0x27AE60  # Green for passed law
        )
        
        embed.add_field(name="üìÅ Category", value=category, inline=True)
        embed.add_field(name="‚úçÔ∏è Author", value=author_name, inline=True)
        embed.add_field(name="üìÖ Enacted", value=passed_str, inline=True)
        embed.add_field(name="üó≥Ô∏è Final Vote", value=f"‚úÖ {yes_votes} | ‚ùå {no_votes} | ‚¨ú {abstain}", inline=True)
        
        # Content - truncate if too long
        if len(description) > 1024:
            embed.add_field(name="üìù Law Text", value=description[:1020] + "...", inline=False)
            embed.add_field(name="‚ö†Ô∏è Note", value="Law text truncated. Full text may be available in original bill.", inline=False)
        else:
            embed.add_field(name="üìù Law Text", value=description, inline=False)
        
        embed.set_footer(text=f"Florab√≠s Law Library | {law_id.upper()}")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Law view failed: {e}")
        await interaction.followup.send(f"‚ùå Failed to view law: {str(e)}")


@law_group.command(name="list", description="List all passed laws by category")
@app_commands.describe(category="Filter by category (optional)")
@app_commands.choices(category=[
    app_commands.Choice(name="All Categories", value="all"),
    app_commands.Choice(name="Constitutional", value="Constitutional"),
    app_commands.Choice(name="Criminal", value="Criminal"),
    app_commands.Choice(name="Civil", value="Civil"),
    app_commands.Choice(name="Economic", value="Economic"),
    app_commands.Choice(name="Administrative", value="Administrative"),
    app_commands.Choice(name="Foreign Affairs", value="Foreign Affairs"),
    app_commands.Choice(name="Military", value="Military"),
])
async def law_list(interaction: discord.Interaction, category: str = "all"):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database unavailable.")
    
    try:
        # Get all passed laws
        laws = await asyncio.to_thread(lambda: list(
            db.collection(BILL_COLLECTION_NAME)
            .where(filter=FieldFilter('status', 'in', ['Passed', 'Bill is Now Law']))
            .stream()
        ))
        
        laws_data = [doc.to_dict() for doc in laws]
        
        # Filter by category if specified
        if category != "all":
            laws_data = [l for l in laws_data if l.get('category', '').lower() == category.lower()]
        
        if not laws_data:
            cat_text = f" in category **{category}**" if category != "all" else ""
            return await interaction.followup.send(f"üìú No passed laws found{cat_text}.")
        
        # Sort by date (newest first)
        laws_data.sort(key=lambda x: x.get('votingEndedAt') or x.get('createdAt') or datetime.min, reverse=True)
        
        # Group by category if showing all
        if category == "all":
            by_category = {}
            for law in laws_data:
                cat = law.get('category', 'General')
                if cat not in by_category:
                    by_category[cat] = []
                by_category[cat].append(law)
            
            embed = discord.Embed(
                title="üìú Florab√≠s Law Library",
                description=f"**{len(laws_data)}** laws currently in effect",
                color=0x2E4053
            )
            
            for cat, cat_laws in sorted(by_category.items()):
                law_list_text = ""
                for law in cat_laws[:5]:  # Max 5 per category
                    law_id = law.get('id', '?')
                    title = law.get('title', 'Untitled')[:40]
                    law_list_text += f"‚Ä¢ **{law_id}**: {title}\n"
                if len(cat_laws) > 5:
                    law_list_text += f"*...and {len(cat_laws) - 5} more*\n"
                embed.add_field(name=f"üìÅ {cat} ({len(cat_laws)})", value=law_list_text or "None", inline=False)
        else:
            embed = discord.Embed(
                title=f"üìú Laws: {category}",
                description=f"**{len(laws_data)}** laws in this category",
                color=0x2E4053
            )
            
            for law in laws_data[:15]:  # Max 15
                law_id = law.get('id', '?')
                title = law.get('title', 'Untitled')[:50]
                passed_at = law.get('votingEndedAt') or law.get('createdAt')
                if passed_at and hasattr(passed_at, 'astimezone'):
                    passed_str = passed_at.astimezone(EST).strftime('%b %Y')
                else:
                    passed_str = "?"
                embed.add_field(
                    name=f"üìã {law_id}",
                    value=f"{title}\nüìÖ {passed_str}",
                    inline=True
                )
        
        embed.set_footer(text="Use /law view <id> to read full law text")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Law list failed: {e}")
        await interaction.followup.send(f"‚ùå Failed to list laws: {str(e)}")


@law_group.command(name="recent", description="View recently passed laws")
@app_commands.describe(count="Number of recent laws to show (default 5, max 10)")
async def law_recent(interaction: discord.Interaction, count: int = 5):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database unavailable.")
    
    count = min(max(1, count), 10)  # Clamp between 1 and 10
    
    try:
        # Get all passed laws
        laws = await asyncio.to_thread(lambda: list(
            db.collection(BILL_COLLECTION_NAME)
            .where(filter=FieldFilter('status', 'in', ['Passed', 'Bill is Now Law']))
            .stream()
        ))
        
        laws_data = [doc.to_dict() for doc in laws]
        
        if not laws_data:
            return await interaction.followup.send("üìú No passed laws found.")
        
        # Sort by passed date (newest first)
        laws_data.sort(key=lambda x: x.get('votingEndedAt') or x.get('createdAt') or datetime.min, reverse=True)
        laws_data = laws_data[:count]
        
        embed = discord.Embed(
            title="üìú Recently Passed Laws",
            description=f"The **{len(laws_data)}** most recently enacted laws",
            color=0x27AE60
        )
        
        for i, law in enumerate(laws_data, 1):
            law_id = law.get('id', '?')
            title = law.get('title', 'Untitled')[:50]
            category = law.get('category', 'General')
            passed_at = law.get('votingEndedAt') or law.get('createdAt')
            
            if passed_at and hasattr(passed_at, 'astimezone'):
                passed_str = passed_at.astimezone(EST).strftime('%b %d, %Y')
            else:
                passed_str = "Unknown"
            
            yes_votes = law.get('yesVotes', 0)
            no_votes = law.get('noVotes', 0)
            
            embed.add_field(
                name=f"{i}. {title}",
                value=f"**ID:** {law_id} | **Category:** {category}\nüìÖ Passed: {passed_str} | üó≥Ô∏è {yes_votes}-{no_votes}",
                inline=False
            )
        
        embed.set_footer(text="Use /law view <id> to read full law text")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Law recent failed: {e}")
        await interaction.followup.send(f"‚ùå Failed to fetch recent laws: {str(e)}")


@law_group.command(name="stats", description="View law library statistics")
async def law_stats(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database unavailable.")
    
    try:
        # Get all bills
        all_bills = await asyncio.to_thread(lambda: list(
            db.collection(BILL_COLLECTION_NAME).stream()
        ))
        
        bills_data = [doc.to_dict() for doc in all_bills]
        
        # Filter out test bills (case-insensitive check for "test" in title)
        def is_test_bill(b):
            title = b.get('title', '').lower()
            return 'test' in title or b.get('isTest', False)
        
        real_bills = [b for b in bills_data if not is_test_bill(b)]
        test_bills = [b for b in bills_data if is_test_bill(b)]
        
        # Count by status (only real bills)
        passed = [b for b in real_bills if b.get('status') in ['Passed', 'Bill is Now Law']]
        failed = [b for b in real_bills if b.get('status') == 'Failed']
        vetoed = [b for b in real_bills if b.get('status') == 'Vetoed']
        voting = [b for b in real_bills if b.get('status') == 'Voting']
        
        # Count by category
        category_counts = {}
        for law in passed:
            cat = law.get('category', 'General')
            category_counts[cat] = category_counts.get(cat, 0) + 1
        
        embed = discord.Embed(
            title="üìä Law Library Statistics",
            description="Overview of Florab√≠s legislation (excludes test bills)",
            color=0x2E4053
        )
        
        embed.add_field(name="üìú Laws Enacted", value=str(len(passed)), inline=True)
        embed.add_field(name="‚ùå Bills Failed", value=str(len(failed)), inline=True)
        embed.add_field(name="üö´ Bills Vetoed", value=str(len(vetoed)), inline=True)
        embed.add_field(name="üó≥Ô∏è Currently Voting", value=str(len(voting)), inline=True)
        embed.add_field(name="üìã Bills Filed", value=str(len(real_bills)), inline=True)
        
        # Pass rate
        total_decided = len(passed) + len(failed)
        if total_decided > 0:
            pass_rate = (len(passed) / total_decided) * 100
            embed.add_field(name="‚úÖ Pass Rate", value=f"{pass_rate:.1f}%", inline=True)
        
        # Show test bills excluded
        if test_bills:
            embed.add_field(name="üß™ Test Bills Excluded", value=str(len(test_bills)), inline=True)
        
        # Category breakdown
        if category_counts:
            cat_text = "\n".join([f"‚Ä¢ **{cat}:** {count}" for cat, count in sorted(category_counts.items(), key=lambda x: -x[1])])
            embed.add_field(name="üìÅ Laws by Category", value=cat_text, inline=False)
        
        # List passed laws
        if passed:
            laws_list = []
            for law in passed[:10]:
                law_id = law.get('id', '?')
                title = law.get('title', 'Untitled')[:35]
                laws_list.append(f"‚Ä¢ **{law_id}**: {title}")
            if len(passed) > 10:
                laws_list.append(f"*...and {len(passed) - 10} more*")
            embed.add_field(name="üìú Enacted Laws", value="\n".join(laws_list), inline=False)
        
        embed.set_footer(text="Florab√≠s Law Library | Use /law view <id> for details")
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Law stats failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Failed to get stats: {str(e)}")

bot.tree.add_command(law_group)



# Add groups to bot command tree
bot.tree.add_command(betting_group)
bot.tree.add_command(warrant_group)
bot.tree.add_command(pearl_group)
bot.tree.add_command(market_group)
bot.tree.add_command(court_group)
# ARCHIVED: bot.tree.add_command(bank_group)
bot.tree.add_command(economy_group)
bot.tree.add_command(property_group)
bot.tree.add_command(contract_group)


# ---------- BILL CREATION MODAL & BUTTONS ----------

# Category Select Menu
class CategorySelect(ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="Defense and Security", description="Defense and Security Councilor", emoji="üõ°Ô∏è", value="Defense and Security Councilor"),
            discord.SelectOption(label="Works and Infrastructure", description="Works and Infrastructure Councilor", emoji="üèóÔ∏è", value="Works and Infrastructure Councilor"),
            discord.SelectOption(label="Economy and Finance", description="Economy and Finance Councilor", emoji="üí∞", value="Economy and Finance Councilor"),
            discord.SelectOption(label="Justice and Law", description="Justice and Law Councilor", emoji="‚öñÔ∏è", value="Justice and Law Councilor"),
            discord.SelectOption(label="Culture and Heritage", description="Culture and Heritage Councilor", emoji="üé≠", value="Culture and Heritage Councilor"),
            discord.SelectOption(label="Agriculture and Resources", description="Agriculture and Resources Councilor", emoji="üåæ", value="Agriculture and Resources Councilor"),
            discord.SelectOption(label="Mining and Natural Resources", description="Mining and Natural Resources Councilor", emoji="‚õèÔ∏è", value="Mining and Natural Resources Councilor"),
            discord.SelectOption(label="Population and Settlement", description="Population and Settlement Councilor", emoji="üë•", value="Population and Settlement Councilor"),
            discord.SelectOption(label="General", description="General/Uncategorized", emoji="üìã", value="General"),
        ]
        super().__init__(placeholder="Select a Councilor Domain (Category)", options=options, min_values=1, max_values=1)
    
    async def callback(self, interaction: discord.Interaction):
        selected_category = self.values[0]
        view = self.view
        
        # Store category and show modal
        modal = BillCreationModal(
            visibility=view.visibility,
            voting_threshold=view.voting_threshold,
            bill_type=view.bill_type,
            category=selected_category
        )
        await interaction.response.send_modal(modal)

class CategorySelectView(ui.View):
    def __init__(self, visibility: str = 'PUBLIC', voting_threshold: str = 'SIMPLE_MAJORITY', bill_type: str = 'STANDARD'):
        super().__init__(timeout=300)
        self.visibility = visibility
        self.voting_threshold = voting_threshold
        self.bill_type = bill_type
        self.add_item(CategorySelect())

class BillCreationModal(ui.Modal, title="Create a Bill"):
    bill_title = ui.TextInput(label="Bill Title", placeholder="Enter bill title", max_length=100)
    bill_description = ui.TextInput(
        label="Description", 
        placeholder="Describe what this bill does", 
        style=discord.TextStyle.paragraph,
        max_length=1000
    )
    
    def __init__(self, visibility: str = 'PUBLIC', voting_threshold: str = 'SIMPLE_MAJORITY', bill_type: str = 'STANDARD', category: str = 'General'):
        super().__init__()
        self.visibility = visibility
        self.voting_threshold = voting_threshold
        self.bill_type = bill_type
        self.category = category
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="Database not available.")
        
        title = self.bill_title.value
        category = self.category  # Use pre-selected category from dropdown
        description = self.bill_description.value
        
        edict_text = f"By the authority of the Royal Council, be it known that...\n\n{description}"
        
        try:
            bill_ref = db.collection(BILL_COLLECTION_NAME).document()
            bill_id = bill_ref.id[:6].upper()
            
            # Constitutional Amendments skip sponsorship and go straight to voting with 2/3 majority
            is_constitutional = self.bill_type == 'CONSTITUTIONAL_AMENDMENT'
            initial_status = BILL_STATUSES['VOTING'] if is_constitutional else BILL_STATUSES['AWAITING_SPONSOR']
            threshold = 'TWO_THIRDS_VOTES' if is_constitutional else self.voting_threshold
            
            # Assign bill number if going straight to voting
            bill_title = title
            if is_constitutional:
                bill_number = get_next_bill_number()
                if bill_number:
                    bill_title = f"R.C. {bill_number:03d} - {title}"
            
            new_bill = {
                'id': bill_id,
                'title': bill_title,
                'category': category,
                'text': edict_text,
                'proposerId': interaction.user.id,
                'proposerTag': interaction.user.mention,
                'sponsorId': interaction.user.id if is_constitutional else None,
                'sponsorTag': interaction.user.mention if is_constitutional else None,
                'sponsorDomain': 'Constitutional Amendment' if is_constitutional else None,
                'status': initial_status,
                'billType': self.bill_type,
                'visibility': self.visibility,
                'votingThreshold': threshold,
                'requiredCoSponsors': REQUIRED_CO_SPONSORS_DEFAULT,
                'coSponsors': [],
                'votes': {'yes': [], 'no': [], 'abstain': []},
                'createdAt': datetime.now(),
                'channelId': interaction.channel.id if interaction.channel else 0,
                'guildId': interaction.guild.id if interaction.guild else 0,
            }
            
            # Add voting start time and bill number for constitutional amendments
            if is_constitutional:
                new_bill['votingStartAt'] = datetime.now(timezone.utc)
                if bill_number:
                    new_bill['billNumber'] = bill_number
            
            await asyncio.to_thread(lambda: bill_ref.set(new_bill))
        except Exception as e:
            print(f"[ERR] Firestore save failed: {e}")
            return await interaction.edit_original_response(content="Failed to register the Edict.")
        
        visibility_text = "A public bill" if self.visibility == 'PUBLIC' else "A Confidential Bill"
        
        # Determine posting channel based on bill status
        posting_channel = interaction.channel
        if interaction.guild:
            # Bills awaiting sponsor/pending go to PROPOSED_CHANNEL_ID
            # Bills in voting go to VOTING_CHANNEL_ID
            if initial_status in ('Awaiting Sponsor', 'Pending') and PROPOSED_CHANNEL_ID:
                proposed_channel = interaction.guild.get_channel(PROPOSED_CHANNEL_ID)
                if proposed_channel:
                    posting_channel = proposed_channel
            elif initial_status == 'Voting' and VOTING_CHANNEL_ID:
                voting_channel = interaction.guild.get_channel(VOTING_CHANNEL_ID)
                if voting_channel:
                    posting_channel = voting_channel
        
        bill_message = await posting_channel.send(
            content=f"**{visibility_text}** by {interaction.user.mention}",
            embed=get_bill_embed(new_bill),
            view=BillConsole(bill_id=bill_id)
        )
        
        # Save the message ID back to the database so we can update it later
        try:
            await asyncio.to_thread(lambda: bill_ref.update({'messageId': bill_message.id, 'channelId': posting_channel.id}))
        except Exception as e:
            print(f"[WARN] Could not save message ID: {e}")
        
        await interaction.edit_original_response(content=f"‚úÖ Bill **{bill_id}** created successfully!")

class CreateBillButton(ui.Button):
    def __init__(self, label: str, visibility: str, voting_threshold: str = 'SIMPLE_MAJORITY', bill_type: str = 'STANDARD', style=discord.ButtonStyle.primary, custom_id: str = None):
        super().__init__(label=label, style=style, custom_id=custom_id)
        self.visibility = visibility
        self.voting_threshold = voting_threshold
        self.bill_type = bill_type
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout (critical for persistent panels)
        category_view = CategorySelectView(
            visibility=self.visibility,
            voting_threshold=self.voting_threshold,
            bill_type=self.bill_type
        )
        await interaction.response.send_message(
            "**Select Councilor Domain (Category) for this bill:**",
            view=category_view, ephemeral=True)

class BillCreationPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(CreateBillButton("üìú Public Bill", "PUBLIC", "SIMPLE_MAJORITY", "STANDARD", discord.ButtonStyle.primary, "portal_public_bill"))
        self.add_item(CreateBillButton("üîí Confidential Bill", "CONFIDENTIAL", "SIMPLE_MAJORITY", "STANDARD", discord.ButtonStyle.secondary, "portal_confidential_bill"))
        self.add_item(CreateBillButton("‚öñÔ∏è Constitutional Amendment", "PUBLIC", "TWO_THIRDS_VOTES", "CONSTITUTIONAL_AMENDMENT", discord.ButtonStyle.success, "portal_constitutional_amendment"))

# ---------- SLASH COMMANDS ----------
@bot.tree.command(name="setup", description="[ADMIN ONLY] Setup the bill creation panel in this channel")
async def setup_panel(interaction: discord.Interaction):
    # Admin-only check BEFORE defer
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    # Respond immediately with the panel
    embed = discord.Embed(
        title="‚öúÔ∏è Legislative Initiative Portal",
        description=(
            "**Florab√≠s Royal Council - Bill Submission**\n\n"
            "Consejeros (Councilors) may propose legislation by selecting the appropriate bill type below. "
            "All bills are subject to a 24-hour voting period before finalization.\n\n"
            "**Bill Types:**\n"
            "üìú **Public Bill** - Standard legislation with transparent voting\n"
            "üîí **Confidential Bill** - Anonymous voting process\n"
            "‚öñÔ∏è **Constitutional Amendment** - Amendments to Florab√≠s Constitution"
        ),
        color=discord.Color.from_str("#794966")
    )
    embed.set_footer(text="By authority of the Royal Council ‚Ä¢ Select a bill type to begin")
    
    # Send confirmation FIRST (must respond to interaction before anything else)
    await interaction.response.send_message("‚úÖ Legislative portal posted successfully!", ephemeral=True)
    
    # Post panel to channel
    message = await interaction.channel.send(embed=embed, view=BillCreationPanel())
    
    # Do cleanup and storage in background (non-blocking)
    if db and interaction.guild:
        try:
            # Delete old panels - wrap blocking .stream() call
            q = db.collection(PORTAL_PANELS_COLLECTION).where(filter=FieldFilter('guildId', '==', interaction.guild.id)).limit(1)
            q_list = await asyncio.to_thread(lambda: list(q.stream()))
            for doc in q_list:
                old_data = doc.to_dict()
                old_channel = interaction.guild.get_channel(old_data.get('channelId'))
                if old_channel:
                    try:
                        old_message = await old_channel.fetch_message(old_data.get('messageId'))
                        await old_message.delete()
                    except:
                        pass
                doc.reference.delete()
        except:
            pass
        
        # Store new panel
        try:
            await asyncio.to_thread(lambda: db.collection(PORTAL_PANELS_COLLECTION).document().set({
                'guildId': interaction.guild.id,
                'channelId': interaction.channel.id,
                'messageId': message.id,
                'createdAt': datetime.now(timezone.utc)
            }))
        except Exception as e:
            print(f"[WARN] Could not store portal panel: {e}")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SETUP STATUS & WIZARD COMMANDS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@bot.tree.command(name="setup_status", description="[ADMIN] View configuration status of all bot panels")
async def setup_status_cmd(interaction: discord.Interaction):
    """Show status of all configured panels"""
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    current_db = await ensure_firestore()
    if not current_db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    try:
        guild_id = interaction.guild.id
        status_lines = []
        configured_count = 0
        total_panels = 8
        
        panel_configs = [
            ("Legislative Portal", PORTAL_PANELS_COLLECTION, None, "guildId", "/setup"),
            ("Court System", PORTAL_PANELS_COLLECTION, "court_panel", None, "/court_panel"),
            ("Citizen Registration", PORTAL_PANELS_COLLECTION, "citizen_panel", None, "/citizen_panel"),
            ("Warrant/POS Display", PORTAL_PANELS_COLLECTION, "warrant_panel", None, "/warrant post_panel"),
            ("Pearl Facility", PEARL_PANELS_COLLECTION, "pearl_panel", None, "/pearl post_panel"),
            ("Economy Dashboard", PORTAL_PANELS_COLLECTION, "economy_panel", None, "/economy_panel"),
            ("Stock Market", PORTAL_PANELS_COLLECTION, "market_panel", None, "/market_panel"),
            ("Betting Exchange", PORTAL_PANELS_COLLECTION, "betting_panel", None, "/betting_panel"),
        ]
        
        for panel_name, collection, doc_id, guild_field, command in panel_configs:
            try:
                if doc_id:
                    doc = await asyncio.to_thread(
                        lambda d=doc_id, c=collection: current_db.collection(c).document(d).get()
                    )
                    if doc.exists:
                        data = doc.to_dict()
                        channel_id = data.get('channelId')
                        channel = interaction.guild.get_channel(channel_id) if channel_id else None
                        if channel:
                            status_lines.append(f"‚úÖ **{panel_name}** ‚Üí {channel.mention}")
                            configured_count += 1
                        else:
                            status_lines.append(f"‚ö†Ô∏è **{panel_name}** ‚Üí Channel not found (run `{command}`)")
                    else:
                        status_lines.append(f"‚ùå **{panel_name}** ‚Üí Not configured (run `{command}`)")
                else:
                    q = current_db.collection(collection).where(filter=FieldFilter(guild_field, '==', guild_id)).limit(1)
                    docs = await asyncio.to_thread(lambda: list(q.stream()))
                    if docs:
                        data = docs[0].to_dict()
                        channel_id = data.get('channelId')
                        channel = interaction.guild.get_channel(channel_id) if channel_id else None
                        if channel:
                            status_lines.append(f"‚úÖ **{panel_name}** ‚Üí {channel.mention}")
                            configured_count += 1
                        else:
                            status_lines.append(f"‚ö†Ô∏è **{panel_name}** ‚Üí Channel not found (run `{command}`)")
                    else:
                        status_lines.append(f"‚ùå **{panel_name}** ‚Üí Not configured (run `{command}`)")
            except Exception as e:
                status_lines.append(f"‚ö†Ô∏è **{panel_name}** ‚Üí Error checking status")
        
        progress_pct = int((configured_count / total_panels) * 100)
        progress_bar = "‚ñà" * (configured_count) + "‚ñë" * (total_panels - configured_count)
        
        embed = discord.Embed(
            title="üõ†Ô∏è Bot Configuration Status",
            description=f"**Progress: {configured_count}/{total_panels} panels configured** ({progress_pct}%)\n`[{progress_bar}]`",
            color=discord.Color.green() if configured_count == total_panels else discord.Color.gold()
        )
        embed.add_field(name="Panel Status", value="\n".join(status_lines), inline=False)
        
        if configured_count < total_panels:
            embed.add_field(
                name="üí° Quick Setup",
                value="Use `/setup_wizard` for guided panel deployment",
                inline=False
            )
        else:
            embed.set_footer(text="‚ú® All panels are configured!")
        
        await interaction.followup.send(embed=embed, ephemeral=True)
        
    except Exception as e:
        print(f"[ERR] Setup status error: {e}")
        await interaction.followup.send("‚ùå Failed to check configuration status.", ephemeral=True)


class SetupWizardView(discord.ui.View):
    """Interactive wizard for deploying panels"""
    
    def __init__(self, user_id: int):
        super().__init__(timeout=300)
        self.user_id = user_id
        self.current_step = 0
        self.steps = [
            ("Legislative Portal", "setup_legislative", "üìú Bill creation and voting system"),
            ("Citizen Registration", "setup_citizen", "üë• Self-registration for citizens"),
            ("Court System", "setup_court", "‚öñÔ∏è Case filing and management"),
            ("Warrant/POS Display", "setup_warrant", "üö® Warrants and snitch alerts"),
            ("Pearl Facility", "setup_pearl", "üíé Pearl sentence tracking"),
            ("Economy Dashboard", "setup_economy", "üí∞ Treasury and economy overview"),
            ("Stock Market", "setup_market", "üìà Business and share trading"),
            ("Betting Exchange", "setup_betting", "üé∞ Pari-mutuel betting system"),
        ]
    
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå This wizard is not for you.", ephemeral=True)
            return False
        return True
    
    def get_embed(self):
        if self.current_step >= len(self.steps):
            embed = discord.Embed(
                title="‚úÖ Setup Wizard Complete!",
                description="All panels have been offered. Use `/setup_status` to see your configuration.",
                color=discord.Color.green()
            )
            return embed
        
        step_name, _, step_desc = self.steps[self.current_step]
        embed = discord.Embed(
            title=f"üõ†Ô∏è Setup Wizard - Step {self.current_step + 1}/{len(self.steps)}",
            description=f"**{step_name}**\n{step_desc}",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="Instructions",
            value="Click **Deploy Here** to set up this panel in the current channel, or **Skip** to move to the next panel.",
            inline=False
        )
        embed.set_footer(text=f"Step {self.current_step + 1} of {len(self.steps)}")
        return embed
    
    def update_buttons(self):
        self.clear_items()
        if self.current_step >= len(self.steps):
            self.add_item(SetupWizardDoneButton())
        else:
            self.add_item(SetupWizardDeployButton(self.steps[self.current_step]))
            self.add_item(SetupWizardSkipButton())
            if self.current_step > 0:
                self.add_item(SetupWizardBackButton())


class SetupWizardDeployButton(discord.ui.Button):
    def __init__(self, step_info):
        super().__init__(style=discord.ButtonStyle.success, label="Deploy Here", emoji="‚úÖ")
        self.step_info = step_info
    
    async def callback(self, interaction: discord.Interaction):
        view: SetupWizardView = self.view
        step_name, step_key, _ = self.step_info
        
        await interaction.response.defer(ephemeral=True)
        
        try:
            if step_key == "setup_legislative":
                embed = discord.Embed(
                    title="‚öúÔ∏è Legislative Initiative Portal",
                    description=(
                        "**Florab√≠s Royal Council - Bill Submission**\n\n"
                        "Consejeros (Councilors) may propose legislation by selecting the appropriate bill type below. "
                        "All bills are subject to a 24-hour voting period before finalization.\n\n"
                        "**Bill Types:**\n"
                        "üìú **Public Bill** - Standard legislation with transparent voting\n"
                        "üîí **Confidential Bill** - Anonymous voting process\n"
                        "‚öñÔ∏è **Constitutional Amendment** - Amendments to Florab√≠s Constitution"
                    ),
                    color=discord.Color.from_str("#794966")
                )
                embed.set_footer(text="By authority of the Royal Council ‚Ä¢ Select a bill type to begin")
                message = await interaction.channel.send(embed=embed, view=BillCreationPanel())
                
                current_db = await ensure_firestore()
                if current_db:
                    q = current_db.collection(PORTAL_PANELS_COLLECTION).where(filter=FieldFilter('guildId', '==', interaction.guild.id)).limit(1)
                    for doc in await asyncio.to_thread(lambda: list(q.stream())):
                        try:
                            old_channel = interaction.guild.get_channel(doc.to_dict().get('channelId'))
                            if old_channel:
                                old_msg = await old_channel.fetch_message(doc.to_dict().get('messageId'))
                                await old_msg.delete()
                        except:
                            pass
                        doc.reference.delete()
                    await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document().set({
                        'guildId': interaction.guild.id,
                        'channelId': interaction.channel.id,
                        'messageId': message.id,
                        'createdAt': datetime.now(timezone.utc)
                    }))
                    
            elif step_key == "setup_citizen":
                embed = discord.Embed(
                    title="üèõÔ∏è Florab√≠s Citizen Registration",
                    description=(
                        "**Welcome to Florab√≠s!**\n\n"
                        "Register as a citizen to participate in our nation. "
                        "Click the button below to begin your registration.\n\n"
                        "**Benefits of Citizenship:**\n"
                        "‚Ä¢ Vote in state referendums\n"
                        "‚Ä¢ Access citizen-only channels\n"
                        "‚Ä¢ Participate in the economy\n"
                        "‚Ä¢ File court cases and legal actions"
                    ),
                    color=discord.Color.from_str("#794966")
                )
                embed.set_footer(text="Florab√≠s Government ‚Ä¢ Click below to register")
                message = await interaction.channel.send(embed=embed, view=CitizenRegistrationPanel())
                
                current_db = await ensure_firestore()
                if current_db:
                    await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('citizen_panel').set({
                        'guildId': interaction.guild.id,
                        'channelId': interaction.channel.id,
                        'messageId': message.id,
                        'createdAt': datetime.now(timezone.utc)
                    }))
                    
            elif step_key == "setup_court":
                embed = discord.Embed(
                    title="‚öñÔ∏è Florab√≠s Court System",
                    description=(
                        "**Royal Court of Florab√≠s**\n\n"
                        "File criminal or civil cases through our justice system.\n\n"
                        "**Case Types:**\n"
                        "üî¥ **Criminal** - State prosecution for crimes\n"
                        "üîµ **Civil** - Disputes between citizens\n\n"
                        "All cases are heard by appointed Magistrates."
                    ),
                    color=discord.Color.from_str("#794966")
                )
                embed.set_footer(text="Florab√≠s Justice System ‚Ä¢ Select case type below")
                message = await interaction.channel.send(embed=embed, view=CourtPanelView())
                
                current_db = await ensure_firestore()
                if current_db:
                    await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('court_panel').set({
                        'guildId': interaction.guild.id,
                        'channelId': interaction.channel.id,
                        'messageId': message.id,
                        'createdAt': datetime.now(timezone.utc)
                    }))
                    
            elif step_key == "setup_warrant":
                job_data = {
                    'type': 'warrant_panel',
                    'guildId': interaction.guild.id,
                    'channelId': interaction.channel.id,
                    'requestedBy': interaction.user.id,
                    'createdAt': datetime.now(timezone.utc),
                    'status': 'pending'
                }
                current_db = await ensure_firestore()
                if current_db:
                    await asyncio.to_thread(lambda: current_db.collection('florabi_panel_jobs').add(job_data))
                await interaction.followup.send(f"‚úÖ **{step_name}** queued for deployment (posts within 30 seconds).", ephemeral=True)
                view.current_step += 1
                view.update_buttons()
                await interaction.edit_original_response(embed=view.get_embed(), view=view)
                return
                    
            elif step_key == "setup_pearl":
                job_data = {
                    'type': 'pearl_panel',
                    'guildId': interaction.guild.id,
                    'channelId': interaction.channel.id,
                    'requestedBy': interaction.user.id,
                    'createdAt': datetime.now(timezone.utc),
                    'status': 'pending'
                }
                current_db = await ensure_firestore()
                if current_db:
                    await asyncio.to_thread(lambda: current_db.collection('florabi_panel_jobs').add(job_data))
                await interaction.followup.send(f"‚úÖ **{step_name}** queued for deployment (posts within 30 seconds).", ephemeral=True)
                view.current_step += 1
                view.update_buttons()
                await interaction.edit_original_response(embed=view.get_embed(), view=view)
                return
                    
            elif step_key == "setup_economy":
                job_data = {
                    'type': 'economy_panel',
                    'guildId': interaction.guild.id,
                    'channelId': interaction.channel.id,
                    'requestedBy': interaction.user.id,
                    'createdAt': datetime.now(timezone.utc),
                    'status': 'pending'
                }
                current_db = await ensure_firestore()
                if current_db:
                    await asyncio.to_thread(lambda: current_db.collection('florabi_panel_jobs').add(job_data))
                await interaction.followup.send(f"‚úÖ **{step_name}** queued for deployment (posts within 30 seconds).", ephemeral=True)
                view.current_step += 1
                view.update_buttons()
                await interaction.edit_original_response(embed=view.get_embed(), view=view)
                return
                    
            elif step_key == "setup_market":
                embed = discord.Embed(
                    title="üìà Florab√≠s Stock Market",
                    description=(
                        "**Royal Stock Exchange**\n\n"
                        "Trade shares in Florab√≠s businesses.\n\n"
                        "‚Ä¢ View market listings\n"
                        "‚Ä¢ Buy and sell shares\n"
                        "‚Ä¢ Track your portfolio"
                    ),
                    color=discord.Color.from_str("#2ecc71")
                )
                embed.set_footer(text="Florab√≠s Stock Exchange")
                message = await interaction.channel.send(embed=embed, view=MarketPanelView())
                
                current_db = await ensure_firestore()
                if current_db:
                    await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('market_panel').set({
                        'guildId': interaction.guild.id,
                        'channelId': interaction.channel.id,
                        'messageId': message.id,
                        'createdAt': datetime.now(timezone.utc)
                    }))
                    
            elif step_key == "setup_betting":
                embed = discord.Embed(
                    title="üé∞ Tom Brady's Royal Betting Exchange",
                    description=(
                        "**Place Your Bets!**\n\n"
                        "Bet on events using diamonds. Pari-mutuel system means odds change based on the pool.\n\n"
                        "Click below to view active events and place bets."
                    ),
                    color=discord.Color.from_str("#9b59b6")
                )
                embed.set_footer(text="Florab√≠s Betting Exchange ‚Ä¢ Gamble responsibly")
                message = await interaction.channel.send(embed=embed, view=BettingPanelView())
                
                current_db = await ensure_firestore()
                if current_db:
                    await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('betting_panel').set({
                        'guildId': interaction.guild.id,
                        'channelId': interaction.channel.id,
                        'messageId': message.id,
                        'createdAt': datetime.now(timezone.utc)
                    }))
            
            await interaction.followup.send(f"‚úÖ **{step_name}** deployed successfully!", ephemeral=True)
            
        except Exception as e:
            print(f"[ERR] Wizard deploy error: {e}")
            await interaction.followup.send(f"‚ùå Failed to deploy {step_name}: {str(e)[:100]}", ephemeral=True)
        
        view.current_step += 1
        view.update_buttons()
        await interaction.edit_original_response(embed=view.get_embed(), view=view)


class SetupWizardSkipButton(discord.ui.Button):
    def __init__(self):
        super().__init__(style=discord.ButtonStyle.secondary, label="Skip", emoji="‚è≠Ô∏è")
    
    async def callback(self, interaction: discord.Interaction):
        view: SetupWizardView = self.view
        view.current_step += 1
        view.update_buttons()
        await interaction.response.edit_message(embed=view.get_embed(), view=view)


class SetupWizardBackButton(discord.ui.Button):
    def __init__(self):
        super().__init__(style=discord.ButtonStyle.secondary, label="Back", emoji="‚¨ÖÔ∏è")
    
    async def callback(self, interaction: discord.Interaction):
        view: SetupWizardView = self.view
        view.current_step -= 1
        view.update_buttons()
        await interaction.response.edit_message(embed=view.get_embed(), view=view)


class SetupWizardDoneButton(discord.ui.Button):
    def __init__(self):
        super().__init__(style=discord.ButtonStyle.success, label="Done", emoji="‚úÖ")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.edit_message(
            content="‚úÖ Setup wizard completed! Use `/setup_status` to view your configuration.",
            embed=None,
            view=None
        )


@bot.tree.command(name="setup_wizard", description="[ADMIN] Interactive wizard to deploy all bot panels")
async def setup_wizard_cmd(interaction: discord.Interaction):
    """Launch interactive setup wizard"""
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    view = SetupWizardView(interaction.user.id)
    view.update_buttons()
    
    await interaction.followup.send(
        embed=view.get_embed(),
        view=view,
        ephemeral=True
    )

@bot.tree.command(name="migrate_treasury", description="[ADMIN ONLY] One-time migration: Fix treasury data (quantity ‚Üí amount)")
async def migrate_treasury(interaction: discord.Interaction):
    """Admin-only command to migrate legacy treasury data from 'quantity' to 'amount' field"""
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Migrating treasury data...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        migrated_count = 0
        already_migrated_count = 0
        
        # Get all treasury documents - wrap blocking .stream() call
        treasury_docs = await asyncio.to_thread(lambda: list(db.collection(TREASURY_COLLECTION).stream()))
        
        for doc in treasury_docs:
            doc_data = doc.to_dict()
            commodity_name = doc.id
            
            # Check if document has 'quantity' field but not 'amount'
            if 'quantity' in doc_data and 'amount' not in doc_data:
                quantity_value = doc_data.get('quantity', 0)
                
                # Migrate: copy quantity to amount, remove quantity
                await asyncio.to_thread(lambda: doc.reference.update({
                    'amount': quantity_value,
                    'quantity': firestore.DELETE_FIELD,  # Remove old field
                    'migratedAt': datetime.now(timezone.utc),
                    'migratedBy': interaction.user.id
                }))
                migrated_count += 1
                print(f"[MIGRATION] Migrated {commodity_name}: quantity={quantity_value} ‚Üí amount={quantity_value}")
            
            elif 'amount' in doc_data:
                # Already migrated
                already_migrated_count += 1
            
            else:
                # Document has neither field (empty or corrupt)
                print(f"[WARN] Treasury document {commodity_name} has no quantity or amount field")
        
        result_msg = f"‚úÖ **Treasury Migration Complete!**\n\n"
        result_msg += f"**Migrated:** {migrated_count} commodities\n"
        result_msg += f"**Already Migrated:** {already_migrated_count} commodities\n\n"
        
        if migrated_count > 0:
            result_msg += "All treasury commands should now work correctly!\n"
            result_msg += "Old 'quantity' fields have been removed."
        else:
            result_msg += "No migration needed - all data already uses 'amount' field."
        
        await interaction.edit_original_response(content=result_msg)
        print(f"[OK] Treasury migration completed by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Treasury migration failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Migration failed: {str(e)}")

@bot.tree.command(name="delete_bill", description="[ADMIN ONLY] Delete a bill by ID")
@app_commands.describe(bill_id="The 6-character bill ID (e.g., AB12CD)")
async def delete_bill(interaction: discord.Interaction, bill_id: str):
    # Admin-only check BEFORE any async operations
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    # Respond immediately
    await interaction.response.send_message("üóëÔ∏è Deleting bill...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Find the bill
        bill_id = bill_id.upper().strip()
        doc_ref, bill_data = find_bill_by_id_sync(bill_id)
        
        if not bill_data:
            return await interaction.edit_original_response(content=f"‚ùå Bill `{bill_id}` not found.")
        
        # Delete the Discord message if it exists (in background, don't wait)
        if bill_data.get('channelId') and bill_data.get('messageId'):
            try:
                channel = interaction.guild.get_channel(bill_data['channelId'])
                if channel:
                    message = await channel.fetch_message(bill_data['messageId'])
                    await message.delete()
            except:
                pass  # Message might already be deleted
    
        # Delete from database
        doc_ref.delete()
        
        await interaction.edit_original_response(content=f"‚úÖ Bill `{bill_id}` deleted successfully!")
        
    except Exception as e:
        print(f"[ERR] Delete bill failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error deleting bill: {str(e)}")




# ARCHIVED: Decree command removed per user request
# @bot.tree.command(name="decree", description="‚ùÑÔ∏è Issue a Royal Decree (Soberante only - bypasses voting)")
@app_commands.describe(
    decree_text="The full text of the decree",
    decree_number="(Optional) Manually specify the decree number"
)
async def decree(interaction: discord.Interaction, decree_text: str, decree_number: int = None):
    await interaction.response.send_message("‚ùÑÔ∏è Issuing Royal Decree...")
    
    if not db:
        return await interaction.edit_original_response(content="Database not available.")
    
    # Check for Soberante role (1407064681226440885)
    SOBERANTE_ROLE_ID = 1407064681226440885
    is_soberante = False
    if hasattr(interaction.user, "roles"):
        is_soberante = any(getattr(r, "id", 0) == SOBERANTE_ROLE_ID for r in interaction.user.roles)
    
    if not is_soberante:
        return await interaction.edit_original_response(content="‚ùå Only the Soberante can issue Royal Decrees.")
    
    try:
        # Get decree number (manual or auto-increment)
        if decree_number is None:
            # Auto-increment from counter - wrap blocking .get() call
            counter_ref = db.collection('counters').document('royal_decrees')
            counter_doc = await asyncio.to_thread(lambda: counter_ref.get())
            
            if counter_doc.exists:
                decree_number = counter_doc.to_dict().get('count', 0) + 1
            else:
                decree_number = 1
            
            # Update the counter
            await asyncio.to_thread(lambda: counter_ref.set({'count': decree_number}))
        else:
            # Manual number provided - also update counter if this number is higher - wrap blocking .get() call
            counter_ref = db.collection('counters').document('royal_decrees')
            counter_doc = await asyncio.to_thread(lambda: counter_ref.get())
            current_count = counter_doc.to_dict().get('count', 0) if counter_doc.exists else 0
            
            # Update counter to at least this number
            if decree_number > current_count:
                await asyncio.to_thread(lambda: counter_ref.set({'count': decree_number}))
        
        # Create the decree document
        bill_ref = db.collection(BILL_COLLECTION_NAME).document()
        
        # Convert to Roman numerals for display
        decree_roman = int_to_roman(decree_number)
        
        # Format decree with custom styling
        formal_text = f"‚ùÑÔ∏è ùì°ùì∏ùîÇùì™ùìµ ùììùìÆùì¨ùìªùìÆùìÆ ‚ùÑÔ∏è\n\n{decree_text}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nùìíùìÆùìºùì™ùìªùìªùìªùüìùüéùüì"
        
        new_decree = {
            'id': str(decree_number),
            'title': f'Royal Decree {decree_roman}',
            'text': formal_text,
            'sponsorId': interaction.user.id,
            'sponsorTag': interaction.user.mention,
            'status': BILL_STATUSES['LAW'],
            'billType': 'ROYAL_DECREE',
            'visibility': 'PUBLIC',
            'votingThreshold': 'SIMPLE_MAJORITY',
            'requiredCoSponsors': 0,
            'coSponsors': [],
            'votes': {'yes': [], 'no': [], 'abstain': []},
            'createdAt': datetime.now(),
            'channelId': interaction.channel.id if interaction.channel else 0,
            'guildId': interaction.guild.id if interaction.guild else 0,
            'decreeNumber': decree_number,
        }
        
        await asyncio.to_thread(lambda: bill_ref.set(new_decree))
        
        embed = discord.Embed(
            title=f"Royal Decree {decree_roman}",
            description=formal_text,
            color=discord.Color.from_str("#004f59")
        )
        embed.set_footer(text="Royal Decree is now Law")
        
        # Post to Royal Decree channel (1406718713935433903)
        ROYAL_DECREE_CHANNEL_ID = 1406718713935433903
        posting_channel = interaction.channel
        if interaction.guild:
            decree_channel = interaction.guild.get_channel(ROYAL_DECREE_CHANNEL_ID)
            if decree_channel:
                posting_channel = decree_channel
        
        try:
            await posting_channel.send(embed=embed)
            await interaction.edit_original_response(content=f"‚úÖ Royal Decree **{decree_roman}** has been enacted as Law.")
        except discord.Forbidden:
            await interaction.edit_original_response(content=f"‚ùå Bot lacks permissions to post in <#{ROYAL_DECREE_CHANNEL_ID}>. Please give the bot 'Send Messages' and 'Embed Links' permissions in that channel.")
            print(f"[ERR] Missing permissions in channel {ROYAL_DECREE_CHANNEL_ID}")
        
    except Exception as e:
        print(f"[ERR] Decree creation failed: {e}")
        await interaction.edit_original_response(content="‚ùå Failed to create Royal Decree in database.")

# ARCHIVED: Decree edit command removed per user request
# @bot.tree.command(name="decree_edit", description="‚úèÔ∏è Edit an existing Royal Decree (Soberante only)")
@app_commands.describe(
    decree_number="The decree number to edit",
    new_decree_text="The updated text of the decree"
)
async def decree_edit(interaction: discord.Interaction, decree_number: int, new_decree_text: str):
    await interaction.response.send_message("‚úèÔ∏è Editing Royal Decree...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Check for Soberante role
    SOBERANTE_ROLE_ID = 1407064681226440885
    is_soberante = False
    if hasattr(interaction.user, "roles"):
        is_soberante = any(getattr(r, "id", 0) == SOBERANTE_ROLE_ID for r in interaction.user.roles)
    
    if not is_soberante:
        return await interaction.edit_original_response(content="‚ùå Only the Soberante can edit Royal Decrees.")
    
    try:
        # Find the decree to edit - query only on billType to avoid composite index requirement
        # Wrap blocking .stream() call
        bills_query = await asyncio.to_thread(lambda: list(db.collection(BILL_COLLECTION_NAME).where(
            filter=FieldFilter('billType', '==', 'ROYAL_DECREE')
        ).stream()))
        
        # Filter in code to find matching decree number
        decree_doc = None
        for doc in bills_query:
            doc_data = doc.to_dict()
            if doc_data.get('decreeNumber') == decree_number:
                decree_doc = doc
                break
        
        if not decree_doc:
            return await interaction.edit_original_response(content=f"‚ùå Royal Decree {decree_number} not found.")
        
        # Convert to Roman numerals for display
        decree_roman = int_to_roman(decree_number)
        
        # Format decree with custom styling
        formal_text = f"‚ùÑÔ∏è ùì°ùì∏ùîÇùì™ùìµ ùììùìÆùì¨ùìªùìÆùìÆ ‚ùÑÔ∏è\n\n{new_decree_text}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nùìíùìÆùìºùì™ùìªùìªùìªùüìùüéùüì"
        
        # Update the decree
        await asyncio.to_thread(lambda: decree_doc.reference.update({
            'text': formal_text,
            'editedAt': datetime.now(),
            'editedBy': interaction.user.id
        }))
        
        embed = discord.Embed(
            title=f"Royal Decree {decree_roman} (Edited)",
            description=formal_text,
            color=discord.Color.from_str("#004f59")
        )
        embed.set_footer(text=f"Edited by {interaction.user.name}")
        
        # Post updated decree to Royal Decree channel
        ROYAL_DECREE_CHANNEL_ID = 1406718713935433903
        posting_channel = interaction.channel
        if interaction.guild:
            decree_channel = interaction.guild.get_channel(ROYAL_DECREE_CHANNEL_ID)
            if decree_channel:
                posting_channel = decree_channel
        
        try:
            await posting_channel.send(embed=embed)
            await interaction.edit_original_response(content=f"‚úÖ Royal Decree **{decree_roman}** has been updated.")
        except discord.Forbidden:
            await interaction.edit_original_response(content=f"‚ùå Bot lacks permissions to post in <#{ROYAL_DECREE_CHANNEL_ID}>.")
            print(f"[ERR] Missing permissions in channel {ROYAL_DECREE_CHANNEL_ID}")
        
    except Exception as e:
        print(f"[ERR] Decree edit failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content="‚ùå Failed to edit Royal Decree.")

# ========================================
# PEARL TRACKING SYSTEM
# ========================================

def calculate_pearl_essence_cost(days_held: int) -> float:
    """
    Calculate tiered essence fuel cost for pearls.
    - First day ONLY (day 1): 2 essence per day
    - Afterwards (day 2+): 3 essence per day
    
    Args:
        days_held: Number of days the pearl has been held
    
    Returns:
        Daily essence cost
    """
    if days_held == 1:
        return 2.0  # First day ONLY: 2 essence/day
    else:
        return 3.0  # Day 2 onwards: 3 essence/day

def format_pearl_display(duration: int, release_date: datetime, pearl_start: datetime, essence_remaining: float, essence_capacity: float, days_left: int) -> tuple:
    """
    Format pearl sentence display consistently across all panels.
    Handles perma sentences (256+ days) specially.
    NOW USES X/Y ESSENCE COUNTER FORMAT (e.g., 336/336 essence)
    
    Args:
        duration: Total sentence duration in days
        release_date: Expected release date
        pearl_start: Pearl start date
        essence_remaining: Current essence remaining
        essence_capacity: Maximum essence capacity
        days_left: Days remaining until release
    
    Returns:
        Tuple of (duration_text, release_text, fuel_text)
    """
    release_est = release_date.astimezone(EST)
    
    # Calculate current daily burn rate
    days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days if pearl_start else 0
    current_daily_cost = calculate_pearl_essence_cost(days_held_so_far + 1)
    
    # Check if perma (256+ days)
    if duration >= 256:
        duration_text = f"{duration} days (‚è≥ Perma)"
        release_text = "‚è≥ Perma"
        # For perma, show X/Y format with daily rate in "ess" format
        fuel_text = f"**Fuel:** {ESSENCE_EMOJI} {essence_remaining:.0f}/{essence_capacity:.0f} es ({current_daily_cost:.0f} ess now)"
    else:
        duration_text = f"{duration} days"
        release_text = release_est.strftime('%b %d, %Y')
        # For regular sentences, show X/Y format with daily rate in "ess" format
        fuel_text = f"**Fuel:** {ESSENCE_EMOJI} {essence_remaining:.0f}/{essence_capacity:.0f} es ({current_daily_cost:.0f} ess)"
    
    return (duration_text, release_text, fuel_text)

def calculate_total_pearl_essence(start_date: datetime, end_date: datetime) -> float:
    """
    Calculate total essence fuel needed for a pearl over a period.
    Accounts for tiered pricing (2 es/day first week, 3 es/day after).
    
    Args:
        start_date: Pearl start date
        end_date: Pearl end/current date
    
    Returns:
        Total essence needed for the period
    """
    total_days = (end_date - start_date).days
    
    if total_days <= 0:
        return 0.0
    
    # Calculate essence for first week (up to 7 days)
    first_week_days = min(total_days, 7)
    first_week_essence = first_week_days * 2.0  # 2 es/day
    
    # Calculate essence for days after first week
    remaining_days = max(0, total_days - 7)
    remaining_essence = remaining_days * 3.0  # 3 es/day
    
    return first_week_essence + remaining_essence

@pearl_group.command(name="issue", description="[ADMIN] Manually pearl a player")
@app_commands.describe(
    ign="Minecraft IGN to pearl",
    duration_days="Pearl duration in days",
    charges="Reason for pearling",
    vault_location="Vault coordinates (optional)",
    pearl_holder="IGN of pearl holder (optional)"
)
async def pearl_issue(interaction: discord.Interaction, ign: str, duration_days: int, charges: str, vault_location: str = "", pearl_holder: str = ""):
    await interaction.response.send_message(f"{DIAMOND_EMOJI} Processing pearl for {ign}...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can manually issue pearls.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        pearl_start_date = datetime.now(timezone.utc)
        expected_release = pearl_start_date + timedelta(days=duration_days)
        
        # ESSENCE FUEL SYSTEM: Calculate initial essence capacity
        # CRITICAL: All Prison Pearls have FIXED 336 capacity regardless of sentence length
        essence_capacity = 336.0  # FIXED capacity for all pearls
        essence_remaining = essence_capacity  # Start at full capacity
        
        pearl_id = f"PEARL-MANUAL-{int(pearl_start_date.timestamp())}"
        await asyncio.to_thread(lambda: db.collection(PEARLS_COLLECTION).document(pearl_id).set({
            'ign': ign,
            'userId': None,
            'pearlDuration': duration_days,
            'pearlStartDate': pearl_start_date,
            'expectedReleaseDate': expected_release,
            'vaultLocation': vault_location if vault_location else 'Not specified',
            'pearlHolder': pearl_holder if pearl_holder else 'State',
            'courtCaseId': None,
            'jurisdiction': jurisdiction,
            'status': 'active',
            'issuedBy': str(interaction.user),
            'issuedById': interaction.user.id,
            'charges': charges,
            'sentence': f"Manual pearl - {duration_days} days",
            'essenceCapacity': essence_capacity,
            'essenceRemaining': essence_remaining,
            'lastEssenceUpdate': pearl_start_date
        }))
        
        release_est = expected_release.astimezone(EST)
        
        await interaction.edit_original_response(
            content=f"‚úÖ {PEARL_EMOJI} **{ign}** has been pearled!\n"
                   f"**Duration:** {duration_days} days\n"
                   f"**Expected Release:** {release_est.strftime('%b %d, %Y at %I:%M %p EST')}\n"
                   f"**Vault:** {vault_location if vault_location else 'Not specified'}\n"
                   f"**Holder:** {pearl_holder if pearl_holder else 'State'}"
        )
        print(f"[PEARL] Admin {interaction.user} pearled {ign} for {duration_days} days")
        
    except Exception as e:
        print(f"[ERR] Failed to issue pearl: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content="‚ùå Failed to issue pearl.")

@pearl_group.command(name="release", description="[ADMIN] Release a player from pearl")
@app_commands.describe(
    ign="Minecraft IGN to release"
)
async def pearl_release(interaction: discord.Interaction, ign: str):
    await interaction.response.send_message(f"üîì Processing release for {ign}...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can release pearls.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Find active pearl for this IGN
        pearls_query = db.collection(PEARLS_COLLECTION).where(
            filter=FieldFilter('ign', '==', ign)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).limit(1)
        
        # Wrap blocking .stream() call
        pearl_list = await asyncio.to_thread(lambda: list(pearls_query.stream()))
        pearl_doc = None
        for doc in pearl_list:
            pearl_doc = doc
            break
        
        if not pearl_doc:
            return await interaction.edit_original_response(content=f"‚ùå No active pearl found for {ign}.")
        
        # Release the pearl
        await asyncio.to_thread(lambda: pearl_doc.reference.update({
            'status': 'released',
            'releasedAt': datetime.now(timezone.utc),
            'releasedBy': str(interaction.user),
            'releasedById': interaction.user.id
        }))
        
        pearl_data = pearl_doc.to_dict()
        await interaction.edit_original_response(
            content=f"‚úÖ {PEARL_EMOJI} **{ign}** has been released from pearl!\n"
                   f"**Original Sentence:** {pearl_data.get('pearlDuration')} days\n"
                   f"**Released by:** {interaction.user.mention}"
        )
        print(f"[PEARL] Admin {interaction.user} released {ign} from pearl")
        
    except Exception as e:
        print(f"[ERR] Failed to release pearl: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content="‚ùå Failed to release pearl.")

@pearl_group.command(name="migrate", description="[ADMIN] Backfill essence fields for existing pearls")
@app_commands.describe(
    dry_run="Preview changes without applying them (default: True)",
    force="Force re-migration of already migrated pearls (default: False)"
)
@commands.has_any_role("Duke", "Duchess", "Moderator")
async def pearl_migrate(interaction: discord.Interaction, dry_run: bool = True, force: bool = False):
    """
    Admin command to backfill essence fields for all active pearls.
    Safe to run multiple times (idempotent).
    """
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Ensure Firestore is healthy
        current_db = await ensure_firestore()
        
        # Get all active pearls - wrap blocking .stream() call
        active_pearls = await asyncio.to_thread(lambda: list(current_db.collection(PEARLS_COLLECTION).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream()))
        
        if not active_pearls:
            return await interaction.edit_original_response(content="‚úÖ No active pearls found.")
        
        # Prepare backup data and migration results
        import json
        backup_data = []
        migration_results = []
        migrated_count = 0
        skipped_count = 0
        error_count = 0
        
        for pearl_doc in active_pearls:
            pearl = pearl_doc.to_dict()
            ign = pearl.get('ign', 'UNKNOWN')
            
            # Check if already migrated (unless force=True)
            if not force and pearl.get('migratedAt') is not None:
                migration_results.append(f"‚è≠Ô∏è {ign}: Already migrated (use force=True to override)")
                skipped_count += 1
                continue
            
            # Backup original data
            backup_data.append({
                'id': pearl_doc.id,
                'ign': ign,
                'original_data': pearl
            })
            
            # Extract pearl data
            expected_release = pearl.get('expectedReleaseDate')
            pearl_start = pearl.get('pearlStartDate')
            stored_duration = pearl.get('pearlDuration', 0)
            
            # Infer pearlStartDate if missing
            inferred_start = False
            if not pearl_start:
                if expected_release and stored_duration > 0:
                    # Derive from release date and duration
                    pearl_start = expected_release - timedelta(days=stored_duration)
                    inferred_start = True
                else:
                    # Fallback to current time (conservative)
                    pearl_start = datetime.now(timezone.utc)
                    inferred_start = True
            
            # Calculate essence fields
            now = datetime.now(timezone.utc)
            
            # RECALCULATE actual duration from start/release dates (don't trust stored value)
            if pearl_start and expected_release:
                duration = (expected_release - pearl_start).days
                print(f"[MIGRATION-DEBUG] {ign}: start={pearl_start}, release={expected_release}, calculated_duration={duration} days")
            else:
                duration = stored_duration  # Fallback to stored if dates missing
                print(f"[MIGRATION-DEBUG] {ign}: Missing dates, using stored_duration={stored_duration}")
            
            # CRITICAL: All Prison Pearls have FIXED 336 capacity regardless of sentence length
            # Sentence duration only affects release date, NOT capacity
            essence_capacity = 336.0
            print(f"[MIGRATION-DEBUG] {ign}: duration={duration}, capacity={essence_capacity}")
            
            # Calculate essenceRemaining = capacity - consumed_so_far
            essence_consumed = 0.0
            if pearl_start:
                days_held_so_far = (now - pearl_start).days
                # Calculate total essence consumed from day 1 to now
                for day in range(1, days_held_so_far + 1):
                    daily_cost = calculate_pearl_essence_cost(day)
                    essence_consumed += daily_cost
            
            # Remaining = capacity - consumed
            essence_remaining = max(0.0, essence_capacity - essence_consumed)
            
            # Prepare update payload
            update_payload = {
                'essenceCapacity': essence_capacity,
                'essenceRemaining': essence_remaining,
                'lastEssenceUpdate': pearl_start,
                'migratedAt': datetime.now(timezone.utc)
            }
            
            # Add inferred pearlStartDate if we calculated it
            if inferred_start:
                update_payload['pearlStartDate'] = pearl_start
            
            # Apply update (if not dry run)
            if not dry_run:
                try:
                    await asyncio.to_thread(lambda: pearl_doc.reference.update(update_payload))
                    migrated_count += 1
                    warning = " (‚ö†Ô∏è inferred start date)" if inferred_start else ""
                    migration_results.append(f"‚úÖ {ign}: {essence_remaining:.0f}/{essence_capacity:.0f} es{warning}")
                except Exception as update_err:
                    error_count += 1
                    migration_results.append(f"‚ùå {ign}: {update_err}")
            else:
                warning = " (‚ö†Ô∏è inferred start date)" if inferred_start else ""
                migration_results.append(f"üîç {ign}: Would set {essence_remaining:.0f}/{essence_capacity:.0f} es{warning}")
                migrated_count += 1
        
        # Save backup to file
        timestamp = datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')
        backup_path = f"/tmp/pearl_migration_{timestamp}.json"
        with open(backup_path, 'w') as f:
            json.dump(backup_data, f, indent=2, default=str)
        
        # Build response
        mode_text = "üîç DRY RUN" if dry_run else "‚úÖ MIGRATION COMPLETE"
        response = f"**{mode_text}**\n\n"
        response += f"üìä **Summary:**\n"
        response += f"‚Ä¢ Total pearls: {len(active_pearls)}\n"
        response += f"‚Ä¢ Migrated: {migrated_count}\n"
        response += f"‚Ä¢ Skipped: {skipped_count}\n"
        response += f"‚Ä¢ Errors: {error_count}\n"
        response += f"‚Ä¢ Backup: `{backup_path}`\n\n"
        
        if len(migration_results) <= 10:
            response += "**Details:**\n" + "\n".join(migration_results)
        else:
            response += "**Details (first 10):**\n" + "\n".join(migration_results[:10])
            response += f"\n... and {len(migration_results) - 10} more"
        
        if dry_run:
            response += "\n\nüí° Run with `dry_run: False` to apply changes."
        
        await interaction.edit_original_response(content=response[:2000])  # Discord limit
        print(f"[PEARL-MIGRATE] {mode_text} - Migrated: {migrated_count}, Skipped: {skipped_count}, Errors: {error_count}")
        
    except Exception as e:
        print(f"[ERR] Pearl migration failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Migration failed: {str(e)[:1900]}")

@pearl_group.command(name="fix_duration", description="[ADMIN] Fix pearl duration and recalculate capacity")
@app_commands.describe(
    player_ign="Player IGN",
    correct_duration="Correct sentence duration in days (e.g., 112)"
)
@commands.has_any_role("Duke", "Duchess", "Moderator")
async def pearl_fix_duration(interaction: discord.Interaction, player_ign: str, correct_duration: int):
    """Fix pearl with wrong duration/capacity by recalculating from correct sentence length"""
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Find the pearl
        pearl_query = db.collection(PEARLS_COLLECTION).where(
            filter=FieldFilter('ign', '==', player_ign)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).limit(1)
        
        pearl_doc = None
        for doc in pearl_query.stream():
            pearl_doc = doc
            break
        
        if not pearl_doc:
            return await interaction.edit_original_response(
                content=f"‚ùå No active pearl found for **{player_ign}**"
            )
        
        pearl_data = pearl_doc.to_dict()
        old_duration = pearl_data.get('pearlDuration', 0)
        old_capacity = pearl_data.get('essenceCapacity', 0)
        old_release = pearl_data.get('expectedReleaseDate')
        pearl_start = pearl_data.get('pearlStartDate')
        
        if not pearl_start:
            return await interaction.edit_original_response(
                content=f"‚ùå Pearl has no start date - cannot fix"
            )
        
        # Calculate new values
        # CRITICAL: Prison Pearls in CivMC have FIXED 336 capacity regardless of sentence length
        new_release = pearl_start + timedelta(days=correct_duration)
        new_capacity = 336.0  # Fixed capacity for ALL pearls
        
        # Calculate how much essence should remain based on days already held
        now = datetime.now(timezone.utc)
        days_held = (now - pearl_start).days
        essence_consumed = 0.0
        for day in range(1, days_held + 1):
            daily_cost = calculate_pearl_essence_cost(day)
            essence_consumed += daily_cost
        
        new_remaining = max(0.0, min(new_capacity, new_capacity - essence_consumed))
        
        # Update database
        await asyncio.to_thread(lambda: pearl_doc.reference.update({
            'pearlDuration': correct_duration,
            'expectedReleaseDate': new_release,
            'essenceCapacity': new_capacity,
            'essenceRemaining': new_remaining,
            'lastEssenceUpdate': now
        }))
        
        release_est = new_release.astimezone(EST)
        
        response = f"‚úÖ **Fixed pearl for {player_ign}**\n\n"
        response += f"**OLD VALUES:**\n"
        response += f"‚Ä¢ Duration: {old_duration} days\n"
        response += f"‚Ä¢ Capacity: {old_capacity:.0f} essence\n"
        response += f"‚Ä¢ Release: {old_release.astimezone(EST).strftime('%b %d, %Y') if old_release else 'N/A'}\n\n"
        response += f"**NEW VALUES:**\n"
        response += f"‚Ä¢ Duration: {correct_duration} days\n"
        response += f"‚Ä¢ Capacity: {new_capacity:.0f} essence\n"
        response += f"‚Ä¢ Remaining: {new_remaining:.0f} essence\n"
        response += f"‚Ä¢ Release: {release_est.strftime('%b %d, %Y at %I:%M %p EST')}\n"
        response += f"‚Ä¢ Days held: {days_held} days"
        
        await interaction.edit_original_response(content=response)
        print(f"[PEARL-FIX] Fixed {player_ign}: {old_duration}d/{old_capacity:.0f}es ‚Üí {correct_duration}d/{new_capacity:.0f}es")
        
    except Exception as e:
        print(f"[ERR] Pearl fix duration failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed: {str(e)[:1900]}")

@pearl_group.command(name="essence", description="[ADMIN] Manually adjust pearl essence fuel")
@app_commands.describe(
    player_ign="Player IGN (in-game name)",
    action="Action to perform (add/set/view)",
    amount="Amount of essence (for add/set actions)"
)
async def pearl_essence(interaction: discord.Interaction, player_ign: str, action: str, amount: int = None):
    """
    Manually adjust pearl essence fuel.
    Actions:
    - add: Add essence to current amount
    - set: Set exact essence amount
    - view: View current essence status (no amount needed)
    """
    await interaction.response.defer(ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå This command is for Admins only.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    action = action.lower()
    if action not in ['add', 'set', 'view']:
        return await interaction.edit_original_response(content="‚ùå Invalid action. Use: `add`, `set`, or `view`")
    
    if action in ['add', 'set'] and amount is None:
        return await interaction.edit_original_response(content=f"‚ùå Amount required for action '{action}'")
    
    try:
        # Get pearl document - wrap blocking .stream() call
        pearl_query = db.collection(PEARLS_COLLECTION).where(
            filter=FieldFilter('ign', '==', player_ign)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).limit(1)
        
        pearls = await asyncio.to_thread(lambda: list(pearl_query.stream()))
        if not pearls:
            return await interaction.edit_original_response(content=f"‚ùå No active pearl found for **{player_ign}**")
        
        pearl_doc = pearls[0]
        pearl_data = pearl_doc.to_dict()
        
        # Check if pearl is migrated
        if not pearl_data.get('essenceCapacity') or not pearl_data.get('essenceRemaining'):
            return await interaction.edit_original_response(
                content=f"‚ùå Pearl for **{player_ign}** is not migrated. Run `/pearl migrate` first."
            )
        
        current_essence = pearl_data.get('essenceRemaining', 0)
        capacity = pearl_data.get('essenceCapacity', 0)
        duration = pearl_data.get('pearlDuration', 0)
        
        if action == 'view':
            # Just view current status
            response = f"**{PEARL_EMOJI} Essence Status for {player_ign}**\n\n"
            response += f"**Current:** {current_essence:.0f} essence\n"
            response += f"**Capacity:** {capacity:.0f} essence\n"
            response += f"**Duration:** {duration} days\n"
            response += f"**Fuel Display:** {current_essence:.0f}/{capacity:.0f} es\n"
            
            # Calculate days remaining
            pearl_start = pearl_data.get('pearlStartDate')
            if pearl_start:
                days_held = (datetime.now(timezone.utc) - pearl_start).days
                daily_cost = calculate_pearl_essence_cost(days_held + 1)
                estimated_days_left = int(current_essence / daily_cost) if daily_cost > 0 else 0
                response += f"**Est. Days Left:** ~{estimated_days_left} days (at {daily_cost:.0f} es/day)"
            
            return await interaction.edit_original_response(content=response)
        
        elif action == 'add':
            # Add to current essence
            new_essence = current_essence + amount
            if new_essence < 0:
                return await interaction.edit_original_response(
                    content=f"‚ùå Cannot add {amount} essence. Would result in negative value ({new_essence:.0f})"
                )
            if new_essence > capacity:
                return await interaction.edit_original_response(
                    content=f"‚ö†Ô∏è Warning: Adding {amount} essence would exceed capacity ({new_essence:.0f}/{capacity:.0f}). Capping at capacity."
                )
                new_essence = capacity
            
            # Update database
            await asyncio.to_thread(lambda: pearl_doc.reference.update({
                'essenceRemaining': new_essence,
                'lastEssenceUpdate': datetime.now(timezone.utc)
            }))
            
            response = f"‚úÖ **Added {amount} essence to {player_ign}**\n\n"
            response += f"**Before:** {current_essence:.0f}/{capacity:.0f} es\n"
            response += f"**After:** {new_essence:.0f}/{capacity:.0f} es\n"
            response += f"**Change:** +{amount} essence"
            
            await interaction.edit_original_response(content=response)
            print(f"[PEARL-ESSENCE] {interaction.user.name} added {amount} essence to {player_ign} ({current_essence:.0f} ‚Üí {new_essence:.0f})")
            
        elif action == 'set':
            # Set exact essence amount
            if amount < 0:
                return await interaction.edit_original_response(content=f"‚ùå Cannot set negative essence ({amount})")
            if amount > capacity:
                await interaction.edit_original_response(
                    content=f"‚ö†Ô∏è Warning: Setting {amount} essence exceeds capacity ({capacity:.0f}). Proceeding anyway..."
                )
            
            # Update database
            await asyncio.to_thread(lambda: pearl_doc.reference.update({
                'essenceRemaining': float(amount),
                'lastEssenceUpdate': datetime.now(timezone.utc)
            }))
            
            response = f"‚úÖ **Set essence for {player_ign}**\n\n"
            response += f"**Before:** {current_essence:.0f}/{capacity:.0f} es\n"
            response += f"**After:** {amount}/{capacity:.0f} es\n"
            response += f"**Change:** {amount - current_essence:+.0f} essence"
            
            await interaction.edit_original_response(content=response)
            print(f"[PEARL-ESSENCE] {interaction.user.name} set essence for {player_ign} to {amount} (was {current_essence:.0f})")
        
    except Exception as e:
        print(f"[ERR] Pearl essence command failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to adjust essence: {str(e)[:1900]}")

@pearl_group.command(name="list", description="View all currently pearled players")
async def pearl_list(interaction: discord.Interaction):
    # RETRY LOGIC: Initial ACK with HTTP recreation (3 attempts)
    ack_success = False
    for ack_attempt in range(3):
        try:
            await interaction.response.send_message(f"{PEARL_EMOJI} Loading pearled players...", ephemeral=True)
            ack_success = True
            break
        except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError, discord.HTTPException) as e:
            print(f"[WARN] Pearl list ACK error (attempt {ack_attempt + 1}/3): {e}")
            if ack_attempt < 2:
                try:
                    pass  # Discord.py handles reconnections automatically
                    print("[DEBUG] Recreated HTTP session")
                except Exception as recreate_err:
                    print(f"[WARN] Failed to recreate HTTP: {recreate_err}")
                await asyncio.sleep(0.5)
    
    if not ack_success:
        print(f"[ERR] Failed to ACK pearl list command after 3 attempts")
        return
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # RETRY LOGIC: Firestore query (3 attempts)
        active_pearls = []
        for db_attempt in range(3):
            try:
                # Wrap blocking .stream() call
                active_pearls = await asyncio.to_thread(lambda: list(db.collection(PEARLS_COLLECTION).where(
                    filter=FieldFilter('status', '==', 'active')
                ).stream()))
                print(f"[OK] Pearl list: Got {len(active_pearls)} pearls")
                break
            except (OSError, Exception) as db_err:
                print(f"[WARN] Pearl list Firestore query error (attempt {db_attempt + 1}/3): {db_err}")
                if db_attempt < 2:
                    await asyncio.sleep(0.5)
                else:
                    raise
        
        if not active_pearls:
            return await interaction.edit_original_response(content="‚úÖ No players currently pearled.")
        
        pearl_list = []
        for pearl_doc in active_pearls:
            pearl = pearl_doc.to_dict()
            ign = pearl.get('ign')
            release_date = pearl.get('expectedReleaseDate')
            vault = pearl.get('vaultLocation', 'Unknown')
            holder = pearl.get('pearlHolder', 'Unknown')
            
            if release_date:
                release_est = release_date.astimezone(EST)
                days_left = (release_date - datetime.now(timezone.utc)).days
                pearl_list.append(
                    f"{PEARL_EMOJI} **{ign}**\n"
                    f"  ‚îî Release: {release_est.strftime('%b %d')} ({days_left}d left) | Vault: {vault} | Holder: {holder}"
                )
            else:
                pearl_list.append(f"{PEARL_EMOJI} **{ign}** | Vault: {vault} | Holder: {holder}")
        
        embed = discord.Embed(
            title=f"{PEARL_EMOJI} Currently Pearled Players ({len(active_pearls)})",
            description="\n".join(pearl_list),
            color=discord.Color.purple()
        )
        embed.set_footer(text="‚öñÔ∏è Florab√≠s State Justice System")
        
        # RETRY LOGIC: Edit response (3 attempts with HTTP recreation)
        for edit_attempt in range(3):
            try:
                await interaction.edit_original_response(content="", embed=embed)
                break
            except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError, discord.HTTPException) as edit_err:
                print(f"[WARN] Pearl list edit error (attempt {edit_attempt + 1}/3): {edit_err}")
                if edit_attempt < 2:
                    try:
                        pass  # Discord.py handles reconnections automatically
                    except:
                        pass
                    await asyncio.sleep(0.5)
                else:
                    raise
        
    except Exception as e:
        print(f"[ERR] Failed to list pearls: {e}")
        import traceback
        traceback.print_exc()
        try:
            await interaction.edit_original_response(content="‚ùå Failed to load pearl list.")
        except:
            pass

@pearl_group.command(name="status", description="Check pearl status for a specific player")
@app_commands.describe(
    ign="Minecraft IGN to check"
)
async def pearl_status(interaction: discord.Interaction, ign: str):
    # RETRY LOGIC: Initial ACK with HTTP recreation (3 attempts)
    ack_success = False
    for ack_attempt in range(3):
        try:
            await interaction.response.send_message(f"üîç Checking pearl status for {ign}...", ephemeral=True)
            ack_success = True
            break
        except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError, discord.HTTPException) as e:
            print(f"[WARN] Pearl status ACK error (attempt {ack_attempt + 1}/3): {e}")
            if ack_attempt < 2:
                try:
                    pass  # Discord.py handles reconnections automatically
                    print("[DEBUG] Recreated HTTP session")
                except Exception as recreate_err:
                    print(f"[WARN] Failed to recreate HTTP: {recreate_err}")
                await asyncio.sleep(0.5)
    
    if not ack_success:
        print(f"[ERR] Failed to ACK pearl status command after 3 attempts")
        return
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # RETRY LOGIC: Firestore query (3 attempts)
        pearl_doc = None
        for db_attempt in range(3):
            try:
                pearls_query = db.collection(PEARLS_COLLECTION).where(
                    filter=FieldFilter('ign', '==', ign)
                ).limit(1)
                
                # Wrap blocking .stream() call
                pearl_list = await asyncio.to_thread(lambda: list(pearls_query.stream()))
                for doc in pearl_list:
                    pearl_doc = doc
                    break
                print(f"[OK] Pearl status: Query complete for {ign}")
                break
            except (OSError, Exception) as db_err:
                print(f"[WARN] Pearl status Firestore query error (attempt {db_attempt + 1}/3): {db_err}")
                if db_attempt < 2:
                    await asyncio.sleep(0.5)
                else:
                    raise
        
        if not pearl_doc:
            return await interaction.edit_original_response(content=f"‚úÖ **{ign}** has no pearl records.")
        
        pearl = pearl_doc.to_dict()
        status = pearl.get('status', 'unknown')
        duration = pearl.get('pearlDuration', 0)
        start_date = pearl.get('pearlStartDate')
        release_date = pearl.get('expectedReleaseDate')
        vault = pearl.get('vaultLocation', 'Not specified')
        holder = pearl.get('pearlHolder', 'Unknown')
        charges = pearl.get('charges', 'Not specified')
        case_id = pearl.get('courtCaseId')
        
        status_emoji = "üî¥" if status == 'active' else "üü¢"
        
        description = f"**Status:** {status_emoji} {status.upper()}\n"
        description += f"**Charges:** {charges}\n"
        
        if case_id:
            description += f"**Court Case:** #{case_id}\n"
        
        description += f"**Duration:** {duration} days\n"
        
        if start_date:
            start_est = start_date.astimezone(EST)
            description += f"**Pearled On:** {start_est.strftime('%b %d, %Y at %I:%M %p EST')}\n"
        
        if release_date and status == 'active':
            release_est = release_date.astimezone(EST)
            days_left = (release_date - datetime.now(timezone.utc)).days
            description += f"**Release Date:** {release_est.strftime('%b %d, %Y at %I:%M %p EST')}\n"
            description += f"**Days Remaining:** {days_left}\n"
        
        description += f"\n**Vault Location:** {vault}\n"
        description += f"**Pearl Holder:** {holder}"
        
        embed = discord.Embed(
            title=f"{PEARL_EMOJI} Pearl Status: {ign}",
            description=description,
            color=discord.Color.red() if status == 'active' else discord.Color.green()
        )
        embed.set_footer(text="‚öñÔ∏è Florab√≠s State Justice System")
        
        # RETRY LOGIC: Edit response (3 attempts with HTTP recreation)
        for edit_attempt in range(3):
            try:
                await interaction.edit_original_response(content="", embed=embed)
                break
            except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError, discord.HTTPException) as edit_err:
                print(f"[WARN] Pearl status edit error (attempt {edit_attempt + 1}/3): {edit_err}")
                if edit_attempt < 2:
                    try:
                        pass  # Discord.py handles reconnections automatically
                    except:
                        pass
                    await asyncio.sleep(0.5)
                else:
                    raise
        
    except Exception as e:
        print(f"[ERR] Failed to check pearl status: {e}")
        import traceback
        traceback.print_exc()
        try:
            await interaction.edit_original_response(content="‚ùå Failed to check pearl status.")
        except:
            pass

@pearl_group.command(name="update_location", description="[ADMIN] Update vault location for a pearled player")
@app_commands.describe(
    ign="Minecraft IGN",
    new_vault_location="New vault coordinates"
)
async def pearl_update_location(interaction: discord.Interaction, ign: str, new_vault_location: str):
    await interaction.response.send_message(f"üìç Updating vault location for {ign}...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can update vault locations.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Find active pearl for this IGN
        pearls_query = db.collection(PEARLS_COLLECTION).where(
            filter=FieldFilter('ign', '==', ign)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).limit(1)
        
        # Wrap blocking .stream() call
        pearl_list = await asyncio.to_thread(lambda: list(pearls_query.stream()))
        pearl_doc = None
        for doc in pearl_list:
            pearl_doc = doc
            break
        
        if not pearl_doc:
            return await interaction.edit_original_response(content=f"‚ùå No active pearl found for {ign}.")
        
        # Update vault location
        await asyncio.to_thread(lambda: pearl_doc.reference.update({
            'vaultLocation': new_vault_location,
            'locationUpdatedAt': datetime.now(timezone.utc),
            'locationUpdatedBy': str(interaction.user)
        }))
        
        await interaction.edit_original_response(
            content=f"‚úÖ Vault location for {PEARL_EMOJI} **{ign}** updated to: `{new_vault_location}`"
        )
        print(f"[PEARL] Admin {interaction.user} updated vault location for {ign}")
        
    except Exception as e:
        print(f"[ERR] Failed to update vault location: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content="‚ùå Failed to update vault location.")

@pearl_group.command(name="panel", description="<:pearl:1428919990194536458> Show Pearl Facility panel with essence fuel costs")
async def pearl_panel(interaction: discord.Interaction):
    # CRITICAL: ACK IMMEDIATELY with retry logic
    ack_success = False
    for ack_attempt in range(3):
        try:
            await interaction.response.send_message("<:pearl:1428919990194536458> Loading Pearl Facility panel...", ephemeral=True)
            ack_success = True
            break
        except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError, discord.HTTPException) as e:
            print(f"[WARN] Pearl panel ACK error (attempt {ack_attempt + 1}/3): {e}")
            if ack_attempt < 2:
                try:
                    pass  # Discord.py handles reconnections automatically
                except:
                    pass
                await asyncio.sleep(0.5)
    
    if not ack_success:
        print(f"[ERR] Failed to ACK pearl panel command after 3 attempts")
        return
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all active pearls - wrap blocking .stream() call
        active_pearls = await asyncio.to_thread(lambda: list(db.collection(PEARLS_COLLECTION).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream()))
        
        # Check if user is admin for vault location visibility
        is_admin = interaction.user.guild_permissions.administrator if hasattr(interaction.user, 'guild_permissions') else False
        
        if not active_pearls:
            embed = discord.Embed(
                title="<:pearl:1428919990194536458> PEARL FACILITY - FLORAB√çS STATE",
                description="‚úÖ No players currently pearled.\n*All pearled players are held in the Nether*",
                color=discord.Color.green()
            )
            embed.set_footer(text="<:pearl:1428919990194536458> Florab√≠s State Pearl System | Held in the Nether")
            return await interaction.edit_original_response(content="", embed=embed)
        
        pearl_entries = []
        
        # Calculate TOTAL essence across ALL pearls AND current daily consumption
        total_essence_remaining = 0
        daily_consumption = 0
        for pearl_doc in active_pearls:
            pearl = pearl_doc.to_dict()
            pearl_start = pearl.get('pearlStartDate')
            release_date = pearl.get('expectedReleaseDate')
            if pearl_start and release_date:
                # Calculate how many days have been held so far
                days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days
                
                # Calculate remaining essence from NOW to release, accounting for tier based on total days held
                remaining_days = max((release_date - datetime.now(timezone.utc)).days, 0)
                
                # Calculate remaining essence for each remaining day
                essence_needed = 0
                for day in range(remaining_days):
                    # day is 0-indexed, so add 1 to get actual day number, then add days_held_so_far
                    total_days_at_that_point = days_held_so_far + day + 1
                    daily_cost_at_that_point = calculate_pearl_essence_cost(total_days_at_that_point)
                    essence_needed += daily_cost_at_that_point
                
                total_essence_remaining += essence_needed
                
                # Calculate current daily cost for this pearl (based on days already held)
                daily_cost = calculate_pearl_essence_cost(days_held_so_far + 1)  # +1 because we're in the middle of this day
                daily_consumption += daily_cost
                
                # DEBUG: Log pearl cost calculation
                print(f"[DEBUG] Pearl {pearl.get('ign')}: days_held={days_held_so_far}, daily_cost={daily_cost} es/day")
        
        MAX_DISPLAY = 8  # Limit to 8 pearls for clean UI display
        for idx, pearl_doc in enumerate(active_pearls):
            if idx >= MAX_DISPLAY:
                break  # Only show first 8 pearls in display
                
            pearl = pearl_doc.to_dict()
            ign = pearl.get('ign')
            release_date = pearl.get('expectedReleaseDate')
            vault = pearl.get('vaultLocation', 'Unknown')
            holder = pearl.get('pearlHolder', 'Unknown')
            duration = pearl.get('pearlDuration', 0)
            
            # Calculate display info for this pearl
            if release_date:
                days_left = max((release_date - datetime.now(timezone.utc)).days, 0)
                pearl_start = pearl.get('pearlStartDate')
                
                # NEW ESSENCE SYSTEM: Read from database if available, otherwise calculate fallback
                essence_capacity = pearl.get('essenceCapacity')
                essence_remaining = pearl.get('essenceRemaining')
                
                # Fallback for old pearls without new fields
                if essence_capacity is None or essence_remaining is None:
                    if pearl_start:
                        days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days
                        essence_remaining = sum(calculate_pearl_essence_cost(days_held_so_far + day + 1) for day in range(days_left))
                        essence_capacity = 336.0  # FIXED capacity for all pearls  # Calculate what it should have been
                    else:
                        essence_remaining = days_left * 3.0
                        essence_capacity = 336.0  # FIXED capacity for all pearls
                
                # Use helper function for consistent PERMA display
                duration_text, release_text, fuel_text = format_pearl_display(
                    duration, release_date, pearl_start, essence_remaining, essence_capacity, days_left
                )
                
                # Security: Hide vault location from non-admins
                if is_admin:
                    pearl_entries.append(
                        f"<:pearl:1428919990194536458> **{ign}**\n"
                        f"**Sentence:** {duration_text} ‚Ä¢ **Release:** {release_text}\n"
                        f"{fuel_text}\n"
                        f"üîí `{vault}` ‚Ä¢ üëÆ {holder}"
                    )
                else:
                    pearl_entries.append(
                        f"<:pearl:1428919990194536458> **{ign}**\n"
                        f"**Sentence:** {duration_text} ‚Ä¢ **Release:** {release_text}\n"
                        f"{fuel_text}"
                    )
            else:
                # No release date specified
                if is_admin:
                    pearl_entries.append(
                        f"<:pearl:1428919990194536458> **{ign}** ‚Äî *Awaiting Sentencing*\n"
                        f"üîí `{vault}` ‚Ä¢ üëÆ {holder}"
                    )
                else:
                    pearl_entries.append(
                        f"<:pearl:1428919990194536458> **{ign}** ‚Äî *Awaiting Sentencing*"
                    )
        
        # Add overflow indicator if more than MAX_DISPLAY pearls
        pearl_count_text = f"{len(active_pearls)} Pearled" if len(active_pearls) <= MAX_DISPLAY else f"Showing {MAX_DISPLAY} of {len(active_pearls)} Pearled"
        
        # Build description with size limit check (Discord limit: 4096 chars)
        description_text = "*All pearled players are held in the Nether*\n\n" + "\n\n".join(pearl_entries)
        if len(description_text) > 3500:  # Safe limit to account for other embed content
            description_text = description_text[:3500] + "\n\n*...List truncated. Too many pearls to display.*"
        
        embed = discord.Embed(
            title="<:pearl:1428919990194536458> PEARL FACILITY - FLORAB√çS STATE",
            description=description_text,
            color=0xDC143C  # Crimson red
        )
        
        # Add summary field with pearl count at bottom
        embed.add_field(
            name="üìä Facility Status",
            value=(
                f"**Pearled:** {len(active_pearls)} ‚Ä¢ **Fuel:** {ESSENCE_EMOJI} {total_essence_remaining:.0f} es\n"
                f"**Consumption:** {daily_consumption:.0f} es/day ‚Ä¢ **Location:** Nether ‚Ä¢ **View:** {'ADMIN' if is_admin else 'PUBLIC'}"
            ),
            inline=False
        )
        
        now_est = datetime.now(timezone.utc).astimezone(EST)
        embed.set_footer(text=f"<:pearl:1428919990194536458> Updated: {now_est.strftime('%I:%M %p EST')} | Florab√≠s Pearl System")
        
        await interaction.edit_original_response(content="", embed=embed)
        
    except Exception as e:
        print(f"[ERR] Failed to load pearl panel: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content="‚ùå Failed to load pearl panel.")

# Pearl Public Panel View
class PearlPublicPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(RefreshPearlsButton())

class RefreshPearlsButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Pearls", style=discord.ButtonStyle.secondary, custom_id="refresh_pearls")
    
    async def callback(self, interaction: discord.Interaction):
        # CRITICAL: Defer IMMEDIATELY before ANY checks to prevent timeout
        await interaction.response.defer(ephemeral=True)
        print(f"[PEARL-REFRESH] Button clicked by {interaction.user.name}")
        
        if not db:
            return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Ensure Firestore client is healthy before querying
            current_db = await ensure_firestore()
            # CRITICAL: Wrap blocking .stream() call in asyncio.to_thread()
            active_pearls = await asyncio.to_thread(
                lambda: list(current_db.collection(PEARLS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
            )
            
            print(f"[PEARL-REFRESH] Found {len(active_pearls)} active pearls")
            
            if not active_pearls:
                print(f"[PEARL-REFRESH] No pearls - building empty panel embed")
                embed = discord.Embed(
                    title="<:pearl:1428919990194536458> PEARL FACILITY - FLORAB√çS STATE",
                    description="‚úÖ No players currently pearled.\n*All pearled players are held in the Nether*",
                    color=discord.Color.green()
                )
                now_est = datetime.now(timezone.utc).astimezone(EST)
                embed.add_field(
                    name="üìä Facility Status",
                    value=f"**Pearled:** 0 ‚Ä¢ **Fuel:** {ESSENCE_EMOJI} 0 es\n**Consumption:** 0 es/day ‚Ä¢ **Location:** Nether ‚Ä¢ **View:** PUBLIC",
                    inline=False
                )
                embed.set_footer(text=f"<:pearl:1428919990194536458> Updated: {now_est.strftime('%I:%M %p EST')} | Florab√≠s Pearl System")
                
                # Check if interaction.message exists
                if interaction.message is None:
                    print(f"[PEARL-REFRESH] ERROR: interaction.message is None!")
                    return await interaction.followup.send("‚ùå Could not find panel message. Please post a new panel.", ephemeral=True)
                
                message_id = interaction.message.id
                channel = interaction.channel
                print(f"[PEARL-REFRESH] Panel message ID: {message_id}, Channel: {channel.id}")
                
                # Fetch message fresh from channel for reliable editing
                try:
                    panel_message = await channel.fetch_message(message_id)
                    print(f"[PEARL-REFRESH] Fetched panel message successfully")
                except Exception as fetch_err:
                    print(f"[PEARL-REFRESH] ‚ùå Failed to fetch panel message: {fetch_err}")
                    return await interaction.followup.send("‚ùå Could not find panel message. Please post a new panel.", ephemeral=True)
                
                # Edit the panel message directly
                try:
                    await panel_message.edit(embed=embed, view=PearlPublicPanel())
                    print(f"[PEARL-REFRESH] ‚úÖ Successfully edited panel (0 pearls)")
                    # Show success message
                    confirmation = await interaction.followup.send("‚úÖ Pearl panel refreshed!", ephemeral=True)
                    print(f"[PEARL-REFRESH] Sent success followup")
                    await asyncio.sleep(2)
                    try:
                        await confirmation.delete()
                    except:
                        pass
                    return
                except Exception as edit_err:
                    print(f"[PEARL-REFRESH] ‚ùå Failed to edit panel: {edit_err}")
                    import traceback
                    traceback.print_exc()
                    return await interaction.followup.send(f"‚ùå Failed to refresh panel: {edit_err}", ephemeral=True)
            
            pearl_entries = []
            
            # Calculate TOTAL essence across ALL pearls AND current daily consumption
            total_essence_remaining = 0
            daily_consumption = 0
            for pearl_doc in active_pearls:
                pearl = pearl_doc.to_dict()
                pearl_start = pearl.get('pearlStartDate')
                release_date = pearl.get('expectedReleaseDate')
                if pearl_start and release_date:
                    # Calculate how many days have been held so far
                    days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days
                    
                    # Calculate remaining essence from NOW to release, accounting for tier based on total days held
                    remaining_days = max((release_date - datetime.now(timezone.utc)).days, 0)
                    
                    # Calculate remaining essence for each remaining day
                    essence_needed = 0
                    for day in range(remaining_days):
                        # day is 0-indexed, so add 1 to get actual day number, then add days_held_so_far
                        total_days_at_that_point = days_held_so_far + day + 1
                        daily_cost_at_that_point = calculate_pearl_essence_cost(total_days_at_that_point)
                        essence_needed += daily_cost_at_that_point
                    
                    total_essence_remaining += essence_needed
                    
                    # Calculate current daily cost for this pearl (based on days already held)
                    daily_cost = calculate_pearl_essence_cost(days_held_so_far + 1)  # +1 because we're in the middle of this day
                    daily_consumption += daily_cost
                    
                    # DEBUG: Log pearl cost calculation
                    print(f"[DEBUG] Pearl {pearl.get('ign')}: days_held={days_held_so_far}, daily_cost={daily_cost} es/day")
            
            MAX_DISPLAY = 8  # Limit to 8 pearls for clean UI display
            for idx, pearl_doc in enumerate(active_pearls):
                if idx >= MAX_DISPLAY:
                    break  # Only show first 8 pearls in display
                    
                pearl = pearl_doc.to_dict()
                ign = pearl.get('ign')
                release_date = pearl.get('expectedReleaseDate')
                vault = pearl.get('vaultLocation', 'Unknown')
                holder = pearl.get('pearlHolder', 'Unknown')
                duration = pearl.get('pearlDuration', 0)
                
                # Calculate display info for this pearl
                if release_date:
                    days_left = max((release_date - datetime.now(timezone.utc)).days, 0)
                    pearl_start = pearl.get('pearlStartDate')
                    
                    # NEW ESSENCE SYSTEM: Read from database if available, otherwise calculate fallback
                    essence_capacity = pearl.get('essenceCapacity')
                    essence_remaining = pearl.get('essenceRemaining')
                    
                    # Fallback for old pearls without new fields
                    # STANDARD CAPACITY: All pearls show /336 essence (112-day equivalent fuel tank)
                    if essence_capacity is None or essence_remaining is None:
                        essence_capacity = 336.0  # Standard fuel tank size (112 days * 3 ess)
                        if pearl_start:
                            days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days
                            # Calculate essence consumed so far
                            essence_consumed = 0.0
                            for day in range(1, days_held_so_far + 1):
                                essence_consumed += calculate_pearl_essence_cost(day)
                            # Remaining = capacity - consumed
                            essence_remaining = max(0.0, essence_capacity - essence_consumed)
                        else:
                            # If no start date, assume full tank
                            essence_remaining = essence_capacity
                    
                    # Use helper function for consistent PERMA display
                    duration_text, release_text, fuel_text = format_pearl_display(
                        duration, release_date, pearl_start, essence_remaining, essence_capacity, days_left
                    )
                    
                    # PUBLIC PANEL: Never show vault locations for security
                    pearl_entries.append(
                        f"<:pearl:1428919990194536458> **{ign}**\n"
                        f"**Sentence:** {duration_text} ‚Ä¢ **Release:** {release_text}\n"
                        f"{fuel_text}"
                    )
                else:
                    pearl_entries.append(
                        f"<:pearl:1428919990194536458> **{ign}** ‚Äî *Awaiting Sentencing*"
                    )
            
            # Add overflow indicator if more than MAX_DISPLAY pearls
            pearl_count_text = f"{len(active_pearls)} Pearled" if len(active_pearls) <= MAX_DISPLAY else f"Showing {MAX_DISPLAY} of {len(active_pearls)} Pearled"
            
            # Build description with size limit check (Discord limit: 4096 chars)
            description_text = "*All pearled players are held in the Nether*\n\n" + "\n\n".join(pearl_entries)
            if len(description_text) > 3500:  # Safe limit to account for other embed content
                description_text = description_text[:3500] + "\n\n*...List truncated. Too many pearls to display.*"
            
            embed = discord.Embed(
                title="<:pearl:1428919990194536458> PEARL FACILITY - FLORAB√çS STATE",
                description=description_text,
                color=0xDC143C  # Crimson red
            )
            
            # Add summary field with pearl count at bottom
            embed.add_field(
                name="üìä Facility Status",
                value=(
                    f"**Pearled:** {len(active_pearls)} ‚Ä¢ **Fuel:** {ESSENCE_EMOJI} {total_essence_remaining:.0f} es\n"
                    f"**Consumption:** {daily_consumption:.0f} es/day ‚Ä¢ **Location:** Nether ‚Ä¢ **View:** PUBLIC"
                ),
                inline=False
            )
            
            now_est = datetime.now(timezone.utc).astimezone(EST)
            embed.set_footer(text=f"<:pearl:1428919990194536458> Updated: {now_est.strftime('%I:%M %p EST')} | Florab√≠s Pearl System")
            
            # Fetch message fresh from channel for reliable editing
            message_id = interaction.message.id
            channel = interaction.channel
            print(f"[PEARL-REFRESH] Panel message ID: {message_id}, Channel: {channel.id}")
            
            try:
                panel_message = await channel.fetch_message(message_id)
                print(f"[PEARL-REFRESH] Fetched panel message successfully")
            except Exception as fetch_err:
                print(f"[PEARL-REFRESH] ‚ùå Failed to fetch panel message: {fetch_err}")
                return await interaction.followup.send("‚ùå Could not find panel message. Please post a new panel.", ephemeral=True)
            
            # Edit the panel message
            try:
                await panel_message.edit(embed=embed, view=PearlPublicPanel())
                print(f"[PEARL-REFRESH] ‚úÖ Successfully edited panel ({len(active_pearls)} pearls)")
                # Show success message then auto-delete
                confirmation = await interaction.followup.send("‚úÖ Pearl panel refreshed!", ephemeral=True)
                await asyncio.sleep(2)
                try:
                    await confirmation.delete()
                except:
                    pass
            except Exception as edit_err:
                print(f"[PEARL-REFRESH] ‚ùå Failed to edit panel: {edit_err}")
                import traceback
                traceback.print_exc()
                await interaction.followup.send(f"‚ùå Failed to refresh panel: {edit_err}", ephemeral=True)
            
        except Exception as e:
            print(f"[ERR] Refresh pearls failed: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

@pearl_group.command(name="post_panel", description="<:pearl:1428919990194536458> Post public Pearl Facility panel (Admin only)")
async def pearl_post_panel_cmd(interaction: discord.Interaction):
    # CRITICAL: DEFER IMMEDIATELY
    await interaction.response.defer(ephemeral=True)
    
    # Check permissions AFTER deferring
    if not interaction.user.guild_permissions.administrator:
        return await interaction.followup.send("‚ùå Only administrators can post the pearl panel.", ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    try:
        print(f"[PEARL-PANEL] Starting foreground panel creation...")
        # BUILD PANEL IN FOREGROUND WITH FULL ERROR LOGGING
        await bot.process_pearl_panel_job({}, interaction.guild, interaction.channel)
        await interaction.followup.send("‚úÖ Pearl panel posted successfully!", ephemeral=True)
        print(f"[PEARL-PANEL] ‚úÖ Panel created successfully")
    except Exception as e:
        print(f"[PEARL-PANEL] ‚ùå ERROR creating panel:")
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Failed to create panel:\n```{str(e)}```", ephemeral=True)

@bot.tree.command(name="check_snitch_logs", description="üîç Check if an IGN has snitch logs")
@app_commands.describe(
    ign="Minecraft IGN to check"
)
async def check_snitch_logs(interaction: discord.Interaction, ign: str):
    # RESPOND IMMEDIATELY to avoid timeout - PRIVATE (ephemeral)
    await interaction.response.send_message("üîç Checking snitch logs...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Count snitch logs for this IGN
        logs = db.collection(SNITCH_LOGS_COLLECTION).where(filter=FieldFilter('player', '==', ign)).stream()
        count = sum(1 for _ in logs)
        
        if count > 0:
            await interaction.edit_original_response(content=f"‚úÖ **{ign}** has **{count}** snitch log(s). They can register!")
        else:
            await interaction.edit_original_response(content=f"‚ùå **{ign}** has **no** snitch logs. They cannot register yet.\n\nUse `/add_snitch_log {ign}` to add a snitch log entry (admin only).")
    except Exception as e:
        print(f"[ERR] Failed to check snitch logs: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {e}")

@bot.tree.command(name="add_snitch_log", description="[ADMIN] Add snitch log entry to enable citizen registration")
@app_commands.describe(
    ign="Minecraft IGN that hit the snitch",
    location="Optional location description (e.g., 'Main Gate')"
)
async def add_snitch_log(interaction: discord.Interaction, ign: str, location: str = "Florab√≠s Territory"):
    # RESPOND IMMEDIATELY to avoid timeout - PRIVATE (ephemeral)
    await interaction.response.send_message("üìù Adding snitch log...", ephemeral=True)
    
    # Check admin permission
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can add snitch logs.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Add snitch log entry
        await asyncio.to_thread(lambda: db.collection(SNITCH_LOGS_COLLECTION).add({
            'player': ign,
            'location': location,
            'timestamp': datetime.now(timezone.utc),
            'addedBy': str(interaction.user),
            'addedById': interaction.user.id,
            'type': 'manual_entry'
        }))
        
        print(f"[OK] Snitch log added: {ign} at {location} by {interaction.user}")
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Snitch log added successfully!**\n\n"
            f"**IGN:** {ign}\n"
            f"**Location:** {location}\n\n"
            f"üí° {ign} can now register as a citizen!"
        )
    except Exception as e:
        print(f"[ERR] Failed to add snitch log: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to add snitch log: {str(e)}")


def calculate_senators(citizen_count: int) -> int:
    """Calculate number of senators based on citizen count"""
    thresholds = [
        (3, 1),
        (7, 2),
        (12, 3),
        (18, 4),
        (25, 5),
        (33, 6),
        (42, 7),
        (52, 8)
    ]
    
    senators = 0
    for threshold, senator_count in thresholds:
        if citizen_count >= threshold:
            senators = senator_count
        else:
            break
    
    if citizen_count >= 52:
        senators = 8 + ((citizen_count - 52) // 10)
    
    return senators

def get_citizen_count() -> int:
    """Get total number of registered PRIMARY citizens (for senate calculation)"""
    if not db:
        return 0
    try:
        citizens = db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('citizenshipType', '==', 'primary')).stream()
        return sum(1 for _ in citizens)
    except Exception as e:
        print(f"[WARN] Failed to count citizens: {e}")

def get_dual_citizen_count() -> int:
    """Get total number of dual/secondary citizens"""
    if not db:
        return 0
    try:
        # Check both 'dual' and 'secondary' types
        dual_count = sum(1 for _ in db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('citizenshipType', '==', 'dual')).stream())
        secondary_count = sum(1 for _ in db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('citizenshipType', '==', 'secondary')).stream())
        return dual_count + secondary_count
    except Exception as e:
        print(f"[WARN] Failed to count dual citizens: {e}")
        return 0

def get_resident_count() -> int:
    """Get total number of residents"""
    if not db:
        return 0
    try:
        residents = db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('citizenshipType', '==', 'resident')).stream()
        return sum(1 for _ in residents)
    except Exception as e:
        print(f"[WARN] Failed to count residents: {e}")
        return 0

def get_senator_count() -> int:
    """Get manually set senator count from settings"""
    if not db:
        return 0
    try:
        doc = db.collection('florabi_settings').document('senator_count').get()
        if doc.exists:
            return doc.to_dict().get('count', 0)
        return 0
    except Exception as e:
        print(f"[WARN] Failed to get senator count: {e}")
        return 0

def set_senator_count(count: int) -> bool:
    """Set the senator count manually"""
    if not db:
        return False
    try:
        db.collection('florabi_settings').document('senator_count').set({
            'count': count,
            'updatedAt': datetime.now(timezone.utc)
        })
        return True
    except Exception as e:
        print(f"[WARN] Failed to set senator count: {e}")
        return False
        return 0

# ==================================================
# BANK SYSTEM - HELPER FUNCTIONS
# ==================================================

def get_or_create_bank_account(user_id: int):
    """Get or create bank account for a citizen"""
    if not db:
        return None
    
    # Check if account exists
    accounts = list(db.collection(BANK_ACCOUNTS_COLLECTION).where(
        filter=FieldFilter('userId', '==', user_id)
    ).limit(1).stream())
    
    if accounts:
        return accounts[0]
    
    # Create new account with unique account number
    import random
    account_number = f"FL-{random.randint(1000, 9999)}"
    
    # Check if account number already exists (rare collision)
    while len(list(db.collection(BANK_ACCOUNTS_COLLECTION).where(
        filter=FieldFilter('accountNumber', '==', account_number)
    ).limit(1).stream())) > 0:
        account_number = f"FL-{random.randint(1000, 9999)}"
    
    # Create account with multi-commodity balances
    _, account_ref = db.collection(BANK_ACCOUNTS_COLLECTION).add({
        'userId': user_id,
        'accountNumber': account_number,
        'diamondBalance': 0.0,  # Diamonds (primary currency)
        'essenceBalance': 0.0,  # Essence (pearl fuel)
        'ironBalance': 0.0,  # Iron ingots
        'goldBalance': 0.0,  # Gold ingots
        'emeraldBalance': 0.0,  # Emerald units
        # CivMC Block commodities (traded alongside ingots/units)
        'ironBlockBalance': 0.0,  # Iron blocks
        'goldBlockBalance': 0.0,  # Gold blocks
        'emeraldBlockBalance': 0.0,  # Emerald blocks
        'balance': 0.0,  # Legacy field for backwards compatibility
        'createdAt': datetime.now(timezone.utc)
    })
    
    print(f"[BANK] Created account {account_number} for user {user_id}")
    return db.collection(BANK_ACCOUNTS_COLLECTION).document(account_ref.id).get()

def get_bank_balance(user_id: int) -> float:
    """Get bank balance for a user"""
    account = get_or_create_bank_account(user_id)
    if account and account.exists:
        return account.to_dict().get('balance', 0.0)
    return 0.0

def update_bank_balance(user_id: int, new_balance: float, transaction_type: str, amount: float, memo: str = ""):
    """Update bank balance and log transaction"""
    if not db:
        return False
    
    account = get_or_create_bank_account(user_id)
    if not account or not account.exists:
        return False
    
    account_data = account.to_dict()
    account_number = account_data.get('accountNumber')
    
    # Update balance (note: this function is not async, caller needs to be updated to be async or use sync wrapper)
    # For now, wrapping to prevent blocking
    import asyncio
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # Can't use await in non-async function, but this prevents blocking the existing event loop
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                executor.submit(lambda: db.collection(BANK_ACCOUNTS_COLLECTION).document(account.id).update({'balance': new_balance})).result(timeout=5)
        else:
            db.collection(BANK_ACCOUNTS_COLLECTION).document(account.id).update({'balance': new_balance})
    except:
        # Fallback to synchronous call
        db.collection(BANK_ACCOUNTS_COLLECTION).document(account.id).update({'balance': new_balance})
    
    # Log transaction
    db.collection(BANK_TRANSACTIONS_COLLECTION).add({
        'accountNumber': account_number,
        'userId': user_id,
        'type': transaction_type,
        'amount': amount,
        'balanceAfter': new_balance,
        'memo': memo,
        'timestamp': datetime.now(timezone.utc)
    })
    
    return True

def deduct_from_bank(user_id: int, amount: float, transaction_type: str, memo: str = "") -> bool:
    """Deduct amount from bank balance. Returns True if successful. Uses atomic transaction to prevent race conditions."""
    if not db:
        return False
    
    # Get or create account first
    account = get_or_create_bank_account(user_id)
    if not account or not account.exists:
        return False
    
    account_data = account.to_dict()
    account_number = account_data.get('accountNumber')
    account_ref = db.collection(BANK_ACCOUNTS_COLLECTION).document(account.id)
    
    # Use Firestore transaction for atomic read-check-write
    @firestore.transactional
    def deduct_transaction(transaction):
        # Read current balance atomically
        snapshot = account_ref.get(transaction=transaction)
        current_balance = snapshot.to_dict().get('balance', 0.0)
        
        # Check if sufficient funds
        if current_balance < amount:
            return False  # Insufficient funds
        
        # Calculate new balance
        new_balance = current_balance - amount
        
        # Update balance atomically
        transaction.update(account_ref, {'balance': new_balance})
        
        # Log transaction (outside transaction for performance)
        return (True, new_balance, account_number)
    
    try:
        # Execute atomic transaction
        transaction = db.transaction()
        result = deduct_transaction(transaction)
        
        if result is False:
            return False  # Insufficient funds
        
        # Unpack result and log transaction
        success, new_balance, account_number = result
        
        # Log transaction (non-atomic, but balance update was atomic)
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'accountNumber': account_number,
            'userId': user_id,
            'type': transaction_type,
            'amount': -amount,
            'balanceAfter': new_balance,
            'memo': memo,
            'timestamp': datetime.now(timezone.utc)
        })
        
        return True
    except Exception as e:
        print(f"[ERR] Bank deduction transaction failed: {e}")
        return False

def deposit_to_bank(user_id: int, amount: float, transaction_type: str, memo: str = "") -> bool:
    """Deposit amount to bank balance. Returns True if successful."""
    if not db:
        return False
    
    current_balance = get_bank_balance(user_id)
    new_balance = current_balance + amount
    return update_bank_balance(user_id, new_balance, transaction_type, amount, memo)

# ========================================
# MULTI-COMMODITY BANKING FUNCTIONS
# ========================================

def get_commodity_balance(user_id: int, commodity: str) -> float:
    """Get balance for a specific commodity (diamond, essence, iron, gold, emerald, blocks)"""
    account = get_or_create_bank_account(user_id)
    if account and account.exists:
        data = account.to_dict()
        if commodity == 'diamond':
            return data.get('diamondBalance', data.get('balance', 0.0))
        elif commodity == 'essence':
            return data.get('essenceBalance', 0.0)
        elif commodity == 'iron':
            return data.get('ironBalance', 0.0)
        elif commodity == 'gold':
            return data.get('goldBalance', 0.0)
        elif commodity == 'emerald':
            return data.get('emeraldBalance', 0.0)
        # CivMC Block commodities
        elif commodity == 'iron_block':
            return data.get('ironBlockBalance', 0.0)
        elif commodity == 'gold_block':
            return data.get('goldBlockBalance', 0.0)
        elif commodity == 'emerald_block':
            return data.get('emeraldBlockBalance', 0.0)
    return 0.0

def update_commodity_balance(user_id: int, commodity: str, amount: float, transaction_type: str, memo: str = "") -> bool:
    """Update commodity balance and log transaction. Uses atomic transaction to prevent race conditions."""
    if not db:
        return False
    
    # Get or create account first
    account = get_or_create_bank_account(user_id)
    if not account or not account.exists:
        return False
    
    account_data = account.to_dict()
    account_number = account_data.get('accountNumber')
    account_ref = db.collection(BANK_ACCOUNTS_COLLECTION).document(account.id)
    
    # Map commodity names to balance field names
    field_name_map = {
        'diamond': 'diamondBalance',
        'essence': 'essenceBalance',
        'iron': 'ironBalance',
        'gold': 'goldBalance',
        'emerald': 'emeraldBalance',
        'iron_block': 'ironBlockBalance',
        'gold_block': 'goldBlockBalance',
        'emerald_block': 'emeraldBlockBalance'
    }
    field_name = field_name_map.get(commodity, f'{commodity}Balance')
    
    # Use Firestore transaction for atomic read-check-write
    @firestore.transactional
    def commodity_transaction(transaction):
        # Read current balance atomically
        snapshot = account_ref.get(transaction=transaction)
        data = snapshot.to_dict()
        
        # Get current commodity balance
        if commodity == 'diamond':
            current_balance = data.get('diamondBalance', data.get('balance', 0.0))
        elif commodity == 'essence':
            current_balance = data.get('essenceBalance', 0.0)
        elif commodity == 'iron':
            current_balance = data.get('ironBalance', 0.0)
        elif commodity == 'gold':
            current_balance = data.get('goldBalance', 0.0)
        elif commodity == 'emerald':
            current_balance = data.get('emeraldBalance', 0.0)
        # CivMC Block commodities
        elif commodity == 'iron_block':
            current_balance = data.get('ironBlockBalance', 0.0)
        elif commodity == 'gold_block':
            current_balance = data.get('goldBlockBalance', 0.0)
        elif commodity == 'emerald_block':
            current_balance = data.get('emeraldBlockBalance', 0.0)
        else:
            return False
        
        # Calculate new balance
        new_balance = current_balance + amount
        
        # Prevent negative balances
        if new_balance < 0:
            return False
        
        # Update balance atomically
        transaction.update(account_ref, {field_name: new_balance})
        
        return (True, new_balance, account_number)
    
    try:
        # Execute atomic transaction
        transaction = db.transaction()
        result = commodity_transaction(transaction)
        
        if result is False:
            return False  # Insufficient funds or error
        
        # Unpack result and log transaction
        success, new_balance, account_number = result
        
        # Log transaction (non-atomic, but balance update was atomic)
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'accountNumber': account_number,
            'userId': user_id,
            'commodity': commodity,
            'type': transaction_type,
            'amount': amount,
            'balanceAfter': new_balance,
            'memo': memo,
            'timestamp': datetime.now(timezone.utc)
        })
        
        return True
    except Exception as e:
        print(f"[ERR] Commodity balance transaction failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def get_market_price(commodity: str) -> float:
    """Get current market price for a commodity in diamonds (for calculations)"""
    if not db:
        return 1.0  # Default price
    
    # Diamond is always 1.0 unless explicitly set otherwise
    if commodity == 'diamond':
        try:
            price_doc = db.collection(MARKET_PRICES_COLLECTION).document('diamond').get()
            if price_doc.exists:
                return price_doc.to_dict().get('price', 1.0)
            return 1.0  # Default: 1 diamond = 1 diamond
        except Exception as e:
            print(f"[ERR] Failed to get diamond price: {e}")
            return 1.0
    
    try:
        price_doc = db.collection(MARKET_PRICES_COLLECTION).document(commodity).get()
        if price_doc.exists:
            return price_doc.to_dict().get('price', 1.0)
        else:
            # Initialize default prices and rates
            default_configs = {
                'essence': {'price': 0.2857, 'rate': 3.5, 'unit': 'es/1d'},
                'iron': {'price': 0.125, 'rate': 8.0, 'unit': 'i/1d'},
                'gold': {'price': 0.05, 'rate': 20.0, 'unit': 'gld/1d'},
                'emerald': {'price': 0.2727, 'rate': 3.67, 'unit': 'em/1d'},
                'iron_block': {'price': 0.125, 'rate': 8.0, 'unit': 'iblk/1d'},
                'gold_block': {'price': 0.1430, 'rate': 6.99, 'unit': 'gblk/1d'},
                'emerald_block': {'price': 0.2727, 'rate': 3.67, 'unit': 'eblk/1d'}
            }
            if commodity in default_configs:
                config = default_configs[commodity]
                # Note: This function is not async. Wrapping to prevent blocking.
                import asyncio
                try:
                    loop = asyncio.get_event_loop()
                    if loop.is_running():
                        import concurrent.futures
                        with concurrent.futures.ThreadPoolExecutor() as executor:
                            executor.submit(lambda: db.collection(MARKET_PRICES_COLLECTION).document(commodity).set({
                                'price': config['price'],
                                'rate': config['rate'],
                                'unit': config['unit'],
                                'lastUpdated': datetime.now(timezone.utc),
                                'supply': 0,
                                'demand': 0
                            })).result(timeout=5)
                    else:
                        db.collection(MARKET_PRICES_COLLECTION).document(commodity).set({
                            'price': config['price'],
                            'rate': config['rate'],
                            'unit': config['unit'],
                            'lastUpdated': datetime.now(timezone.utc),
                            'supply': 0,
                            'demand': 0
                        })
                except:
                    db.collection(MARKET_PRICES_COLLECTION).document(commodity).set({
                        'price': config['price'],
                        'rate': config['rate'],
                        'unit': config['unit'],
                        'lastUpdated': datetime.now(timezone.utc),
                        'supply': 0,
                        'demand': 0
                    })
                return config['price']
            return 1.0
    except Exception as e:
        print(f"[ERR] Failed to get market price for {commodity}: {e}")
        return 1.0

def format_market_rate(commodity: str) -> str:
    """Format market rate for display - returns clean string with CivMC style spread if set"""
    rate, unit, buy_rate, sell_rate, spread = get_market_rate(commodity)
    
    if spread > 0 and buy_rate > 0 and sell_rate > 0:
        # Show CivMC-style spread: ‚Üìbuy | ‚Üësell (mid)
        return f"‚Üì{buy_rate:.2f}{unit} | ‚Üë{sell_rate:.2f}{unit}"
    else:
        # Simple rate display
        return f"{rate:.2f}{unit}"

def get_market_rate(commodity: str) -> tuple:
    """Get current market rate for display - returns (rate, unit, buy_rate, sell_rate, spread)"""
    if not db:
        return (1.0, "", 0.0, 0.0, 0.0)
    
    try:
        # Special handling for diamond
        if commodity == 'diamond':
            price_doc = db.collection(MARKET_PRICES_COLLECTION).document('diamond').get()
            if price_doc.exists:
                data = price_doc.to_dict()
                rate = data.get('rate', 1.0)
                buy_rate = data.get('buyRate', 0.0)
                sell_rate = data.get('sellRate', 0.0)
                spread = data.get('spreadPercent', 0.0)
                return (rate, "d/1d", buy_rate, sell_rate, spread)
            return (1.0, "d/1d", 0.0, 0.0, 0.0)  # Default: 1 diamond = 1 diamond
        
        price_doc = db.collection(MARKET_PRICES_COLLECTION).document(commodity).get()
        if price_doc.exists:
            data = price_doc.to_dict()
            rate = data.get('rate')
            price = data.get('price', 1.0)
            buy_rate = data.get('buyRate', 0.0)
            sell_rate = data.get('sellRate', 0.0)
            spread = data.get('spreadPercent', 0.0)
            
            # Calculate rate if not stored
            if not rate:
                rate = 1.0 / price if price > 0 else 1.0
            
            # ALWAYS return new format: (rate, unit, buy_rate, sell_rate, spread)
            # For blocks, apply 1/9 conversion to all rates
            if commodity == 'essence':
                return (rate, "es/1d", buy_rate, sell_rate, spread)
            elif commodity == 'iron':
                return (rate, "i/1d", buy_rate, sell_rate, spread)
            elif commodity == 'gold':
                return (rate, "gld/1d", buy_rate, sell_rate, spread)
            elif commodity == 'emerald':
                return (rate, "em/1d", buy_rate, sell_rate, spread)
            elif commodity == 'iron_block':
                # Blocks: 1 iron block = 9 iron ingots
                block_rate = rate / 9.0
                block_buy = buy_rate / 9.0 if buy_rate > 0 else 0.0
                block_sell = sell_rate / 9.0 if sell_rate > 0 else 0.0
                return (block_rate, "iblk/1d", block_buy, block_sell, spread)
            elif commodity == 'gold_block':
                block_rate = rate / 9.0
                block_buy = buy_rate / 9.0 if buy_rate > 0 else 0.0
                block_sell = sell_rate / 9.0 if sell_rate > 0 else 0.0
                return (block_rate, "gblk/1d", block_buy, block_sell, spread)
            elif commodity == 'emerald_block':
                block_rate = rate / 9.0
                block_buy = buy_rate / 9.0 if buy_rate > 0 else 0.0
                block_sell = sell_rate / 9.0 if sell_rate > 0 else 0.0
                return (block_rate, "eblk/1d", block_buy, block_sell, spread)
            else:
                return (rate, "/1d", buy_rate, sell_rate, spread)
        else:
            # Trigger initialization
            get_market_price(commodity)
            # Try again
            price_doc = db.collection(MARKET_PRICES_COLLECTION).document(commodity).get()
            if price_doc.exists:
                data = price_doc.to_dict()
                rate = data.get('rate', 1.0)
                buy = data.get('buyRate', 0.0)
                sell = data.get('sellRate', 0.0)
                spread = data.get('spreadPercent', 0.0)
                return (rate, data.get('unit', ''), buy, sell, spread)
            return (1.0, '', 0.0, 0.0, 0.0)
    except Exception as e:
        print(f"[ERR] Failed to get market rate for {commodity}: {e}")
        return (1.0, '', 0.0, 0.0, 0.0)

def update_market_price(commodity: str, new_price: float):
    """Update market price for a commodity"""
    if not db:
        return
    
    try:
        # Note: This function is not async. Wrapping to prevent blocking.
        import asyncio
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                import concurrent.futures
                with concurrent.futures.ThreadPoolExecutor() as executor:
                    executor.submit(lambda: db.collection(MARKET_PRICES_COLLECTION).document(commodity).update({
                        'price': new_price,
                        'lastUpdated': datetime.now(timezone.utc)
                    })).result(timeout=5)
            else:
                db.collection(MARKET_PRICES_COLLECTION).document(commodity).update({
                    'price': new_price,
                    'lastUpdated': datetime.now(timezone.utc)
                })
        except:
            db.collection(MARKET_PRICES_COLLECTION).document(commodity).update({
                'price': new_price,
                'lastUpdated': datetime.now(timezone.utc)
            })
    except Exception as e:
        print(f"[ERR] Failed to update market price: {e}")

# ========================================
# GRAPH GENERATION SYSTEM
# ========================================

def generate_stock_price_graph(business_name: str, days: int = None) -> BytesIO:
    """Generate stock price history graph for a business"""
    if not db:
        return None
    
    try:
        
        # Get all transactions for this business
        query = db.collection(STOCK_TRANSACTIONS_COLLECTION).where(
            filter=FieldFilter('businessName', '==', business_name)
        ).order_by('timestamp')
        
        transactions = list(query.stream())
        
        if not transactions:
            return None
        
        # Extract timestamps and prices (convert to EST)
        est = EST
        dates = []
        prices = []
        
        for tx in transactions:
            data = tx.to_dict()
            utc_time = data['timestamp'].replace(tzinfo=timezone.utc)
            est_time = utc_time.astimezone(est)
            dates.append(est_time)
            prices.append(data.get('pricePerShare', 0))
        
        # Create professional graph
        fig, ax = plt.subplots(figsize=(12, 6), facecolor='white')
        
        # Plot line with gradient fill
        ax.plot(dates, prices, marker='o', linestyle='-', linewidth=2.5, 
                markersize=6, color='#1e3a5f', markerfacecolor='#4a90e2', 
                markeredgewidth=1.5, markeredgecolor='#1e3a5f')
        ax.fill_between(dates, prices, alpha=0.2, color='#1e3a5f')
        
        # Styling
        ax.set_title(f'{business_name} - Stock Price History', 
                     fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel('Date (EST)', fontsize=12, fontweight='bold')
        ax.set_ylabel('Price (diamonds per share)', fontsize=12, fontweight='bold')
        
        # Professional grid
        ax.grid(True, alpha=0.3, linestyle='--', linewidth=0.7)
        ax.set_axisbelow(True)
        
        # Smart date formatting based on time span
        time_span = (dates[-1] - dates[0]).days if len(dates) > 1 else 0
        if time_span > 365:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y', tz=EST))
            ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3, tz=EST))
        elif time_span > 30:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d', tz=EST))
            ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=1, tz=EST))
        else:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d', tz=EST))
            ax.xaxis.set_major_locator(mdates.DayLocator(interval=1, tz=EST))
        
        plt.gcf().autofmt_xdate(rotation=45)
        
        # Add value labels on points
        for i, (date, price) in enumerate(zip(dates, prices)):
            if i == 0 or i == len(dates) - 1 or i % max(1, len(dates) // 5) == 0:
                ax.annotate(f'{price:.2f}d', (date, price), 
                           textcoords="offset points", xytext=(0,8), 
                           ha='center', fontsize=9, alpha=0.7)
        
        plt.tight_layout()
        
        # Save to temporary file then load into BytesIO (fixes Replit I/O error)
        tmp_path = None
        try:
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                tmp_path = tmp.name
            
            plt.savefig(tmp_path, format='png', dpi=150, bbox_inches='tight', facecolor='white')
            plt.close()
            
            with open(tmp_path, 'rb') as f:
                buffer = BytesIO(f.read())
            
            buffer.seek(0)
            return buffer
        except Exception as save_err:
            print(f"[ERR] Error saving stock price graph: {save_err}")
            import traceback
            traceback.print_exc()
            plt.close()
            return None
        finally:
            if tmp_path and os.path.exists(tmp_path):
                try:
                    os.remove(tmp_path)
                except:
                    pass
    except Exception as e:
        print(f"[ERR] Failed to generate stock price graph: {e}")
        import traceback
        traceback.print_exc()
        return None

def generate_market_cap_graph() -> BytesIO:
    """Generate total market capitalization trend graph"""
    if not db:
        return None
    
    try:
        
        # Get all stock transactions sorted by time
        query = db.collection(STOCK_TRANSACTIONS_COLLECTION).order_by('timestamp')
        transactions = list(query.stream())
        
        if not transactions:
            return None
        
        # Calculate market cap over time
        est = EST
        dates = []
        market_caps = []
        business_shares = {}
        
        for tx in transactions:
            data = tx.to_dict()
            business = data.get('businessName')
            price = data.get('pricePerShare', 0)
            
            # Get total shares for this business
            ipo_docs = list(db.collection(IPOS_COLLECTION).where(
                filter=FieldFilter('businessName', '==', business)
            ).limit(1).stream())
            
            if ipo_docs:
                total_shares = ipo_docs[0].to_dict().get('totalShares', 0)
                business_shares[business] = (total_shares, price)
            
            # Calculate total market cap
            total_cap = sum(shares * price for shares, price in business_shares.values())
            
            utc_time = data['timestamp'].replace(tzinfo=timezone.utc)
            est_time = utc_time.astimezone(est)
            dates.append(est_time)
            market_caps.append(total_cap)
        
        # Create professional graph
        fig, ax = plt.subplots(figsize=(12, 6), facecolor='white')
        
        # Plot with gradient fill
        ax.fill_between(dates, market_caps, alpha=0.25, color='#1e3a5f')
        ax.plot(dates, market_caps, linewidth=2.5, color='#1e3a5f', marker='o', 
                markersize=4, markerfacecolor='#4a90e2')
        
        # Styling
        ax.set_title('Total Market Capitalization', fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel('Date (EST)', fontsize=12, fontweight='bold')
        ax.set_ylabel('Market Cap (diamonds)', fontsize=12, fontweight='bold')
        
        # Professional grid
        ax.grid(True, alpha=0.3, linestyle='--', linewidth=0.7)
        ax.set_axisbelow(True)
        
        # Smart date formatting (dates are already in EST timezone)
        time_span = (dates[-1] - dates[0]).days if len(dates) > 1 else 0
        if time_span > 365:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
            ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        elif time_span > 30:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d'))
            ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=1))
        else:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d'))
            ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
        
        plt.gcf().autofmt_xdate(rotation=45)
        plt.tight_layout()
        
        # Save to temporary file then load into BytesIO (fixes Replit I/O error)
        tmp_path = None
        try:
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                tmp_path = tmp.name
            
            plt.savefig(tmp_path, format='png', dpi=150, bbox_inches='tight', facecolor='white')
            plt.close()
            
            with open(tmp_path, 'rb') as f:
                buffer = BytesIO(f.read())
            
            buffer.seek(0)
            return buffer
        except Exception as save_err:
            print(f"[ERR] Error saving market cap graph: {save_err}")
            import traceback
            traceback.print_exc()
            plt.close()
            return None
        finally:
            if tmp_path and os.path.exists(tmp_path):
                try:
                    os.remove(tmp_path)
                except:
                    pass
    except Exception as e:
        print(f"[ERR] Failed to generate market cap graph: {e}")
        import traceback
        traceback.print_exc()
        plt.close()  # Ensure cleanup
        return None

def generate_economy_gdp_graph() -> BytesIO:
    """Generate GDP (state reserves + citizen liquidity) trend graph"""
    if not db:
        return None
    
    try:
        
        # Get all treasury transactions
        treasury_logs = list(db.collection(TREASURY_LOG_COLLECTION).order_by('timestamp').stream())
        bank_txs = list(db.collection(BANK_TRANSACTIONS_COLLECTION).order_by('timestamp').stream())
        
        if not treasury_logs and not bank_txs:
            return None
        
        # Combine and sort all transactions
        all_events = []
        
        for log in treasury_logs:
            data = log.to_dict()
            all_events.append((data['timestamp'], 'treasury', data))
        
        for tx in bank_txs:
            data = tx.to_dict()
            all_events.append((data['timestamp'], 'bank', data))
        
        all_events.sort(key=lambda x: x[0])
        
        # Calculate running GDP
        est = EST
        dates = []
        gdp_values = []
        treasury_total = 0
        citizen_liquidity = 0
        
        for timestamp, event_type, data in all_events:
            if event_type == 'treasury':
                # Update treasury total
                treasury_total += data.get('amount', 0)
            elif event_type == 'bank':
                # Update citizen liquidity
                amount = data.get('amount', 0)
                if data.get('type') == 'deposit':
                    citizen_liquidity += amount
                elif data.get('type') == 'withdrawal':
                    citizen_liquidity -= amount
            
            utc_time = timestamp.replace(tzinfo=timezone.utc)
            est_time = utc_time.astimezone(est)
            dates.append(est_time)
            gdp_values.append(treasury_total + citizen_liquidity)
        
        if not dates:
            return None
        
        # Create professional graph
        fig, ax = plt.subplots(figsize=(12, 6), facecolor='white')
        
        # Plot with gold gradient fill
        ax.fill_between(dates, gdp_values, alpha=0.25, color='#d4af37')
        ax.plot(dates, gdp_values, linewidth=2.5, color='#b8860b', marker='o', 
                markersize=4, markerfacecolor='#ffd700')
        
        # Styling
        ax.set_title('Florab√≠s GDP Trend (State + Citizens)', fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel('Date (EST)', fontsize=12, fontweight='bold')
        ax.set_ylabel('GDP (diamonds)', fontsize=12, fontweight='bold')
        
        # Professional grid
        ax.grid(True, alpha=0.3, linestyle='--', linewidth=0.7)
        ax.set_axisbelow(True)
        
        # Smart date formatting (dates are already in EST timezone)
        time_span = (dates[-1] - dates[0]).days if len(dates) > 1 else 0
        if time_span > 365:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
            ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        elif time_span > 30:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d'))
            ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=1))
        else:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d'))
            ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
        
        plt.gcf().autofmt_xdate(rotation=45)
        plt.tight_layout()
        
        # Save to temporary file then load into BytesIO (fixes Replit I/O error)
        tmp_path = None
        try:
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                tmp_path = tmp.name
            
            plt.savefig(tmp_path, format='png', dpi=150, bbox_inches='tight', facecolor='white')
            plt.close()
            
            with open(tmp_path, 'rb') as f:
                buffer = BytesIO(f.read())
            
            buffer.seek(0)
            return buffer
        except Exception as save_err:
            print(f"[ERR] Error saving GDP graph: {save_err}")
            import traceback
            traceback.print_exc()
            plt.close()
            return None
        finally:
            if tmp_path and os.path.exists(tmp_path):
                try:
                    os.remove(tmp_path)
                except:
                    pass
    except Exception as e:
        print(f"[ERR] Failed to generate GDP graph: {e}")
        import traceback
        traceback.print_exc()
        plt.close()  # Ensure cleanup
        return None

def generate_betting_volume_graph() -> BytesIO:
    """Generate betting volume and winnings graph"""
    if not db:
        return None
    
    try:
        
        # Get all bets
        bets = list(db.collection(BETS_COLLECTION).order_by('timestamp').stream())
        
        if not bets:
            return None
        
        # Calculate daily betting volume
        est = EST
        daily_volume = {}
        
        for bet in bets:
            data = bet.to_dict()
            timestamp = data.get('timestamp')
            if timestamp:
                utc_time = timestamp.replace(tzinfo=timezone.utc)
                est_time = utc_time.astimezone(est)
                date = est_time.replace(hour=0, minute=0, second=0, microsecond=0)
                amount = data.get('amount', 0)
                
                if date not in daily_volume:
                    daily_volume[date] = 0
                daily_volume[date] += amount
        
        # Sort by date
        sorted_dates = sorted(daily_volume.keys())
        volumes = [daily_volume[date] for date in sorted_dates]
        
        # Create professional graph
        fig, ax = plt.subplots(figsize=(12, 6), facecolor='white')
        
        # Professional bar chart with gradient
        bars = ax.bar(sorted_dates, volumes, color='#228B22', alpha=0.75, width=0.8,
                      edgecolor='#1a6b1a', linewidth=1.5)
        
        # Styling
        ax.set_title('Tom Brady\'s Betting Exchange - Daily Volume', fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel('Date (EST)', fontsize=12, fontweight='bold')
        ax.set_ylabel('Total Bets (diamonds)', fontsize=12, fontweight='bold')
        
        # Professional grid
        ax.grid(True, alpha=0.3, axis='y', linestyle='--', linewidth=0.7)
        ax.set_axisbelow(True)
        
        # Smart date formatting
        time_span = (sorted_dates[-1] - sorted_dates[0]).days if len(sorted_dates) > 1 else 0
        if time_span > 365:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y', tz=EST))
            ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3, tz=EST))
        elif time_span > 30:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d', tz=EST))
            ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=1, tz=EST))
        else:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d', tz=EST))
            ax.xaxis.set_major_locator(mdates.DayLocator(interval=1, tz=EST))
        
        plt.gcf().autofmt_xdate(rotation=45)
        plt.tight_layout()
        
        # Save to temporary file then load into BytesIO (fixes Replit I/O error)
        tmp_path = None
        try:
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                tmp_path = tmp.name
            
            plt.savefig(tmp_path, format='png', dpi=150, bbox_inches='tight', facecolor='white')
            plt.close()
            
            with open(tmp_path, 'rb') as f:
                buffer = BytesIO(f.read())
            
            buffer.seek(0)
            return buffer
        except Exception as save_err:
            print(f"[ERR] Error saving betting volume graph: {save_err}")
            import traceback
            traceback.print_exc()
            plt.close()
            return None
        finally:
            if tmp_path and os.path.exists(tmp_path):
                try:
                    os.remove(tmp_path)
                except:
                    pass
    except Exception as e:
        print(f"[ERR] Failed to generate betting volume graph: {e}")
        import traceback
        traceback.print_exc()
        plt.close()  # Ensure cleanup
        return None

def generate_banking_deposits_graph() -> BytesIO:
    """Generate total banking deposits over time graph"""
    if not db:
        return None
    
    try:
        
        # Get all bank transactions
        transactions = list(db.collection(BANK_TRANSACTIONS_COLLECTION).order_by('timestamp').stream())
        
        if not transactions:
            return None
        
        # Calculate running total deposits
        est = EST
        dates = []
        total_deposits = []
        running_total = 0
        
        for tx in transactions:
            data = tx.to_dict()
            amount = data.get('amount', 0)
            tx_type = data.get('type', '')
            
            if tx_type == 'deposit':
                running_total += amount
            elif tx_type == 'withdrawal':
                running_total -= amount
            
            utc_time = data['timestamp'].replace(tzinfo=timezone.utc)
            est_time = utc_time.astimezone(est)
            dates.append(est_time)
            total_deposits.append(running_total)
        
        # Create professional graph
        fig, ax = plt.subplots(figsize=(12, 6), facecolor='white')
        
        # Plot with premium bank colors
        ax.fill_between(dates, total_deposits, alpha=0.25, color='#003d5c')
        ax.plot(dates, total_deposits, linewidth=2.5, color='#003d5c', marker='o', 
                markersize=4, markerfacecolor='#0066cc')
        
        # Styling
        ax.set_title('Florab√≠s State Bank - Total Deposits', fontsize=16, fontweight='bold', pad=20)
        ax.set_xlabel('Date (EST)', fontsize=12, fontweight='bold')
        ax.set_ylabel('Total Deposits (diamonds)', fontsize=12, fontweight='bold')
        
        # Professional grid
        ax.grid(True, alpha=0.3, linestyle='--', linewidth=0.7)
        ax.set_axisbelow(True)
        
        # Smart date formatting (dates are already in EST timezone)
        time_span = (dates[-1] - dates[0]).days if len(dates) > 1 else 0
        if time_span > 365:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
            ax.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        elif time_span > 30:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d'))
            ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=1))
        else:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %d'))
            ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
        
        plt.gcf().autofmt_xdate(rotation=45)
        plt.tight_layout()
        
        # Save to temporary file then load into BytesIO (fixes Replit I/O error)
        tmp_path = None
        try:
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp:
                tmp_path = tmp.name
            
            plt.savefig(tmp_path, format='png', dpi=150, bbox_inches='tight', facecolor='white')
            plt.close()
            
            with open(tmp_path, 'rb') as f:
                buffer = BytesIO(f.read())
            
            buffer.seek(0)
            return buffer
        except Exception as save_err:
            print(f"[ERR] Error saving banking deposits graph: {save_err}")
            import traceback
            traceback.print_exc()
            plt.close()
            return None
        finally:
            if tmp_path and os.path.exists(tmp_path):
                try:
                    os.remove(tmp_path)
                except:
                    pass
    except Exception as e:
        print(f"[ERR] Failed to generate banking deposits graph: {e}")
        import traceback
        traceback.print_exc()
        plt.close()  # Ensure cleanup
        return None

class CitizenRegistrationModal(ui.Modal, title="Enter Your IGN"):
    ign_input = ui.TextInput(
        label="Minecraft IGN",
        placeholder="Your in-game name",
        required=True,
        max_length=16,
        style=discord.TextStyle.short
    )
    
    def __init__(self, citizenship_type: str):
        super().__init__()
        self.citizenship_type = citizenship_type
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        ign = self.ign_input.value.strip()
        
        if is_citizen(interaction.user.id):
            # Find their existing IGN
            existing_citizen = db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', interaction.user.id)).limit(1).stream()
            existing_ign = "unknown"
            for doc in existing_citizen:
                existing_ign = doc.to_dict().get('ign', 'unknown')
            return await interaction.edit_original_response(content=
                f"‚ùå **Already Registered**\n\n"
                f"You are already registered as a citizen with IGN: `{existing_ign}`\n\n"
                f"If you need to update your IGN, please contact an administrator."
            )
        
        # SNITCH VERIFICATION REQUIRED
        if not has_snitch_hit(ign):
            print(f"[WARN] Registration failed for {interaction.user} ({ign}) - no snitch hits")
            return await interaction.edit_original_response(content=
                f"‚ùå **Snitch Verification Failed**\n\n"
                f"Your IGN `{ign}` has **no recorded snitch hits** in Florab√≠s territory.\n\n"
                f"**To register, you must:**\n"
                f"1. Visit Florab√≠s territory in-game\n"
                f"2. Trigger a snitch (walk around/interact with blocks)\n"
                f"3. Wait a few seconds for the automatic relay system to capture your IGN\n"
                f"4. Try registering again\n\n"
                f"‚úÖ *Snitch hits are captured automatically in real-time - no admin needed!*\n"
                f"üìù *Admins can verify your snitch hits with `/check_snitch_logs {ign}`*"
            )
        
        # Register citizen with error handling
        try:
            await asyncio.to_thread(lambda: db.collection(CITIZENS_COLLECTION).document().set({
                'userId': interaction.user.id,
                'username': str(interaction.user),
                'ign': ign,
                'citizenshipType': self.citizenship_type,
                'registeredAt': datetime.now(timezone.utc),
                'registeredBy': 'self',
                'snitchVerified': True  # Only verified citizens can register
            }))
            print(f"[OK] Citizen registered: {interaction.user} ({ign}) - {self.citizenship_type}")
        except Exception as e:
            print(f"[ERR] Failed to register citizen {interaction.user} ({ign}): {e}")
            return await interaction.edit_original_response(content=
                f"‚ùå **Registration Failed**\n\n"
                f"Database error occurred. Please contact an administrator.\n\n"
                f"Error: {str(e)}"
            )
        
        # Auto-assign citizen roles (base + universal + optional dual)
        role_assigned = False
        role_error = None
        if interaction.guild:
            print(f"[DEBUG] Assigning roles for {self.citizenship_type} citizen")
            
            # Get all required roles
            base_citizen_role = interaction.guild.get_role(CITIZEN_ROLE_ID) if CITIZEN_ROLE_ID else None
            universal_role = interaction.guild.get_role(UNIVERSAL_CITIZEN_ROLE_ID) if UNIVERSAL_CITIZEN_ROLE_ID else None
            dual_citizen_role = interaction.guild.get_role(SECONDARY_CITIZEN_ROLE_ID) if (self.citizenship_type == "secondary" and SECONDARY_CITIZEN_ROLE_ID) else None
            resident_role = interaction.guild.get_role(RESIDENT_ROLE_ID) if (self.citizenship_type == "resident" and RESIDENT_ROLE_ID) else None
            
            if not isinstance(interaction.user, discord.Member):
                role_error = "User is not a guild member"
                print(f"[WARN] {role_error}")
            else:
                try:
                    roles_to_assign = []
                    
                    if self.citizenship_type == "resident":
                        # Residents get resident role + base citizen role
                        if resident_role:
                            roles_to_assign.append(resident_role)
                        if base_citizen_role:
                            roles_to_assign.append(base_citizen_role)
                    else:
                        # Citizens get base citizen role + universal role
                        if base_citizen_role:
                            roles_to_assign.append(base_citizen_role)
                        if universal_role:
                            roles_to_assign.append(universal_role)
                        # ONLY secondary citizens get the extra dual role
                        if dual_citizen_role:
                            roles_to_assign.append(dual_citizen_role)
                    
                    if roles_to_assign:
                        await interaction.user.add_roles(*roles_to_assign, reason=f"{self.citizenship_type} citizen registration")
                        role_names = [r.name for r in roles_to_assign]
                        print(f"[OK] Assigned {len(roles_to_assign)} role(s) to {interaction.user}: {', '.join(role_names)}")
                        role_assigned = True
                    else:
                        role_error = "No roles configured or found"
                        print(f"[WARN] {role_error}")
                        
                except discord.Forbidden:
                    role_error = "Bot lacks permission to manage roles"
                    print(f"[ERR] {role_error} - Check bot permissions and role hierarchy")
                except Exception as e:
                    role_error = str(e)
                    print(f"[ERR] Failed to assign roles: {e}")
        
        citizenship_labels = {"primary": "Primary Citizen", "secondary": "Secondary Citizen (Dual)", "resident": "Resident"}
        citizenship_label = citizenship_labels.get(self.citizenship_type, self.citizenship_type)
        
        if role_assigned:
            role_msg = f"\nüéñÔ∏è Role assigned!" if self.citizenship_type == "resident" else f"\nüéñÔ∏è Citizen role assigned!"
        elif role_error:
            role_msg = f"\n‚ö†Ô∏è Role assignment failed: {role_error}\nPlease contact an admin for manual role assignment."
        else:
            role_msg = ""
            
        await interaction.edit_original_response(content=
            f"‚úÖ **Registration Successful!**\n\n"
            f"**IGN:** {ign}\n"
            f"**Citizenship:** {citizenship_label}{role_msg}\n"
            f"Welcome to Florab√≠s!")

class CitizenshipTypeView(ui.View):
    def __init__(self, user_id: int):
        super().__init__(timeout=180)
        self.user_id = user_id
    
    @ui.button(label="üèõÔ∏è Primary Citizen", style=discord.ButtonStyle.primary, custom_id="primary_citizen")
    async def primary_button(self, interaction: discord.Interaction, button: ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your registration.", ephemeral=True)
        await interaction.response.send_modal(CitizenRegistrationModal("primary"))
        self.stop()
    
    @ui.button(label="üåê Secondary Citizen (Dual)", style=discord.ButtonStyle.secondary, custom_id="secondary_citizen")
    async def secondary_button(self, interaction: discord.Interaction, button: ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your registration.", ephemeral=True)
        await interaction.response.send_modal(CitizenRegistrationModal("secondary"))
        self.stop()
    
    @ui.button(label="üè† Resident (Non-Citizen)", style=discord.ButtonStyle.success, custom_id="resident")
    async def resident_button(self, interaction: discord.Interaction, button: ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your registration.", ephemeral=True)
        await interaction.response.send_modal(CitizenRegistrationModal("resident"))
        self.stop()

class CitizenRegistrationButton(ui.Button):
    def __init__(self):
        super().__init__(label="üë• Register as Citizen/Resident", style=discord.ButtonStyle.primary, custom_id="citizen_register_button")
    
    async def callback(self, interaction: discord.Interaction):
        # Check if already citizen first
        if is_citizen(interaction.user.id):
            try:
                return await interaction.response.send_message("‚ùå You are already registered as a citizen!", ephemeral=True)
            except:
                return  # Old panel, ignore
        
        embed = discord.Embed(
            title="üë• Registration Application",
            description=(
                "**Select your registration type:**\n\n"
                "üèõÔ∏è **Primary Citizen** - Florab√≠s is your sole State\n"
                "üåê **Secondary Citizen** - Dual citizenship with another nation\n"
                "üè† **Resident** - Live in Florab√≠s but not a citizen\n\n"
                "**Requirements:**\n"
                "‚úÖ Must have triggered a snitch in the State of Florab√≠s"
            ),
            color=discord.Color.from_str("#1f5123")
        )
        embed.set_footer(text="Your IGN will be verified")
        
        try:
            await interaction.response.send_message(embed=embed, view=CitizenshipTypeView(interaction.user.id), ephemeral=True)
        except:
            # Old panel - silently fail
            pass

class ListCitizensButton(ui.Button):
    def __init__(self):
        super().__init__(label="üìã List Citizens", style=discord.ButtonStyle.secondary, custom_id="list_citizens_button")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("üìã Loading citizen list...", ephemeral=True)
        
        primary_citizens = []
        secondary_citizens = []
        residents = []
        
        try:
            for doc in db.collection(CITIZENS_COLLECTION).stream():
                data = doc.to_dict()
                citizenship_type = data.get('citizenshipType', 'primary')
                ign = data.get('ign', 'Unknown')
                user_id = data.get('userId')
                entry = f"‚Ä¢ **{ign}** - <@{user_id}>"
                
                if citizenship_type == 'primary':
                    primary_citizens.append(entry)
                elif citizenship_type == 'secondary':
                    secondary_citizens.append(entry)
                elif citizenship_type == 'resident':
                    residents.append(entry)
        except Exception as e:
            await interaction.edit_original_response(content=f"‚ùå Error fetching citizens: {e}")
            return
        
        total_citizens = len(primary_citizens) + len(secondary_citizens)
        total_residents = len(residents)
        
        if total_citizens == 0 and total_residents == 0:
            await interaction.edit_original_response(content="üìã No citizens or residents registered yet.")
            return
        
        senators = calculate_senators(len(primary_citizens))
        
        description_parts = []
        if primary_citizens:
            description_parts.append(f"**üèõÔ∏è PRIMARY CITIZENS ({len(primary_citizens)})**\n" + "\n".join(primary_citizens))
        if secondary_citizens:
            description_parts.append(f"**üåê SECONDARY CITIZENS ({len(secondary_citizens)})**\n" + "\n".join(secondary_citizens))
        if residents:
            description_parts.append(f"**üè† RESIDENTS ({len(residents)})**\n" + "\n".join(residents))
        
        embed = discord.Embed(
            title=f"üë• Registry of Florab√≠s",
            description="\n\n".join(description_parts),
            color=discord.Color.from_str("#1f5123")
        )
        embed.add_field(
            name="üìä Summary",
            value=f"üèõÔ∏è Primary: {len(primary_citizens)} | üåê Secondary: {len(secondary_citizens)} | üè† Residents: {total_residents}\nüìä Senate Seats: {senators}",
            inline=False
        )
        embed.set_footer(text="‚ö†Ô∏è Residency is NOT citizenship. Residents have limited rights within the State.")
        await interaction.edit_original_response(content=None, embed=embed)

class RefreshCitizensButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Citizens", style=discord.ButtonStyle.secondary, custom_id="refresh_citizens")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing citizen list...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            all_citizens = list(db.collection(CITIZENS_COLLECTION).stream())
            
            if not all_citizens:
                embed = discord.Embed(
                    title="üë• Registry of Florab√≠s",
                    description="No citizens or residents registered yet.",
                    color=discord.Color.from_str("#1f5123")
                )
                return await interaction.edit_original_response(embed=embed)
            
            primary_citizens = []
            secondary_citizens = []
            residents = []
            
            for citizen_doc in all_citizens:
                data = citizen_doc.to_dict()
                citizenship_type = data.get('citizenshipType', 'primary')
                ign = data.get('ign', 'Unknown')
                user_id = data.get('userId')
                entry = f"‚Ä¢ **{ign}** - <@{user_id}>"
                
                if citizenship_type == 'primary':
                    primary_citizens.append(entry)
                elif citizenship_type == 'secondary':
                    secondary_citizens.append(entry)
                elif citizenship_type == 'resident':
                    residents.append(entry)
            
            senators = calculate_senators(len(primary_citizens))
            
            description_parts = []
            if primary_citizens:
                description_parts.append(f"**üèõÔ∏è PRIMARY CITIZENS ({len(primary_citizens)})**\n" + "\n".join(primary_citizens[:10]))
                if len(primary_citizens) > 10:
                    description_parts[-1] += f"\n*...and {len(primary_citizens) - 10} more*"
            if secondary_citizens:
                description_parts.append(f"**üåê SECONDARY CITIZENS ({len(secondary_citizens)})**\n" + "\n".join(secondary_citizens[:10]))
                if len(secondary_citizens) > 10:
                    description_parts[-1] += f"\n*...and {len(secondary_citizens) - 10} more*"
            if residents:
                description_parts.append(f"**üè† RESIDENTS ({len(residents)})**\n" + "\n".join(residents[:10]))
                if len(residents) > 10:
                    description_parts[-1] += f"\n*...and {len(residents) - 10} more*"
            
            embed = discord.Embed(
                title=f"üë• REGISTRY OF FLORAB√çS - LIVE",
                description="\n\n".join(description_parts) if description_parts else "No registrations yet.",
                color=discord.Color.from_str("#1f5123")
            )
            
            embed.add_field(
                name="üìä BREAKDOWN",
                value=f"üèõÔ∏è **Primary:** {len(primary_citizens)}\nüåê **Secondary:** {len(secondary_citizens)}\nüè† **Residents:** {len(residents)}\nüìä **Senate Seats:** {senators}",
                inline=False
            )
            
            embed.set_footer(text="‚ö†Ô∏è Residency is NOT citizenship. Residents have limited rights within the State.")
            
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Refresh citizens failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh citizens: {str(e)}")

class CheckMyStatusButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîç Check My Status", style=discord.ButtonStyle.secondary, custom_id="check_my_status_button")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("üîç Checking your status...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            citizen_docs = await asyncio.to_thread(lambda: list(db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', interaction.user.id)).limit(1).stream()))
            
            if not citizen_docs:
                return await interaction.edit_original_response(content="‚ùå You are not registered as a citizen or resident.")
            
            citizen_data = citizen_docs[0].to_dict()
            
            citizenship_type = citizen_data.get('citizenshipType', 'primary')
            ign = citizen_data.get('ign', 'Unknown')
            registered_at = citizen_data.get('registeredAt')
            
            type_labels = {"primary": "üèõÔ∏è Primary Citizen", "secondary": "üåê Secondary Citizen", "resident": "üè† Resident"}
            type_label = type_labels.get(citizenship_type, citizenship_type)
            
            reg_date_str = "Unknown"
            if registered_at:
                reg_date_est = registered_at.astimezone(EST)
                reg_date_str = reg_date_est.strftime("%B %d, %Y at %I:%M %p EST")
            
            snitch_count = 0
            try:
                snitch_docs = await asyncio.to_thread(lambda: list(db.collection(SNITCH_LOGS_COLLECTION).where(filter=FieldFilter('player', '==', ign)).stream()))
                snitch_count = len(snitch_docs)
            except:
                pass
            
            user_roles = [r.name for r in interaction.user.roles if r.name != "@everyone"] if hasattr(interaction.user, 'roles') else []
            roles_str = ", ".join(user_roles[:10]) if user_roles else "None"
            if len(user_roles) > 10:
                roles_str += f" (+{len(user_roles) - 10} more)"
            
            embed = discord.Embed(
                title="üîç Your Registration Status",
                color=discord.Color.from_str("#1f5123")
            )
            embed.add_field(name="IGN", value=ign, inline=True)
            embed.add_field(name="Type", value=type_label, inline=True)
            embed.add_field(name="Registered", value=reg_date_str, inline=False)
            embed.add_field(name="Snitch Activity", value=f"{snitch_count} recorded triggers", inline=True)
            embed.add_field(name="Your Roles", value=roles_str, inline=False)
            
            if citizenship_type == "resident":
                embed.set_footer(text="‚ö†Ô∏è Residents have limited rights. Apply for citizenship for full access.")
            else:
                embed.set_footer(text="‚úÖ You have full citizen rights in Florab√≠s!")
            
            await interaction.edit_original_response(content=None, embed=embed)
            
        except Exception as e:
            print(f"[ERR] Check my status failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

class CitizenRegistrationPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(CitizenRegistrationButton())
        self.add_item(CheckMyStatusButton())
        self.add_item(ListCitizensButton())
        self.add_item(RefreshCitizensButton())

@bot.tree.command(name="citizen_panel", description="[ADMIN ONLY] Setup citizen registration panel in this channel")
async def citizen_panel(interaction: discord.Interaction):
    # Admin-only check BEFORE any async work
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    # RESPOND IMMEDIATELY to avoid timeout
    await interaction.response.send_message("üë• Creating citizen registration panel...", ephemeral=True)
    
    citizen_count = await asyncio.to_thread(get_citizen_count)
    dual_count = await asyncio.to_thread(get_dual_citizen_count)
    resident_count = await asyncio.to_thread(get_resident_count)
    senator_count = await asyncio.to_thread(get_senator_count)
    await asyncio.sleep(0)  # Yield control
    
    embed = discord.Embed(
        title="üë• Citizen Registration",
        description=(
            "**Welcome to Florab√≠s, a State within the Imperial Federation.**\n\n"
            "Click the button below to register.\n\n"
            "**Registration Types:**\n"
            "üèõÔ∏è **Primary Citizen** - Florab√≠s is your Primary Residence (full voting rights)\n"
            "üåê **Secondary Citizen** - Dual Citizenship with another State/Nation (full voting rights)\n"
            "üè† **Resident** - Living in Florab√≠s but not a citizen (limited rights, no voting)\n\n"
            "**Requirements:**\n"
            "‚úÖ Must have triggered a snitch in the State of Florab√≠s\n\n"
            "**Note:** Citizens must also be active in IFcord or risk removal.\n\n"
            f"üìä **Primary Citizens:** {citizen_count}\n"
            f"üåê **Dual Citizens:** {dual_count}\n"
            f"üè† **Residents:** {resident_count}\n"
            f"üèõÔ∏è **Senators:** {senator_count}"
        ),
        color=discord.Color.from_str("#1f5123")
    )
    embed.set_footer(text="Click Register to begin or Check My Status to view your registration")

    # Check for existing citizen panel in this guild and delete old message
    if db and interaction.guild:
        try:
            existing_panels = await asyncio.to_thread(
                lambda: list(db.collection('florabi_citizen_panels').where(filter=FieldFilter('guildId', '==', interaction.guild.id)).limit(1).stream())
            )
            for doc in existing_panels:
                old_data = doc.to_dict()
                old_channel = interaction.guild.get_channel(old_data.get('channelId'))
                if old_channel:
                    try:
                        old_message = await old_channel.fetch_message(old_data.get('messageId'))
                        await old_message.delete()
                    except:
                        pass
                await asyncio.to_thread(lambda d=doc: d.reference.delete())
        except:
            pass
    # Post new panel with ultra-aggressive retry logic (same as other panels)
    message = None
    last_error = None
    for attempt in range(12):  # Ultra-aggressive retry for Replit free tier network issues
        try:
            await asyncio.sleep(0.3)  # Small delay to ensure connection stability
            fresh_channel = bot.get_channel(interaction.channel.id)
            if not fresh_channel:
                fresh_channel = await bot.fetch_channel(interaction.channel.id)
            
            if attempt > 0:
                await asyncio.sleep(1.0)  # Longer recovery delay
            
            message = await fresh_channel.send(embed=embed, view=CitizenRegistrationPanel())
            if attempt > 0:
                print(f"[OK] Citizen panel sent successfully after {attempt + 1} attempts")
            break  # Success!
        except Exception as send_err:
            last_error = send_err
            error_type = type(send_err).__name__
            print(f"[WARN] Discord send failed (attempt {attempt + 1}/12): {error_type}: {send_err}")
            
            if "Input/output error" in str(send_err) or "Errno 5" in str(send_err):
                print(f"[INFO] Network I/O error detected - this is usually temporary Replit‚ÜîDiscord connectivity")
            
            if attempt < 11:
                wait_time = min(3 * (attempt + 1), 30)
                print(f"[INFO] Waiting {wait_time}s before retry...")
                await asyncio.sleep(wait_time)
            else:
                print(f"[ERR] All 12 attempts failed for citizen panel")
    
    if not message:
        error_msg = str(last_error) if last_error else "Failed to send message after 12 attempts"
        print(f"[ERR] Citizen panel posting failed after all retries: {error_msg}")
        try:
            await interaction.followup.send(
                f"‚ùå Failed to post panel after 12 attempts (waited over 3 minutes)\n\n"
                f"**Error:** {error_msg}\n\n"
                f"**Cause:** Severe network issue between Replit and Discord.\n"
                f"**Solution:** Wait 2-3 minutes and try again. If this persists, contact bot admin.", 
                ephemeral=True
            )
        except discord.HTTPException as followup_err:
            print(f"[ERR] Could not send followup message: {followup_err}")
        return
    
    # Store panel location in Firestore
    if db and interaction.guild:
        try:
            await asyncio.to_thread(lambda: db.collection('florabi_citizen_panels').document().set({
                'guildId': interaction.guild.id,
                'channelId': interaction.channel.id,
                'messageId': message.id,
                'createdAt': datetime.now(timezone.utc)
            }))
        except Exception as e:
            print(f"[WARN] Could not store citizen panel: {e}")
    
    await interaction.edit_original_response(content="‚úÖ Citizen registration panel posted successfully!")

@bot.tree.command(name="set_senators", description="[ADMIN] Manage State Senators (Federal Representatives)")
@app_commands.describe(
    action="add, remove, or list senators",
    member="Select a Discord member (for add/remove)",
    name="Or type senator name manually (for add/remove)"
)
@app_commands.choices(action=[
    app_commands.Choice(name="add", value="add"),
    app_commands.Choice(name="remove", value="remove"),
    app_commands.Choice(name="list", value="list")
])
async def set_senators_cmd(interaction: discord.Interaction, action: str, member: discord.Member = None, name: str = None):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    current_db = await ensure_firestore()
    if not current_db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        gov_doc = await asyncio.to_thread(
            lambda: current_db.collection('florabi_config').document('government_officials').get()
        )
        senators = gov_doc.to_dict().get('senators', []) if gov_doc.exists else []
        
        if action == "list":
            if not senators:
                return await interaction.edit_original_response(content="üìã **State Senators**: None registered")
            senator_list = "\n".join([f"‚Ä¢ {s}" for s in senators])
            return await interaction.edit_original_response(content=f"üìã **State Senators ({len(senators)})**:\n{senator_list}")
        
        senator_name = member.display_name if member else name
        if not senator_name:
            return await interaction.edit_original_response(content="‚ùå Please provide a senator (use member selector or type a name).")
        
        if action == "add":
            if senator_name in senators:
                return await interaction.edit_original_response(content=f"‚ùå **{senator_name}** is already a senator.")
            senators.append(senator_name)
            await asyncio.to_thread(
                lambda: current_db.collection('florabi_config').document('government_officials').update({'senators': senators})
            )
            return await interaction.edit_original_response(content=f"‚úÖ Added **{senator_name}** as State Senator. Website will update shortly.")
        
        elif action == "remove":
            if senator_name not in senators:
                return await interaction.edit_original_response(content=f"‚ùå **{senator_name}** is not a registered senator.")
            senators.remove(senator_name)
            await asyncio.to_thread(
                lambda: current_db.collection('florabi_config').document('government_officials').update({'senators': senators})
            )
            return await interaction.edit_original_response(content=f"‚úÖ Removed **{senator_name}** from State Senators.")
    
    except Exception as e:
        print(f"[ERR] Senator management error: {e}")
        return await interaction.edit_original_response(content="‚ùå Failed to update senators.")



@bot.tree.command(name="set_councilor_domain", description="[ADMIN] Set a councilor's domain/portfolio")
@app_commands.describe(
    councilor="Select the councilor",
    domain="Select the councilor's domain/portfolio"
)
@app_commands.choices(domain=[
    app_commands.Choice(name="Defense & Security", value="Defense & Security"),
    app_commands.Choice(name="Works & Infrastructure", value="Works & Infrastructure"),
    app_commands.Choice(name="Economy & Finance", value="Economy & Finance"),
    app_commands.Choice(name="Justice & Law", value="Justice & Law"),
    app_commands.Choice(name="Culture & Heritage", value="Culture & Heritage"),
    app_commands.Choice(name="Agriculture & Resources", value="Agriculture & Resources"),
    app_commands.Choice(name="Mining & Natural Resources", value="Mining & Natural Resources"),
    app_commands.Choice(name="Population & Settlement", value="Population & Settlement"),
])
async def set_councilor_domain_cmd(interaction: discord.Interaction, councilor: discord.Member, domain: str = None):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    councilor_name = councilor.display_name
    
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    current_db = await ensure_firestore()
    if not current_db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        gov_doc = await asyncio.to_thread(
            lambda: current_db.collection('florabi_config').document('government_officials').get()
        )
        if not gov_doc.exists:
            return await interaction.edit_original_response(content="‚ùå Government officials not found. Run a sync first.")
        
        data = gov_doc.to_dict()
        councilors = data.get('councilors', [])
        councilor_domains = data.get('councilor_domains', {})
        
        if councilor_name not in councilors:
            councilor_list = ", ".join(councilors) if councilors else "None"
            return await interaction.edit_original_response(content=f"‚ùå **{councilor_name}** is not a registered councilor.\n\n**Current councilors:** {councilor_list}")
        
        if domain:
            councilor_domains[councilor_name] = domain
            await asyncio.to_thread(
                lambda: current_db.collection('florabi_config').document('government_officials').update({'councilor_domains': councilor_domains})
            )
            return await interaction.edit_original_response(content=f"‚úÖ Set **{councilor_name}** as **Councilor of {domain}**")
        else:
            if councilor_name in councilor_domains:
                del councilor_domains[councilor_name]
                await asyncio.to_thread(
                    lambda: current_db.collection('florabi_config').document('government_officials').update({'councilor_domains': councilor_domains})
                )
                return await interaction.edit_original_response(content=f"‚úÖ Removed domain from **{councilor_name}**")
            else:
                return await interaction.edit_original_response(content=f"‚ÑπÔ∏è **{councilor_name}** has no domain set.")
    
    except Exception as e:
        print(f"[ERR] Councilor domain error: {e}")
        return await interaction.edit_original_response(content="‚ùå Failed to update councilor domain.")




# ========== COUNCIL STATISTICS COMMAND ==========
@bot.tree.command(name="council_stats", description="View legislative statistics for this month")
async def council_stats_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    current_db = await ensure_firestore()
    if not current_db:
        return await interaction.followup.send("‚ùå Database not available.")
    
    try:
        now = datetime.now(timezone.utc)
        month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        
        all_bills = await asyncio.to_thread(
            lambda: list(current_db.collection(BILL_COLLECTION_NAME).stream())
        )
        
        total_this_month = 0
        passed = 0
        failed = 0
        enacted = 0
        voting = 0
        awaiting = 0
        
        for doc in all_bills:
            bill = doc.to_dict()
            created = bill.get('createdAt')
            if created and hasattr(created, 'replace'):
                if created.tzinfo is None:
                    created = created.replace(tzinfo=timezone.utc)
                if created >= month_start:
                    total_this_month += 1
            
            status = bill.get('status', '')
            if status == 'Passed':
                passed += 1
            elif status == 'Failed':
                failed += 1
            elif status == 'Bill is Now Law':
                enacted += 1
            elif status == 'Voting':
                voting += 1
            elif status == 'Awaiting Sponsor':
                awaiting += 1
        
        embed = discord.Embed(
            title="Royal Council Statistics",
            description=f"Legislative activity for {now.strftime('%B %Y')}",
            color=0xc9a227
        )
        
        embed.add_field(name="Bills This Month", value=str(total_this_month), inline=True)
        embed.add_field(name="Currently Voting", value=str(voting), inline=True)
        embed.add_field(name="Awaiting Sponsor", value=str(awaiting), inline=True)
        embed.add_field(name="Passed", value=str(passed), inline=True)
        embed.add_field(name="Failed", value=str(failed), inline=True)
        embed.add_field(name="Enacted as Law", value=str(enacted), inline=True)
        
        decided = passed + failed
        if decided > 0:
            pass_rate = round((passed / decided) * 100)
            embed.add_field(name="Pass Rate", value=f"{pass_rate}%", inline=True)
        
        embed.set_footer(text=f"Data as of {now.strftime('%B %d, %Y')}")
        
        await interaction.followup.send(embed=embed)
    
    except Exception as e:
        print(f"[ERR] council_stats error: {e}")
        await interaction.followup.send("‚ùå Failed to retrieve statistics.")


# ========== PERSONAL VOTING HISTORY COMMAND ==========
@bot.tree.command(name="my_votes", description="View your personal voting history")
async def my_votes_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    current_db = await ensure_firestore()
    if not current_db:
        return await interaction.followup.send("‚ùå Database not available.")
    
    try:
        uid = interaction.user.id
        
        all_bills = await asyncio.to_thread(
            lambda: list(current_db.collection(BILL_COLLECTION_NAME).stream())
        )
        
        yes_votes = []
        no_votes = []
        abstain_votes = []
        
        for doc in all_bills:
            bill = doc.to_dict()
            votes = bill.get('votes', {'yes': [], 'no': [], 'abstain': []})
            bill_title = bill.get('title', 'Untitled')[:50]
            bill_id = bill.get('id', 'UNKNOWN')
            status = bill.get('status', 'Unknown')
            
            entry = f"**{bill_title}** (\`{bill_id}\`) - {status}"
            
            if uid in votes.get('yes', []):
                yes_votes.append(entry)
            elif uid in votes.get('no', []):
                no_votes.append(entry)
            elif uid in votes.get('abstain', []):
                abstain_votes.append(entry)
        
        total_votes = len(yes_votes) + len(no_votes) + len(abstain_votes)
        
        if total_votes == 0:
            return await interaction.followup.send("You haven't voted on any bills yet.")
        
        embed = discord.Embed(
            title=f"{interaction.user.display_name}'s Voting History",
            description=f"Total votes cast: **{total_votes}**",
            color=0x4ade80
        )
        
        if yes_votes:
            yes_text = "\n".join(yes_votes[:5])
            if len(yes_votes) > 5:
                yes_text += f"\n*...and {len(yes_votes) - 5} more*"
            embed.add_field(name=f"Si ({len(yes_votes)})", value=yes_text, inline=False)
        
        if no_votes:
            no_text = "\n".join(no_votes[:5])
            if len(no_votes) > 5:
                no_text += f"\n*...and {len(no_votes) - 5} more*"
            embed.add_field(name=f"No ({len(no_votes)})", value=no_text, inline=False)
        
        if abstain_votes:
            abstain_text = "\n".join(abstain_votes[:5])
            if len(abstain_votes) > 5:
                abstain_text += f"\n*...and {len(abstain_votes) - 5} more*"
            embed.add_field(name=f"Abstencion ({len(abstain_votes)})", value=abstain_text, inline=False)
        
        await interaction.followup.send(embed=embed)
    
    except Exception as e:
        print(f"[ERR] my_votes error: {e}")
        await interaction.followup.send("‚ùå Failed to retrieve voting history.")



@bot.tree.command(name="switch_citizenship", description="Switch between Primary and Secondary citizenship")
async def switch_citizenship(interaction: discord.Interaction):
    # Respond immediately
    await interaction.response.send_message("‚è≥ Checking your citizenship status...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Check if user is a citizen
    if not is_citizen(interaction.user.id):
        return await interaction.edit_original_response(content=
            "‚ùå **Not a Citizen**\n\n"
            "You must be a registered citizen to switch citizenship types.\n"
            "Use the citizen registration panel to register first!"
        )
    
    # Get current citizenship data
    try:
        citizen_query = db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', interaction.user.id)).limit(1).stream()
        citizen_doc = None
        citizen_data = None
        
        for doc in citizen_query:
            citizen_doc = doc
            citizen_data = doc.to_dict()
            break
        
        if not citizen_data:
            return await interaction.edit_original_response(content="‚ùå Could not find your citizenship record.")
        
        current_type = citizen_data.get('citizenshipType', 'primary')
        current_ign = citizen_data.get('ign', 'unknown')
        
        # Determine new type
        if current_type == 'primary':
            new_type = 'secondary'
            new_label = 'Secondary (Dual Citizenship)'
            current_label = 'Primary'
        else:
            new_type = 'primary'
            new_label = 'Primary'
            current_label = 'Secondary (Dual Citizenship)'
        
        # Create confirmation view
        class SwitchCitizenshipView(ui.View):
            def __init__(self):
                super().__init__(timeout=180)
            
            @ui.button(label=f"‚úÖ Switch to {new_label}", style=discord.ButtonStyle.success)
            async def confirm_button(self, btn_interaction: discord.Interaction, button: ui.Button):
                if btn_interaction.user.id != interaction.user.id:
                    return await btn_interaction.response.send_message("‚ùå This is not your citizenship switch.", ephemeral=True)
                
                await btn_interaction.response.send_message("‚è≥ Processing citizenship switch...", ephemeral=True)
                
                try:
                    # Update database
                    await asyncio.to_thread(lambda: citizen_doc.reference.update({
                        'citizenshipType': new_type,
                        'lastUpdated': datetime.now(timezone.utc)
                    }))
                    print(f"[OK] Citizenship switched for {btn_interaction.user} ({current_ign}): {current_type} ‚Üí {new_type}")
                    
                    # Update Discord roles
                    if btn_interaction.guild and isinstance(btn_interaction.user, discord.Member):
                        dual_role = btn_interaction.guild.get_role(SECONDARY_CITIZEN_ROLE_ID) if SECONDARY_CITIZEN_ROLE_ID else None
                        
                        if dual_role:
                            try:
                                if new_type == 'secondary':
                                    # Switching TO secondary - add dual citizenship role
                                    await btn_interaction.user.add_roles(dual_role, reason=f"Switched to {new_type} citizenship")
                                    print(f"[OK] Added {dual_role.name} role to {btn_interaction.user}")
                                else:
                                    # Switching TO primary - remove dual citizenship role
                                    await btn_interaction.user.remove_roles(dual_role, reason=f"Switched to {new_type} citizenship")
                                    print(f"[OK] Removed {dual_role.name} role from {btn_interaction.user}")
                                
                                role_status = f"\nüéñÔ∏è Discord roles updated!"
                            except discord.Forbidden:
                                role_status = f"\n‚ö†Ô∏è Role update failed: Bot lacks permission. Contact an admin."
                                print(f"[ERR] Failed to update roles for {btn_interaction.user} - Permission denied")
                            except Exception as e:
                                role_status = f"\n‚ö†Ô∏è Role update failed: {str(e)}"
                                print(f"[ERR] Failed to update roles for {btn_interaction.user}: {e}")
                        else:
                            role_status = f"\n‚ö†Ô∏è Secondary citizenship role not configured."
                    else:
                        role_status = ""
                    
                    await btn_interaction.edit_original_response(content=
                        f"‚úÖ **Citizenship Type Changed!**\n\n"
                        f"**IGN:** {current_ign}\n"
                        f"**Previous:** {current_label}\n"
                        f"**New:** {new_label}{role_status}\n\n"
                        f"Your citizenship has been successfully updated!"
                    )
                    
                    # Disable buttons
                    self.stop()
                    
                except Exception as e:
                    print(f"[ERR] Citizenship switch failed for {btn_interaction.user}: {e}")
                    await btn_interaction.edit_original_response(content=
                        f"‚ùå **Switch Failed**\n\n"
                        f"Database error occurred: {str(e)}\n"
                        f"Please contact an administrator."
                    )
            
            @ui.button(label="‚ùå Cancel", style=discord.ButtonStyle.danger)
            async def cancel_button(self, btn_interaction: discord.Interaction, button: ui.Button):
                if btn_interaction.user.id != interaction.user.id:
                    return await btn_interaction.response.send_message("‚ùå This is not your citizenship switch.", ephemeral=True)
                
                await btn_interaction.response.send_message("‚ùå Citizenship switch cancelled.", ephemeral=True)
                self.stop()
        
        # Show confirmation
        embed = discord.Embed(
            title="üîÑ Switch Citizenship Type",
            description=(
                f"**Current Status:**\n"
                f"üë§ IGN: `{current_ign}`\n"
                f"üèõÔ∏è Citizenship: **{current_label}**\n\n"
                f"**You are about to switch to:**\n"
                f"‚û°Ô∏è **{new_label}**\n\n"
                f"**What this means:**\n"
                f"{'‚Ä¢ You will be marked as having dual citizenship with another nation' if new_type == 'secondary' else '‚Ä¢ Florab√≠s will be your sole nation (no dual citizenship)'}\n"
                f"{'‚Ä¢ You will receive the secondary/dual citizen role' if new_type == 'secondary' else '‚Ä¢ Your secondary/dual citizen role will be removed'}\n\n"
                f"Are you sure you want to switch?"
            ),
            color=discord.Color.blue()
        )
        embed.set_footer(text="You can switch back at any time using this command again")
        
        await interaction.edit_original_response(content=None, embed=embed, view=SwitchCitizenshipView())
        
    except Exception as e:
        print(f"[ERR] Switch citizenship failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

# ========================================
# LAWYER REGISTRATION SYSTEM
# ========================================

def is_lawyer(user_id: int) -> bool:
    """Check if user is registered as a lawyer"""
    if not db:
        return False
    try:
        q = db.collection(LAWYERS_COLLECTION).where(filter=FieldFilter('discordId', '==', user_id)).limit(1)
        return len(list(q.stream())) > 0
    except:
        return False

def get_lawyer_data(user_id: int):
    """Get lawyer data for a user"""
    if not db:
        return None
    try:
        q = db.collection(LAWYERS_COLLECTION).where(filter=FieldFilter('discordId', '==', user_id)).limit(1)
        for doc in q.stream():
            data = doc.to_dict()
            data['id'] = doc.id
            return data
        return None
    except:
        return None

class LawyerTypeSelect(ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(
                label="Attorney",
                description="General practice lawyer (defense, civil)",
                emoji="‚öñÔ∏è",
                value="attorney"
            ),
            discord.SelectOption(
                label="Public Defender",
                description="Free defense for those who need it",
                emoji="üõ°Ô∏è",
                value="public_defender"
            ),
            discord.SelectOption(
                label="State Prosecutor",
                description="Prosecute criminal cases for the state",
                emoji="üéØ",
                value="prosecutor"
            )
        ]
        super().__init__(
            placeholder="Select your lawyer type...",
            options=options,
            custom_id="lawyer_type_select"
        )
    
    async def callback(self, interaction: discord.Interaction):
        lawyer_type = self.values[0]
        user_lang = get_user_language(interaction)
        modal = LawyerRegistrationModal(lawyer_type, lang=user_lang)
        await interaction.response.send_modal(modal)

class LawyerRegistrationModal(ui.Modal):
    def __init__(self, lawyer_type: str, lang: str = "en"):
        # Get translations for this language with safe cascading fallback
        tr = get_translation_dict(lang)
        
        # Set modal title with translation
        super().__init__(title=tr.get('registered_lawyer', 'Lawyer Registration'))
        
        self.lawyer_type = lawyer_type
        
        # Create translated text inputs
        self.ign_input = ui.TextInput(
            label=tr.get('your_ign', 'Your IGN'),
            placeholder=tr.get('ign_placeholder', 'Enter your in-game name'),
            required=True,
            max_length=16,
            style=discord.TextStyle.short
        )
        
        self.bar_number = ui.TextInput(
            label=tr.get('bar_number', 'Bar Number') + " (Optional)",
            placeholder="Leave blank for auto-generated",
            required=False,
            max_length=20,
            style=discord.TextStyle.short
        )
        
        # Add fields to modal
        self.add_item(self.ign_input)
        self.add_item(self.bar_number)
    
    async def on_submit(self, interaction: discord.Interaction):
        # RESPOND IMMEDIATELY to avoid timeout
        await interaction.response.send_message("‚öñÔ∏è Registering lawyer...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        ign = self.ign_input.value.strip()
        
        # Check if already registered as lawyer
        if is_lawyer(interaction.user.id):
            return await interaction.edit_original_response(content="‚ùå You are already registered as a lawyer!")
        
        # Generate bar number if not provided
        bar_number = self.bar_number.value.strip() if self.bar_number.value else f"FL-{interaction.user.id % 100000}"
        
        # Create lawyer record
        lawyer_ref = db.collection(LAWYERS_COLLECTION).document()
        lawyer_data = {
            'discordId': interaction.user.id,
            'discordName': str(interaction.user),
            'ign': ign,
            'lawyerType': self.lawyer_type,
            'barNumber': bar_number,
            'registeredAt': datetime.now(timezone.utc),
            'wins': 0,
            'losses': 0,
            'activeCases': [],
            'totalCases': 0,
            'jurisdiction': 'STATE',
            'status': 'active'
        }
        lawyer_ref.set(lawyer_data)
        
        # Auto-assign Discord role based on lawyer type
        role_assigned = False
        role_name = ""
        role_error = ""
        if interaction.guild:
            role_id = None
            if self.lawyer_type == 'attorney' and ATTORNEY_ROLE_ID:
                role_id = ATTORNEY_ROLE_ID
                role_name = "Attorney"
            elif self.lawyer_type == 'public_defender' and PUBLIC_DEFENDER_ROLE_ID:
                role_id = PUBLIC_DEFENDER_ROLE_ID
                role_name = "Public Defender"
            elif self.lawyer_type == 'prosecutor' and STATE_PROSECUTOR_ROLE_ID:
                role_id = STATE_PROSECUTOR_ROLE_ID
                role_name = "State Prosecutor"
            
            if role_id:
                print(f"[DEBUG] Attempting to assign role ID {role_id} ({role_name}) to {interaction.user}")
                role = interaction.guild.get_role(role_id)
                if role:
                    try:
                        member = interaction.guild.get_member(interaction.user.id)
                        if member:
                            await member.add_roles(role)
                            role_assigned = True
                            print(f"[OK] Successfully assigned {role_name} role to {interaction.user}")
                        else:
                            role_error = f"Member {interaction.user.id} not found in guild"
                            print(f"[ERR] Lawyer role assignment failed: {role_error}")
                    except discord.Forbidden:
                        role_error = "Bot lacks permission to assign roles"
                        print(f"[ERR] Could not assign {role_name} role: {role_error}")
                    except Exception as e:
                        role_error = str(e)
                        print(f"[ERR] Could not assign {role_name} role: {e}")
                else:
                    role_error = f"Role ID {role_id} does not exist in server"
                    print(f"[ERR] Lawyer role assignment failed: {role_error}")
            else:
                role_error = f"No role ID configured for {self.lawyer_type}"
                print(f"[ERR] Lawyer role assignment failed: {role_error}")
        
        # Get type name for display
        type_names = {
            'attorney': '‚öñÔ∏è Attorney',
            'public_defender': 'üõ°Ô∏è Public Defender',
            'prosecutor': 'üéØ State Prosecutor'
        }
        type_display = type_names.get(self.lawyer_type, self.lawyer_type)
        
        # Build role status message
        if role_assigned:
            role_status = f"\n**Discord Role:** {role_name} assigned ‚úÖ"
        elif role_error:
            role_status = f"\n**Discord Role:** ‚ö†Ô∏è Could not assign role ({role_error})"
        else:
            role_status = ""
        
        # Get user's language for success message with safe cascading fallback
        user_lang = get_user_language(interaction)
        tr = get_translation_dict(user_lang)
        
        embed = discord.Embed(
            title=tr.get('registered_lawyer', '‚úÖ Registered as Legal Counsel'),
            description=(
                f"**{tr.get('type', 'Type')}:** {type_display}\n"
                f"**{tr.get('your_ign', 'IGN')}:** {ign}\n"
                f"**{tr.get('bar_number', 'Bar Number')}:** {bar_number}{role_status}\n\n"
                f"You can now represent clients in court!"
            ),
            color=discord.Color.green()
        )
        await interaction.edit_original_response(content=None, embed=embed)
        
        print(f"[OK] Lawyer registered: {interaction.user} as {self.lawyer_type}")

class LawyerRegistrationButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Register as Lawyer",
            style=discord.ButtonStyle.primary,
            emoji="‚öñÔ∏è",
            custom_id="lawyer_registration_button"
        )
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True, thinking=True)
        
        user_lang = get_user_language(interaction)
        tr = get_translation_dict(user_lang)
        
        already_lawyer = await asyncio.to_thread(is_lawyer, interaction.user.id)
        if already_lawyer:
            return await interaction.followup.send(
                tr.get('already_lawyer', '‚ùå You are already registered as a lawyer!'),
                ephemeral=True
            )
        
        view = ui.View()
        view.add_item(LawyerTypeSelect())
        await interaction.followup.send(
            f"**{tr.get('lawyer_type', 'Lawyer Type')}:**",
            view=view,
            ephemeral=True)

# LawyerPanel removed - now integrated into CourtPanel

@bot.tree.command(name="my_lawyer_profile", description="View your lawyer profile and statistics")
async def my_lawyer_profile(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    # Wrap Firestore call in asyncio.to_thread to prevent [Errno 5]
    lawyer_data = await asyncio.to_thread(get_lawyer_data, interaction.user.id)
    
    if not lawyer_data:
        return await interaction.followup.send(
            "‚ùå You are not registered as a lawyer. Use `/lawyer_panel` to register!",
            ephemeral=True
        )
    
    # Calculate win rate
    total_cases = lawyer_data.get('totalCases', 0)
    wins = lawyer_data.get('wins', 0)
    losses = lawyer_data.get('losses', 0)
    win_rate = (wins / total_cases * 100) if total_cases > 0 else 0
    
    # Get type display
    type_names = {
        'attorney': '‚öñÔ∏è Attorney',
        'public_defender': 'üõ°Ô∏è Public Defender',
        'prosecutor': 'üéØ State Prosecutor'
    }
    type_display = type_names.get(lawyer_data.get('lawyerType', ''), lawyer_data.get('lawyerType', ''))
    
    # Format registration date
    reg_date = lawyer_data.get('registeredAt')
    if reg_date:
        reg_est = reg_date.astimezone(EST)
        reg_str = reg_est.strftime('%b %d, %Y at %I:%M %p EST')
    else:
        reg_str = "Unknown"
    
    embed = discord.Embed(
        title=f"‚öñÔ∏è Lawyer Profile: {interaction.user.display_name}",
        description=(
            f"**Type:** {type_display}\n"
            f"**IGN:** {lawyer_data.get('ign', 'N/A')}\n"
            f"**Bar Number:** {lawyer_data.get('barNumber', 'N/A')}\n"
            f"**Registered:** {reg_str}\n\n"
            f"**Case Statistics:**\n"
            f"üìä Total Cases: {total_cases}\n"
            f"‚úÖ Wins: {wins}\n"
            f"‚ùå Losses: {losses}\n"
            f"üìà Win Rate: {win_rate:.1f}%\n\n"
            f"**Active Cases:** {len(lawyer_data.get('activeCases', []))}"
        ),
        color=discord.Color.from_str("#008b8b")
    )
    
    await interaction.followup.send(embed=embed, ephemeral=True)

# ========================================
# WARRANT/BOUNTY SYSTEM
# ========================================

@warrant_group.command(name="add", description="‚öîÔ∏è Issue a new warrant (authorized roles only)")
@app_commands.describe(
    ign="Minecraft IGN",
    charge="Charge/reason for warrant",
    jurisdiction="Jurisdiction level (defaults to STATE)",
    reward_amount="Bounty reward amount (optional)",
    reward_commodity="Bounty reward commodity (optional)"
)
@app_commands.choices(reward_commodity=[
    app_commands.Choice(name="Diamonds", value="d"),
    app_commands.Choice(name="Essence", value="es"),
    app_commands.Choice(name="Iron", value="i"),
    app_commands.Choice(name="Gold", value="gld"),
    app_commands.Choice(name="Emerald", value="em"),
    app_commands.Choice(name="Iron Block", value="iblk"),
    app_commands.Choice(name="Gold Block", value="gblk"),
    app_commands.Choice(name="Emerald Block", value="eblk")
])
@app_commands.choices(jurisdiction=[
    app_commands.Choice(name="State (Florab√≠s)", value="STATE"),
    app_commands.Choice(name="Federal (Imperial Federation)", value="FEDERAL")
])
async def warrant_add_cmd(interaction: discord.Interaction, ign: str, charge: str, jurisdiction: str = "STATE", reward_amount: int = None, reward_commodity: str = None):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    # Check database availability
    if not db:
        await interaction.edit_original_response(content="‚ùå Database not available. Please try again later.")
        return
    
    # Check warrant role permission
    if not has_warrant_role(interaction):
        await interaction.edit_original_response(content="‚ùå Only authorized roles can issue warrants.\n\n**Required roles:** Admin, Judge, Soberante, or Warrant Manager")
        return
    
    try:
        # Build reward text with emojis
        if reward_amount and reward_commodity:
            # Map commodity codes to emojis
            commodity_emojis = {
                'd': DIAMOND_EMOJI,
                'es': ESSENCE_EMOJI,
                'i': IRON_EMOJI,
                'gld': GOLD_EMOJI,
                'em': EMERALD_EMOJI,
                'iblk': IRON_BLOCK_EMOJI,
                'gblk': GOLD_BLOCK_EMOJI,
                'eblk': EMERALD_BLOCK_EMOJI
            }
            emoji = commodity_emojis.get(reward_commodity, "")
            reward = f"{emoji} {reward_amount}{reward_commodity}"
        else:
            reward = "No bounty"
        
        # Create warrant
        warrant_ref = db.collection(WARRANTS_COLLECTION).document()
        warrant_data = {
            'ign': ign,
            'charge': charge,
            'reward': reward,
            'rewardAmount': reward_amount,
            'rewardCommodity': reward_commodity,
            'issuedAt': datetime.now(timezone.utc),
            'issuedBy': str(interaction.user),
            'issuedById': interaction.user.id,
            'jurisdiction': jurisdiction,
            'status': 'active'
        }
        warrant_ref.set(warrant_data)
        print(f"[OK] Warrant issued for {ign} by {interaction.user}")
        
        jurisdiction_label = "üèõÔ∏è State (Florab√≠s)" if jurisdiction == "STATE" else "üåê Federal (Imperial Federation)"
        await interaction.edit_original_response(content=f"‚úÖ Warrant issued for **{ign}**\n\n**Jurisdiction:** {jurisdiction_label}\n**Charge:** {charge}\n**Reward:** {reward}\n\nüí° Refresh the warrant panel to see the update.")
    
    except Exception as e:
        print(f"[ERR] Failed to issue warrant: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to issue warrant. Error: {str(e)}\n\nPlease contact an administrator.")

@warrant_group.command(name="remove", description="üóëÔ∏è Remove a warrant (authorized roles only)")
@app_commands.describe(ign="Minecraft IGN to remove from POS list")
async def warrant_remove_cmd(interaction: discord.Interaction, ign: str):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    # Check warrant role permission
    if not has_warrant_role(interaction):
        await interaction.edit_original_response(content="‚ùå Only authorized roles can remove warrants.")
        return
    
    try:
        # Ensure Firestore client is healthy before querying
        current_db = await ensure_firestore()
        
        # Find and update warrant status with defensive logging
        q = current_db.collection(WARRANTS_COLLECTION).where(filter=FieldFilter('ign', '==', ign)).where(filter=FieldFilter('status', '==', 'active')).limit(1)
        removed = False
        warrant_data = None
        removed_doc_id = None
        
        for doc in q.stream():
            warrant_data = doc.to_dict()
            removed_doc_id = doc.id
            await asyncio.to_thread(lambda d=doc: d.reference.update({'status': 'removed', 'removedAt': datetime.now(timezone.utc), 'removedBy': str(interaction.user)}))
            removed = True
            print(f"[WARRANT] Removed warrant {removed_doc_id} for {ign} by {interaction.user}")
            break
        
        if removed:
            await interaction.edit_original_response(content=f"‚úÖ Warrant for **{ign}** has been removed.\n\nüí° Refresh the warrant panel to see the update.")
        else:
            await interaction.edit_original_response(content=f"‚ùå No active warrant found for **{ign}**.")
    except Exception as e:
        print(f"[ERR] Failed to remove warrant: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to remove warrant. Error: {str(e)}")

# Warrant Panel View
class WarrantPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(RefreshWarrantsButton())

class RefreshWarrantsButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Warrants", style=discord.ButtonStyle.primary, custom_id="refresh_warrants")
    
    async def callback(self, interaction: discord.Interaction):
        # CRITICAL: Defer IMMEDIATELY before ANY checks to prevent timeout
        await interaction.response.defer(ephemeral=True)
        
        if not db:
            return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Get all active pearls ONCE (batch query is faster than individual queries)
            pearled_igns = set()
            for db_attempt in range(3):
                try:
                    # Ensure Firestore client is healthy before querying
                    current_db = await ensure_firestore()
                    # CRITICAL: Wrap blocking .stream() call in asyncio.to_thread()
                    pearl_docs = await asyncio.to_thread(
                        lambda: list(current_db.collection(PEARLS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
                    )
                    for pearl_doc in pearl_docs:
                        pearled_igns.add(pearl_doc.to_dict().get('ign'))
                    break
                except Exception as e:
                    print(f"[WARN] Warrant refresh: Failed to fetch pearled players (attempt {db_attempt + 1}/3): {e}")
                    if db_attempt < 2:
                        await asyncio.sleep(0.5)
            
            # Get all active warrants
            warrants = []
            for db_attempt in range(3):
                try:
                    # Ensure Firestore client is healthy before querying
                    current_db = await ensure_firestore()
                    # CRITICAL: Wrap blocking .stream() call in asyncio.to_thread()
                    warrant_docs = await asyncio.to_thread(
                        lambda: list(current_db.collection(WARRANTS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
                    )
                    for doc in warrant_docs:
                        data = doc.to_dict()
                        issued_at = data.get('issuedAt')
                        if isinstance(issued_at, datetime):
                            issued_date = issued_at.astimezone(EST).strftime('%b %d, %Y')
                        else:
                            issued_date = 'Unknown'
                        charge = data.get('charge') or data.get('reason', 'No charge')
                        ign = data.get('ign')
                        
                        # Check if this person is pearled (fast lookup in set)
                        pearl_indicator = f" {PEARL_EMOJI} **PEARLED**" if ign in pearled_igns else ""
                        
                        warrants.append(f"**{ign}** - {charge} - *{issued_date}*{pearl_indicator}")
                    break
                except Exception as e:
                    print(f"[WARN] Warrant refresh: Failed to fetch warrants (attempt {db_attempt + 1}/3): {e}")
                    if db_attempt < 2:
                        await asyncio.sleep(0.5)
            
            # Build embed
            if warrants:
                description = "\n".join(warrants)
                # Discord embed description limit is 4096 characters (use 3500 for safety)
                if len(description) > 3500:
                    description = description[:3500] + "\n\n*...List truncated. Use `/warrant list` to see all.*"
            else:
                description = "‚úÖ No active warrants at this time."
            
            embed = discord.Embed(
                title=f"üö® ACTIVE WARRANTS ({len(warrants)})",
                description=description,
                color=discord.Color.red() if warrants else discord.Color.green()
            )
            embed.set_footer(text="Pearl on Sight (POS) List ‚Ä¢ Updated")
            
            # Update the panel message with HTTP recreation on I/O errors
            edit_success = False
            last_error = None
            for attempt in range(12):
                try:
                    await asyncio.sleep(0.3)  # Small stability delay
                    if attempt > 0:
                        await asyncio.sleep(1.0)  # Recovery delay
                    
                    await interaction.message.edit(embed=embed, view=WarrantPanel())
                    edit_success = True
                    if attempt > 0:
                        print(f"[OK] Warrant refresh succeeded after {attempt + 1} attempts")
                    break
                except (OSError, aiohttp.ClientOSError, aiohttp.ClientPayloadError) as io_err:
                    last_error = io_err
                    print(f"[WARN] Warrant refresh I/O error (attempt {attempt + 1}/12): {io_err}")
                    print(f"[INFO] Recreating HTTP session...")
                    try:
                        pass  # Discord.py handles reconnections automatically
                        print(f"[OK] HTTP session recreated")
                    except Exception as recreate_err:
                        print(f"[WARN] HTTP recreate failed: {recreate_err}")
                    
                    if attempt < 11:
                        wait = min(3 * (attempt + 1), 30)
                        print(f"[INFO] Waiting {wait}s before retry...")
                        await asyncio.sleep(wait)
                except Exception as other_err:
                    last_error = other_err
                    print(f"[WARN] Warrant refresh error (attempt {attempt + 1}/12): {other_err}")
                    if attempt < 11:
                        await asyncio.sleep(min(3 * (attempt + 1), 30))
            
            if edit_success:
                # Success! Show confirmation using followup (safer than editing deferred response)
                confirmation_msg = await interaction.followup.send(content="‚úÖ Warrant panel refreshed!", ephemeral=True)
                await asyncio.sleep(2)
                try:
                    await confirmation_msg.delete()
                except:
                    pass  # Message might already be gone
            else:
                error_msg = str(last_error) if last_error else "Unknown error"
                print(f"[ERR] Warrant refresh failed after 12 attempts: {error_msg}")
                await interaction.followup.send(content=f"‚ùå Failed to refresh after 12 attempts:\n{error_msg}", ephemeral=True)
            
        except Exception as e:
            print(f"[ERR] Refresh warrants failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

@warrant_group.command(name="post_panel", description="üìã Post public warrant panel (Admin only)")
async def warrant_post_panel_cmd(interaction: discord.Interaction):
    """Post warrant panel in foreground with full error logging for debugging"""
    # CRITICAL: DEFER FIRST (before 3-second timeout)
    await interaction.response.defer(ephemeral=True)
    
    # Check permissions AFTER deferring
    if not interaction.user.guild_permissions.administrator:
        return await interaction.followup.send("‚ùå Only administrators can post the warrant panel.", ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    try:
        print(f"[WARRANT-PANEL] Starting foreground panel creation...")
        # BUILD PANEL IN FOREGROUND WITH FULL ERROR LOGGING
        await bot.process_warrant_panel_job({}, interaction.guild, interaction.channel)
        await interaction.followup.send("‚úÖ Warrant panel posted successfully!", ephemeral=True)
        print(f"[WARRANT-PANEL] ‚úÖ Panel created successfully")
    except Exception as e:
        print(f"[WARRANT-PANEL] ‚ùå ERROR creating panel:")
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Failed to create panel:\n```{str(e)}```", ephemeral=True)
        
@bot.event
async def on_member_remove(member):
    """Automatically remove citizen when they leave the server"""
    if not db:
        return
    
    try:
        # Check if member is a citizen
        q = db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', member.id)).limit(1)
        for doc in q.stream():
            citizen_data = doc.to_dict()
            ign = citizen_data.get('ign', 'Unknown')
            citizenship_type = citizen_data.get('citizenshipType', 'primary')
            
            # Remove from database
            doc.reference.delete()
            print(f"[OK] Auto-removed citizen {member} ({ign}) - left server ({citizenship_type} citizenship)")
            break
    except Exception as e:
        print(f"[ERR] Failed to auto-remove citizen {member}: {e}")

@bot.event
async def on_message(message):
    """Automatically parse snitch logs from messages OR file uploads in the snitch channel"""
    # Only process messages in the snitch log channel
    if message.channel.id != SNITCH_LOG_CHANNEL_ID:
        return
    
    # Skip our own bot messages to avoid loops
    if message.author.id == bot.user.id:
        return
    
    if not db:
        print("[WARN] Cannot parse snitch logs - database not available")
        return
    
    # Parse BOTH message content AND file attachments
    content_to_parse = []
    source_type = None
    source_name = None
    
    # Check for file attachments first
    if message.attachments:
        print(f"[SNITCH] Processing {len(message.attachments)} file(s) from {message.author}...")
        for attachment in message.attachments:
            if attachment.filename.endswith(('.txt', '.log')):
                try:
                    file_bytes = await attachment.read()
                    file_content = file_bytes.decode('utf-8')
                    content_to_parse.append(file_content)
                    source_type = 'file_upload'
                    source_name = attachment.filename
                    print(f"[SNITCH] Parsing file: {attachment.filename}")
                except UnicodeDecodeError:
                    print(f"[SNITCH] ‚ö†Ô∏è Could not decode file: {attachment.filename}")
                    await message.add_reaction('‚ùå')
                    continue
    
    # Also check message content (for bot relay messages)
    if message.content and message.content.strip():
        content_to_parse.append(message.content)
        if not source_type:
            source_type = 'relay_message'
            source_name = f"Relay from {message.author}"
    
    # If nothing to parse, return
    if not content_to_parse:
        return
    
    # Parse all content
    for file_content in content_to_parse:
            
            # Parse snitch log entries
            # Format: "PlayerName entered snitch at SnitchName [world X,Y,Z]"
            # Minecraft IGNs: 3-16 chars, alphanumeric + underscore (no hyphens in modern MC)
            import re
            
            lines_parsed = 0
            entries_added = 0
            igns_found = set()
            
            for line in file_content.split('\n'):
                line = line.strip()
                if not line:
                    continue
                
                # Florab√≠s snitch log format with Discord markdown:
                # `[15:11:11]` `[Crown]` **Piksel2** is at Downstair Base Snitch (-3370,65,9258)
                # Also support plain text: [15:11:11] [Crown] Piksel2 is at Downstair Base Snitch (-3370,65,9258)
                # Pattern: Optional backticks, timestamp, group, player (with optional bold **), snitch name, coords
                match = re.match(
                    r'^`?\[[\d:]+\]`?\s+`?\[([^\]]+)\]`?\s+\*\*?([A-Za-z0-9_]{3,16})\*\*?\s+is at\s+(.+?)\s+\(([-\d]+),([-\d]+),([-\d]+)\)',
                    line
                )
                
                if match:
                    group = match.group(1)
                    ign = match.group(2)
                    snitch_name = match.group(3).strip()
                    x, y, z = match.group(4), match.group(5), match.group(6)
                    action = "is at"  # This format only shows "is at"
                    
                    igns_found.add(ign)
                    
                    try:
                        # Store full snitch log entry with details
                        await asyncio.to_thread(lambda: db.collection(SNITCH_LOGS_COLLECTION).add({
                            'player': ign,
                            'group': group,
                            'action': action,
                            'snitchName': snitch_name,
                            'coordinates': f"{x}, {y}, {z}",
                            'x': int(x),
                            'y': int(y),
                            'z': int(z),
                            'timestamp': datetime.now(timezone.utc),
                            'uploadedBy': str(message.author),
                            'uploadedById': message.author.id,
                            'type': source_type,
                            'sourceName': source_name,
                            'originalLine': line
                        }))
                        entries_added += 1
                        lines_parsed += 1
                    except Exception as e:
                        print(f"[SNITCH] ‚ö†Ô∏è Failed to add entry for {ign}: {e}")
                else:
                    # Try alternate formats or just log warning
                    if any(keyword in line.lower() for keyword in ['is at', 'entered', 'logged', 'broke', 'placed', 'killed', 'opened', 'used']):
                        print(f"[SNITCH] ‚ö†Ô∏è Could not parse line: {line[:80]}")
            
    # Only react/reply if we actually parsed entries
    if entries_added > 0:
        # Log all successful parses (silent for relay messages, visible for files)
        if source_type == 'file_upload':
            print(f"[SNITCH] ‚úÖ File upload processed: {entries_added} entries from {len(igns_found)} unique players")
            await message.add_reaction('‚úÖ')
            await message.reply(
                f"‚úÖ **Snitch log processed!**\n\n"
                f"üìÅ **File:** {source_name}\n"
                f"üìù **Entries added:** {entries_added}\n"
                f"üë• **Unique players:** {len(igns_found)}\n\n"
                f"These players can now register as citizens!",
                mention_author=False
            )
    else:
        # Only warn about files, not relay messages with no matches
        if source_type == 'file_upload':
            await message.add_reaction('‚ö†Ô∏è')
            await message.reply(
                f"‚ö†Ô∏è **Snitch log processed but no entries found!**\n\n"
                f"üìÅ **File:** {source_name}\n"
                f"‚ùå **Entries added:** 0\n\n"
                f"Please check the file format. Expected format:\n"
                f"`[15:11:11] [Crown] PlayerName is at SnitchName (-3370,65,9258)`",
                mention_author=False
            )

# ========================================
# COURT SYSTEM
# ========================================

# Helper function to send DM to lawyers when assigned to cases
async def notify_lawyer_assignment(lawyer_user_id: int, case_id: str, case_data: dict, role: str, bot_instance):
    """Send DM to lawyer when assigned to a case"""
    try:
        user = await bot_instance.fetch_user(lawyer_user_id)
        if user:
            role_emoji = {"prosecutor": "üéØ", "defense": "üõ°Ô∏è", "plaintiff": "‚öñÔ∏è", "defendant": "‚öñÔ∏è"}.get(role, "‚öñÔ∏è")
            case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
            
            dm_embed = discord.Embed(
                title=f"{role_emoji} You've been assigned to a case!",
                description=(
                    f"{case_type_emoji} **Case #{case_id}**\n\n"
                    f"**Type:** {case_data.get('caseType')}\n"
                    f"**Role:** {role.title()} Attorney\n"
                    f"**Defendant:** {case_data.get('defendantIgn')}\n"
                    f"**Charges:** {case_data.get('charges')}\n\n"
                    f"üìã Review the case details and prepare your arguments!"
                ),
                color=0x008b8b
            )
            now_est = datetime.now(timezone.utc).astimezone(EST)
            dm_embed.set_footer(text=f"Assigned {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
            
            await user.send(embed=dm_embed)
            print(f"[OK] Sent DM to lawyer {user} for case {case_id} ({role} role)")
    except discord.Forbidden:
        print(f"[WARN] Cannot DM lawyer {lawyer_user_id} - DMs disabled")
    except Exception as e:
        print(f"[WARN] Failed to DM lawyer {lawyer_user_id}: {e}")

# Appeal Modal for defendants to submit appeal
class FileAppealModal(ui.Modal, title="üì¢ File Appeal"):
    reason = ui.TextInput(
        label="Appeal Reason",
        placeholder="Why should this verdict be overturned?",
        style=discord.TextStyle.paragraph,
        required=True,
        max_length=1000
    )
    
    def __init__(self, case_id: str):
        super().__init__()
        self.case_id = case_id
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üì¢ Filing appeal...")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if already appealed
            if case_data.get('appealStatus'):
                return await interaction.edit_original_response(content="‚ùå This case has already been appealed.")
            
            # Check if within 7 day deadline
            sentenced_at = case_data.get('sentencedAt')
            if sentenced_at:
                from datetime import timedelta
                deadline = sentenced_at + timedelta(days=7)
                if datetime.now(timezone.utc) > deadline:
                    deadline_est = deadline.astimezone(EST)
                    return await interaction.edit_original_response(
                        content=f"‚ùå Appeal deadline has passed. Deadline was {deadline_est.strftime('%b %d, %Y at %I:%M %p EST')}"
                    )
            
            # File the appeal
            await asyncio.to_thread(lambda: case_ref.update({
                'appealStatus': 'pending',
                'appealReason': self.reason.value.strip(),
                'appealedBy': str(interaction.user),
                'appealedById': interaction.user.id,
                'appealedAt': datetime.now(timezone.utc)
            }))
            
            # Post appeal notification to court status channel
            if COURT_STATUS_CHANNEL_ID and interaction.guild:
                status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                if status_channel:
                    appeal_embed = discord.Embed(
                        title=f"üì¢ APPEAL FILED: Case #{self.case_id}",
                        description=(
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Original Verdict:** {case_data.get('verdict')}\n"
                            f"**Appeal Reason:** {self.reason.value.strip()}\n"
                            f"**Filed By:** {interaction.user.mention}"
                        ),
                        color=discord.Color.orange()
                    )
                    now_est = datetime.now(timezone.utc).astimezone(EST)
                    appeal_embed.set_footer(text=f"Filed {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                    await status_channel.send(embed=appeal_embed)
            
            await interaction.edit_original_response(content="‚úÖ Appeal filed successfully! The Appeals Court will review your case.")
        except Exception as e:
            print(f"[ERR] Failed to file appeal: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to file appeal. Please try again.")

# Appeal Button View on verdicts
class VerdictAppealView(ui.View):
    def __init__(self, case_id: str, defendant_discord_id: int):
        super().__init__(timeout=None)
        self.case_id = case_id
        self.defendant_discord_id = defendant_discord_id
        
        # Add appeal button
        appeal_btn = ui.Button(
            label="üì¢ File Appeal (7 days)", 
            style=discord.ButtonStyle.secondary, 
            custom_id=f"appeal_{case_id}"
        )
        appeal_btn.callback = self.file_appeal
        self.add_item(appeal_btn)
    
    async def file_appeal(self, interaction: discord.Interaction):
        # Check if user is the defendant
        if self.defendant_discord_id and interaction.user.id != self.defendant_discord_id:
            return await interaction.response.send_message(
                "‚ùå Only the defendant can appeal this verdict.")
        
        # Check if appeal deadline has passed
        if db:
            try:
                case_doc = db.collection(COURT_CASES_COLLECTION).document(self.case_id).get()
                if case_doc.exists:
                    case_data = case_doc.to_dict()
                    
                    # Check if already appealed
                    if case_data.get('appealStatus'):
                        return await interaction.response.send_message(
                            "‚ùå This case has already been appealed.")
                    
                    # Check 7-day deadline
                    sentenced_at = case_data.get('sentencedAt')
                    if sentenced_at:
                        from datetime import timedelta
                        deadline = sentenced_at + timedelta(days=7)
                        if datetime.now(timezone.utc) > deadline:
                            deadline_est = deadline.astimezone(EST)
                            return await interaction.response.send_message(
                                f"‚ùå Appeal deadline has passed. Deadline was {deadline_est.strftime('%b %d, %Y at %I:%M %p EST')}")
            except Exception as e:
                print(f"[ERR] Failed to check appeal eligibility: {e}")
        
        # Open appeal modal
        await interaction.response.send_modal(FileAppealModal(self.case_id))

# Judge Voting View for 3-judge panel
class JudgeVotingView(ui.View):
    def __init__(self, case_id: str, case_type: str = "Criminal"):
        super().__init__(timeout=None)
        self.case_id = case_id
        self.case_type = case_type
        
        if case_type == "Civil":
            # Civil case buttons
            plaintiff_btn = ui.Button(label="‚úÖ Plaintiff Prevails", style=discord.ButtonStyle.success, custom_id=f"judge_vote_plaintiff_{case_id}")
            plaintiff_btn.callback = self.vote_plaintiff
            self.add_item(plaintiff_btn)
            
            defendant_btn = ui.Button(label="‚ùå Defendant Prevails", style=discord.ButtonStyle.danger, custom_id=f"judge_vote_defendant_{case_id}")
            defendant_btn.callback = self.vote_defendant
            self.add_item(defendant_btn)
        else:
            # Criminal case buttons
            guilty_btn = ui.Button(label="üî¥ Vote Guilty", style=discord.ButtonStyle.danger, custom_id=f"judge_vote_guilty_{case_id}")
            guilty_btn.callback = self.vote_guilty
            self.add_item(guilty_btn)
            
            not_guilty_btn = ui.Button(label="üü¢ Vote Not Guilty", style=discord.ButtonStyle.success, custom_id=f"judge_vote_not_guilty_{case_id}")
            not_guilty_btn.callback = self.vote_not_guilty
            self.add_item(not_guilty_btn)
    
    async def vote_guilty(self, interaction: discord.Interaction):
        await self.cast_vote(interaction, "Guilty")
    
    async def vote_not_guilty(self, interaction: discord.Interaction):
        await self.cast_vote(interaction, "Not Guilty")
    
    async def vote_plaintiff(self, interaction: discord.Interaction):
        await self.cast_vote(interaction, "Plaintiff Prevails")
    
    async def vote_defendant(self, interaction: discord.Interaction):
        await self.cast_vote(interaction, "Defendant Prevails")
    
    async def cast_vote(self, interaction: discord.Interaction, verdict: str):
        # Check if user is a judge
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can vote on verdicts.")
        
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            judge_votes = case_data.get('judgeVotes', {})
            
            # Check if judge already voted
            if str(interaction.user.id) in judge_votes:
                return await interaction.edit_original_response(content="‚ùå You have already voted on this verdict.")
            
            # Add judge's vote
            judge_votes[str(interaction.user.id)] = {
                'judge': str(interaction.user),
                'verdict': verdict,
                'votedAt': datetime.now(timezone.utc)
            }
            
            vote_count = len(judge_votes)
            
            # Update case with new vote
            await asyncio.to_thread(lambda: case_ref.update({
                'judgeVotes': judge_votes,
                'voteCount': vote_count
            }))
            
            # Check if we have 3 votes (finalize verdict)
            if vote_count >= 3:
                case_type = case_data.get('caseType', 'Criminal')
                
                if case_type == "Civil":
                    # Civil case - count plaintiff/defendant votes
                    plaintiff_votes = sum(1 for v in judge_votes.values() if 'plaintiff' in v['verdict'].lower())
                    defendant_votes = sum(1 for v in judge_votes.values() if 'defendant' in v['verdict'].lower())
                    final_verdict = "Plaintiff Prevails" if plaintiff_votes > defendant_votes else "Defendant Prevails"
                    final_sentence = ""  # Civil cases have remedies, not sentences
                    guilty_votes = plaintiff_votes  # For display purposes
                    not_guilty_votes = defendant_votes
                else:
                    # Criminal case - count guilty/not guilty votes
                    guilty_votes = sum(1 for v in judge_votes.values() if v['verdict'].lower() == 'guilty')
                    not_guilty_votes = sum(1 for v in judge_votes.values() if v['verdict'].lower() == 'not guilty')
                    final_verdict = "Guilty" if guilty_votes > not_guilty_votes else "Not Guilty"
                    final_sentence = case_data.get('proposedSentence', '') if final_verdict == "Guilty" else ""
                
                # Finalize the verdict
                await asyncio.to_thread(lambda: case_ref.update({
                    'verdict': final_verdict,
                    'sentence': final_sentence,
                    'status': 'sentenced',
                    'sentencedAt': datetime.now(timezone.utc)
                }))
                
                # Update lawyer win/loss statistics
                # Guilty = Prosecutors win, Defense loses
                # Not Guilty = Defense wins, Prosecutors lose
                try:
                    # Merge both single ID (prosecutorId) and array (prosecutors) formats
                    prosecutors = list(case_data.get('prosecutors', []))
                    if case_data.get('prosecutorId') and case_data.get('prosecutorId') not in prosecutors:
                        prosecutors.append(case_data.get('prosecutorId'))
                    
                    defense_attorneys = list(case_data.get('defenseAttorneys', []))
                    if case_data.get('defenseAttorneyId') and case_data.get('defenseAttorneyId') not in defense_attorneys:
                        defense_attorneys.append(case_data.get('defenseAttorneyId'))
                    
                    if final_verdict == "Guilty":
                        # Prosecutors win
                        for prosecutor_id in prosecutors:
                            lawyer_docs = db.collection(LAWYERS_COLLECTION).where(
                                filter=FieldFilter('userId', '==', prosecutor_id)
                            ).limit(1).stream()
                            for lawyer_doc in lawyer_docs:
                                lawyer_ref = db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                                lawyer_data = lawyer_doc.to_dict()
                                await asyncio.to_thread(lambda lr=lawyer_ref, wd=lawyer_data: lr.update({
                                    'wins': wd.get('wins', 0) + 1
                                }))
                                print(f"[COURT] Updated prosecutor {prosecutor_id} wins (Guilty verdict)")
                        
                        # Defense loses
                        for defense_id in defense_attorneys:
                            lawyer_docs = db.collection(LAWYERS_COLLECTION).where(
                                filter=FieldFilter('userId', '==', defense_id)
                            ).limit(1).stream()
                            for lawyer_doc in lawyer_docs:
                                lawyer_ref = db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                                lawyer_data = lawyer_doc.to_dict()
                                await asyncio.to_thread(lambda lr=lawyer_ref, ld=lawyer_data: lr.update({
                                    'losses': ld.get('losses', 0) + 1
                                }))
                                print(f"[COURT] Updated defense {defense_id} losses (Guilty verdict)")
                    else:
                        # Not Guilty - Defense wins
                        for defense_id in defense_attorneys:
                            lawyer_docs = db.collection(LAWYERS_COLLECTION).where(
                                filter=FieldFilter('userId', '==', defense_id)
                            ).limit(1).stream()
                            for lawyer_doc in lawyer_docs:
                                lawyer_ref = db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                                lawyer_data = lawyer_doc.to_dict()
                                await asyncio.to_thread(lambda lr=lawyer_ref, wd=lawyer_data: lr.update({
                                    'wins': wd.get('wins', 0) + 1
                                }))
                                print(f"[COURT] Updated defense {defense_id} wins (Not Guilty verdict)")
                        
                        # Prosecutors lose
                        for prosecutor_id in prosecutors:
                            lawyer_docs = db.collection(LAWYERS_COLLECTION).where(
                                filter=FieldFilter('userId', '==', prosecutor_id)
                            ).limit(1).stream()
                            for lawyer_doc in lawyer_docs:
                                lawyer_ref = db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                                lawyer_data = lawyer_doc.to_dict()
                                await asyncio.to_thread(lambda lr=lawyer_ref, ld=lawyer_data: lr.update({
                                    'losses': ld.get('losses', 0) + 1
                                }))
                                print(f"[COURT] Updated prosecutor {prosecutor_id} losses (Not Guilty verdict)")
                except Exception as lawyer_err:
                    print(f"[WARN] Failed to update lawyer stats: {lawyer_err}")
                    # Don't fail the verdict if lawyer stats update fails
                
                # Post final verdict to court status channel
                if COURT_STATUS_CHANNEL_ID and interaction.guild:
                    status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                    if status_channel:
                        case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
                        verdict_color = discord.Color.red() if final_verdict == 'Guilty' else discord.Color.green()
                        
                        vote_summary = "\n".join([f"‚Ä¢ {v['judge']}: {v['verdict']}" for v in judge_votes.values()])
                        
                        final_embed = discord.Embed(
                            title=f"{case_type_emoji} FINAL VERDICT: Case #{self.case_id}",
                            description=(
                                f"**Defendant:** {case_data.get('defendantIgn')}\n"
                                f"**Charges:** {case_data.get('charges')}\n\n"
                                f"**Judge Panel Votes:**\n{vote_summary}\n\n"
                                f"**Final Verdict:** {final_verdict} ({guilty_votes}-{not_guilty_votes})\n" +
                                (f"**Sentence:** {final_sentence}\n" if final_sentence else "")
                            ),
                            color=verdict_color
                        )
                        now_est = datetime.now(timezone.utc).astimezone(EST)
                        final_embed.set_footer(text=f"Finalized {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                        await status_channel.send(embed=final_embed)
                
                # Note: Warrants should be issued BEFORE court cases via /warrant add
                # Verdicts only create pearl records, they do NOT create warrants
                
                # Post final verdict with appeal button
                case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
                verdict_color = discord.Color.red() if final_verdict == 'Guilty' else discord.Color.green()
                
                vote_summary = "\n".join([f"‚Ä¢ {v['judge']}: {v['verdict']}" for v in judge_votes.values()])
                
                final_verdict_embed = discord.Embed(
                    title=f"{case_type_emoji} VERDICT FINALIZED: Case #{self.case_id}",
                    description=(
                        f"**Defendant:** {case_data.get('defendantIgn')}\n"
                        f"**Charges:** {case_data.get('charges')}\n\n"
                        f"**Judge Panel Votes:**\n{vote_summary}\n\n"
                        f"**Final Verdict:** {final_verdict} ({guilty_votes}-{not_guilty_votes})\n" +
                        (f"**Sentence:** {final_sentence}\n" if final_sentence else "")
                    ),
                    color=verdict_color
                )
                now_est = datetime.now(timezone.utc).astimezone(EST)
                final_verdict_embed.set_footer(text=f"Finalized {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                
                # Create appeal view
                appeal_view = VerdictAppealView(self.case_id, case_data.get('defendantDiscordId'))
                await interaction.channel.send(embed=final_verdict_embed, view=appeal_view)
                
                # Disable voting buttons
                for item in self.children:
                    item.disabled = True
                await interaction.message.edit(view=self)
                
                await interaction.edit_original_response(content=f"‚úÖ Vote recorded! Verdict finalized: **{final_verdict}** ({guilty_votes}-{not_guilty_votes})")
            else:
                # Update voting panel with current votes
                vote_summary = "\n".join([f"‚úÖ {v['judge']}: {v['verdict']}" for v in judge_votes.values()])
                
                embed = interaction.message.embeds[0]
                embed.description = (
                    f"**Defendant:** {case_data.get('defendantIgn')}\n"
                    f"**Charges:** {case_data.get('charges')}\n\n"
                    f"**Proposed Verdict:** {case_data.get('proposedVerdict')}\n" +
                    (f"**Proposed Sentence:** {case_data.get('proposedSentence')}\n" if case_data.get('proposedSentence') else "") +
                    f"\n**Proposed By:** <@{case_data.get('proposedById')}>\n\n"
                    f"üìä **Judge Panel Votes:** {vote_count}/3\n{vote_summary}\n\n"
                    f"‚öñÔ∏è **{3 - vote_count} more judge{'s' if 3 - vote_count != 1 else ''} needed to finalize verdict**"
                )
                await interaction.message.edit(embed=embed)
                
                await interaction.edit_original_response(content=f"‚úÖ Vote recorded! {3 - vote_count} more vote{'s' if 3 - vote_count != 1 else ''} needed.")
        except Exception as e:
            print(f"[ERR] Failed to cast vote: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to record vote. Please try again.")

# Single Judge Verdict Modal (for normal cases)
class SingleJudgeVerdictModal(ui.Modal):
    def __init__(self, case_id: str, case_type: str = "Criminal"):
        super().__init__(title="üî® Issue Verdict")
        self.case_id = case_id
        self.case_type = case_type
        
        if case_type == "Civil":
            self.verdict = ui.TextInput(
                label="Verdict",
                placeholder="Plaintiff Prevails or Defendant Prevails",
                required=True,
                max_length=30
            )
            self.remedy = ui.TextInput(
                label="Remedy / Relief (if plaintiff prevails)",
                placeholder="e.g., Return of property, 64 diamonds compensation",
                style=discord.TextStyle.paragraph,
                required=False,
                max_length=500
            )
            self.liability = ui.TextInput(
                label="Liability Finding (Optional)",
                placeholder="Liable or Not Liable",
                required=False,
                max_length=20
            )
            self.add_item(self.verdict)
            self.add_item(self.remedy)
            self.add_item(self.liability)
        else:
            self.verdict = ui.TextInput(
                label="Verdict",
                placeholder="Guilty or Not Guilty",
                required=True,
                max_length=20
            )
            self.sentence = ui.TextInput(
                label="Sentence (if guilty)",
                placeholder="e.g., 7 days pearl, 64 diamonds compensation",
                style=discord.TextStyle.paragraph,
                required=False,
                max_length=500
            )
            self.pearl_duration = ui.TextInput(
                label="Pearl Duration (days) - if pearl sentence",
                placeholder="e.g., 7 (leave blank if no pearl)",
                required=False,
                max_length=5
            )
            self.vault_location = ui.TextInput(
                label="Vault Location - if pearl sentence",
                placeholder="e.g., -3398, 66, 9285 (leave blank if no pearl)",
                required=False,
                max_length=100
            )
            self.pearl_holder = ui.TextInput(
                label="Pearl Holder IGN - if pearl sentence",
                placeholder="e.g., PlayerName (leave blank if no pearl)",
                required=False,
                max_length=16
            )
            self.add_item(self.verdict)
            self.add_item(self.sentence)
            self.add_item(self.pearl_duration)
            self.add_item(self.vault_location)
            self.add_item(self.pearl_holder)
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üî® Issuing verdict...")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        verdict_text = self.verdict.value.strip()
        verdict_lower = verdict_text.lower()
        
        if self.case_type == "Civil":
            # Civil case validation
            if 'plaintiff' in verdict_lower:
                verdict_text = "Plaintiff Prevails"
            elif 'defendant' in verdict_lower:
                verdict_text = "Defendant Prevails"
            else:
                return await interaction.edit_original_response(content="‚ùå Verdict must be 'Plaintiff Prevails' or 'Defendant Prevails'")
            sentence_text = self.remedy.value.strip() if hasattr(self, 'remedy') and self.remedy.value else ""
            liability_text = self.liability.value.strip() if hasattr(self, 'liability') and self.liability.value else ""
        else:
            # Criminal case validation
            if verdict_lower not in ['guilty', 'not guilty']:
                return await interaction.edit_original_response(content="‚ùå Verdict must be 'Guilty' or 'Not Guilty'")
            sentence_text = self.sentence.value.strip() if hasattr(self, 'sentence') and self.sentence.value else ""
            liability_text = ""
        
        # Issue verdict directly (single judge)
        try:
            # Ensure Firestore client is healthy before issuing verdict
            current_db = await ensure_firestore()
            
            case_ref = current_db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Update verdict
            await asyncio.to_thread(lambda: case_ref.update({
                'verdict': verdict_text,
                'sentence': sentence_text,
                'status': 'sentenced',
                'sentencedAt': datetime.now(timezone.utc),
                'sentencedBy': str(interaction.user),
                'sentencedById': interaction.user.id
            }))
            
            # Update lawyer win/loss statistics
            # Guilty = Prosecutors win, Defense loses
            # Not Guilty = Defense wins, Prosecutors lose
            try:
                # Merge both single ID (prosecutorId) and array (prosecutors) formats
                prosecutors = list(case_data.get('prosecutors', []))
                if case_data.get('prosecutorId') and case_data.get('prosecutorId') not in prosecutors:
                    prosecutors.append(case_data.get('prosecutorId'))
                
                defense_attorneys = list(case_data.get('defenseAttorneys', []))
                if case_data.get('defenseAttorneyId') and case_data.get('defenseAttorneyId') not in defense_attorneys:
                    defense_attorneys.append(case_data.get('defenseAttorneyId'))
                
                if verdict_lower == "guilty":
                    # Prosecutors win
                    for prosecutor_id in prosecutors:
                        lawyer_docs = current_db.collection(LAWYERS_COLLECTION).where(
                            filter=FieldFilter('userId', '==', prosecutor_id)
                        ).limit(1).stream()
                        for lawyer_doc in lawyer_docs:
                            lawyer_ref = current_db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                            lawyer_data = lawyer_doc.to_dict()
                            await asyncio.to_thread(lambda lr=lawyer_ref, wd=lawyer_data: lr.update({
                                'wins': wd.get('wins', 0) + 1
                            }))
                            print(f"[COURT] Updated prosecutor {prosecutor_id} wins (Guilty verdict - single judge)")
                    
                    # Defense loses
                    for defense_id in defense_attorneys:
                        lawyer_docs = current_db.collection(LAWYERS_COLLECTION).where(
                            filter=FieldFilter('userId', '==', defense_id)
                        ).limit(1).stream()
                        for lawyer_doc in lawyer_docs:
                            lawyer_ref = current_db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                            lawyer_data = lawyer_doc.to_dict()
                            await asyncio.to_thread(lambda lr=lawyer_ref, ld=lawyer_data: lr.update({
                                'losses': ld.get('losses', 0) + 1
                            }))
                            print(f"[COURT] Updated defense {defense_id} losses (Guilty verdict - single judge)")
                else:
                    # Not Guilty - Defense wins
                    for defense_id in defense_attorneys:
                        lawyer_docs = current_db.collection(LAWYERS_COLLECTION).where(
                            filter=FieldFilter('userId', '==', defense_id)
                        ).limit(1).stream()
                        for lawyer_doc in lawyer_docs:
                            lawyer_ref = current_db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                            lawyer_data = lawyer_doc.to_dict()
                            await asyncio.to_thread(lambda lr=lawyer_ref, wd=lawyer_data: lr.update({
                                'wins': wd.get('wins', 0) + 1
                            }))
                            print(f"[COURT] Updated defense {defense_id} wins (Not Guilty verdict - single judge)")
                    
                    # Prosecutors lose
                    for prosecutor_id in prosecutors:
                        lawyer_docs = current_db.collection(LAWYERS_COLLECTION).where(
                            filter=FieldFilter('userId', '==', prosecutor_id)
                        ).limit(1).stream()
                        for lawyer_doc in lawyer_docs:
                            lawyer_ref = current_db.collection(LAWYERS_COLLECTION).document(lawyer_doc.id)
                            lawyer_data = lawyer_doc.to_dict()
                            await asyncio.to_thread(lambda lr=lawyer_ref, ld=lawyer_data: lr.update({
                                'losses': ld.get('losses', 0) + 1
                            }))
                            print(f"[COURT] Updated prosecutor {prosecutor_id} losses (Not Guilty verdict - single judge)")
            except Exception as lawyer_err:
                print(f"[WARN] Failed to update lawyer stats: {lawyer_err}")
                # Don't fail the verdict if lawyer stats update fails
            
            # Post verdict to court status channel
            if COURT_STATUS_CHANNEL_ID and interaction.guild:
                status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                if status_channel:
                    case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
                    # Civil: Plaintiff Prevails = plaintiff wins (green for them), Criminal: Guilty = conviction (red)
                    if case_data.get('caseType') == "Civil":
                        verdict_color = discord.Color.green() if 'plaintiff' in verdict_text.lower() else discord.Color.blue()
                    else:
                        verdict_color = discord.Color.red() if verdict_text.lower() == 'guilty' else discord.Color.green()
                    verdict_embed = discord.Embed(
                        title=f"{case_type_emoji} VERDICT: Case #{self.case_id}",
                        description=(
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Charges:** {case_data.get('charges')}\n\n"
                            f"**Verdict:** {verdict_text}\n" +
                            (f"**Sentence:** {sentence_text}\n" if sentence_text else "") +
                            f"**Magistrate:** {interaction.user.mention}"
                        ),
                        color=verdict_color
                    )
                    now_est = datetime.now(timezone.utc).astimezone(EST)
                    verdict_embed.set_footer(text=f"Issued {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                    await status_channel.send(embed=verdict_embed)
            
            # Note: Warrants should be issued BEFORE court cases via /warrant add
            # Verdicts only create pearl records, they do NOT create warrants
            
            # Create pearl record if pearl duration is specified
            pearl_duration_val = self.pearl_duration.value.strip() if self.pearl_duration.value else ""
            vault_location_val = self.vault_location.value.strip() if self.vault_location.value else ""
            pearl_holder_val = self.pearl_holder.value.strip() if self.pearl_holder.value else ""
            
            if pearl_duration_val and pearl_duration_val.isdigit():
                try:
                    duration_days = int(pearl_duration_val)
                    pearl_start_date = datetime.now(timezone.utc)
                    expected_release = pearl_start_date + timedelta(days=duration_days)
                    
                    pearl_id = f"PEARL-{self.case_id}"
                    await asyncio.to_thread(lambda: current_db.collection(PEARLS_COLLECTION).document(pearl_id).set({
                        'ign': case_data.get('defendantIgn'),
                        'userId': case_data.get('defendantDiscordId'),
                        'pearlDuration': duration_days,
                        'pearlStartDate': pearl_start_date,
                        'expectedReleaseDate': expected_release,
                        'vaultLocation': vault_location_val if vault_location_val else 'Not specified',
                        'pearlHolder': pearl_holder_val if pearl_holder_val else 'State',
                        'courtCaseId': self.case_id,
                        'jurisdiction': jurisdiction,
            'status': 'active',
                        'issuedBy': str(interaction.user),
                        'issuedById': interaction.user.id,
                        'charges': case_data.get('charges'),
                        'sentence': sentence_text
                    }))
                    
                    # Update case with pearl info
                    await asyncio.to_thread(lambda: case_ref.update({
                        'pearlDuration': duration_days,
                        'pearlStartDate': pearl_start_date,
                        'expectedReleaseDate': expected_release,
                        'vaultLocation': vault_location_val,
                        'pearlHolder': pearl_holder_val,
                        'pearlId': pearl_id
                    }))
                    
                    print(f"[PEARL] Created pearl record for {case_data.get('defendantIgn')} - {duration_days} days")
                except Exception as e:
                    print(f"[ERR] Failed to create pearl record: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Post verdict with appeal button to case channel
            case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
            verdict_color = discord.Color.red() if verdict_text.lower() == 'guilty' else discord.Color.green()
            
            final_verdict_embed = discord.Embed(
                title=f"{case_type_emoji} VERDICT ISSUED: Case #{self.case_id}",
                description=(
                    f"**Defendant:** {case_data.get('defendantIgn')}\n"
                    f"**Charges:** {case_data.get('charges')}\n\n"
                    f"**Verdict:** {verdict_text}\n" +
                    (f"**Sentence:** {sentence_text}\n" if sentence_text else "") +
                    f"**Magistrate:** {interaction.user.mention}"
                ),
                color=verdict_color
            )
            now_est = datetime.now(timezone.utc).astimezone(EST)
            final_verdict_embed.set_footer(text=f"Issued {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
            
            # Create appeal view
            appeal_view = VerdictAppealView(self.case_id, case_data.get('defendantDiscordId'))
            await interaction.channel.send(embed=final_verdict_embed, view=appeal_view)
            
            await interaction.edit_original_response(content="‚úÖ Verdict issued successfully!")
        except Exception as e:
            print(f"[ERR] Failed to issue verdict: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to issue verdict. Please try again.")

# Verdict Modal for Magistrates (3-judge panel for serious cases)
class IssueVerdictModal(ui.Modal):
    def __init__(self, case_id: str, case_type: str = "Criminal"):
        super().__init__(title="üî® Issue Verdict")
        self.case_id = case_id
        self.case_type = case_type
        
        if case_type == "Civil":
            self.verdict = ui.TextInput(
                label="Verdict",
                placeholder="Plaintiff Prevails or Defendant Prevails",
                required=True,
                max_length=30
            )
            self.sentence = ui.TextInput(
                label="Remedy / Relief (if plaintiff prevails)",
                placeholder="e.g., Return of property, 64 diamonds compensation",
                style=discord.TextStyle.paragraph,
                required=False,
                max_length=500
            )
        else:
            self.verdict = ui.TextInput(
                label="Verdict",
                placeholder="Guilty or Not Guilty",
                required=True,
                max_length=20
            )
            self.sentence = ui.TextInput(
                label="Sentence (if guilty)",
                placeholder="e.g., 7 days pearl, 64 diamonds compensation",
                style=discord.TextStyle.paragraph,
                required=False,
                max_length=500
            )
        
        self.add_item(self.verdict)
        self.add_item(self.sentence)
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üî® Proposing verdict...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        verdict_text = self.verdict.value.strip()
        sentence_text = self.sentence.value.strip() if self.sentence.value else ""
        
        # Validate verdict
        verdict_lower = verdict_text.lower()
        if verdict_lower not in ['guilty', 'not guilty']:
            return await interaction.edit_original_response(content="‚ùå Verdict must be 'Guilty' or 'Not Guilty'")
        
        # Create 3-judge voting panel instead of direct verdict
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Initialize judge panel voting
            judge_votes = {
                str(interaction.user.id): {
                    'judge': str(interaction.user),
                    'verdict': verdict_text,
                    'votedAt': datetime.now(timezone.utc)
                }
            }
            
            # Update case with proposed verdict and first judge vote
            await asyncio.to_thread(lambda: case_ref.update({
                'proposedVerdict': verdict_text,
                'proposedSentence': sentence_text,
                'judgeVotes': judge_votes,
                'voteCount': 1,
                'proposedBy': str(interaction.user),
                'proposedById': interaction.user.id,
                'proposedAt': datetime.now(timezone.utc)
            }))
            
            # Post judge voting panel
            case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
            verdict_color = discord.Color.orange()  # Orange for pending vote
            
            # Build voting panel description
            vote_desc = [
                f"**Defendant:** {case_data.get('defendantIgn')}",
                f"**Charges:** {case_data.get('charges')}",
                f"\n**Proposed Verdict:** {verdict_text}",
            ]
            if sentence_text:
                vote_desc.append(f"**Proposed Sentence:** {sentence_text}")
            vote_desc.append(f"\n**Proposed By:** {interaction.user.mention}")
            vote_desc.append(f"\nüìä **Judge Panel Votes:** 1/3")
            vote_desc.append(f"‚úÖ {interaction.user.mention}: {verdict_text}")
            vote_desc.append(f"\n‚öñÔ∏è **2 more magistrates needed to finalize verdict**")
            
            voting_embed = discord.Embed(
                title=f"{case_type_emoji} JUDGE PANEL VOTING: Case #{self.case_id}",
                description="\n".join(vote_desc),
                color=verdict_color
            )
            now_est = datetime.now(timezone.utc).astimezone(EST)
            voting_embed.set_footer(text=f"Voting Started {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
            
            # Create judge voting view - different buttons for civil vs criminal
            case_type = case_data.get('caseType', 'Criminal')
            judge_vote_view = JudgeVotingView(self.case_id, case_type=case_type)
            
            # Send voting panel to the channel
            await interaction.channel.send(embed=voting_embed, view=judge_vote_view)
            
            # Acknowledge to judge
            await interaction.edit_original_response(content="‚úÖ Verdict proposed! Waiting for 2 more magistrates to vote.")
        except Exception as e:
            print(f"[ERR] Failed to issue verdict: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to issue verdict. Please try again.")

# Trial Argument Modal
class SubmitArgumentModal(ui.Modal, title="üìù Submit Argument"):
    argument = ui.TextInput(
        label="Your Argument",
        placeholder="Present your case...",
        style=discord.TextStyle.paragraph,
        required=True,
        max_length=2000
    )
    
    def __init__(self, case_id: str, role: str):
        super().__init__()
        self.case_id = case_id
        self.role = role  # "prosecution" or "defense"
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üìù Submitting argument...")
        
        argument_text = self.argument.value.strip()
        
        # Post argument in the thread
        role_emoji = "‚öîÔ∏è" if self.role == "prosecution" else "üõ°Ô∏è"
        role_name = "Prosecution" if self.role == "prosecution" else "Defense"
        
        arg_embed = discord.Embed(
            title=f"{role_emoji} {role_name} Argument",
            description=argument_text,
            color=discord.Color.red() if self.role == "prosecution" else discord.Color.blue()
        )
        arg_embed.set_author(name=str(interaction.user), icon_url=interaction.user.display_avatar.url)
        now_est = datetime.now(timezone.utc).astimezone(EST)
        arg_embed.set_footer(text=f"Submitted {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
        
        await interaction.channel.send(embed=arg_embed)
        await interaction.edit_original_response(content="‚úÖ Argument submitted!")

# Trial Action View (in trial thread)
class TrialActionView(ui.View):
    def __init__(self, case_id: str):
        super().__init__(timeout=None)
        self.case_id = case_id
        
        # Prosecution argument
        pros_btn = ui.Button(label="‚öîÔ∏è Prosecution Argues", style=discord.ButtonStyle.danger, custom_id=f"pros_{case_id}")
        pros_btn.callback = self.prosecution_argue
        self.add_item(pros_btn)
        
        # Defense argument
        def_btn = ui.Button(label="üõ°Ô∏è Defense Argues", style=discord.ButtonStyle.primary, custom_id=f"def_{case_id}")
        def_btn.callback = self.defense_argue
        self.add_item(def_btn)
        
        # Call jury vote (magistrates only)
        jury_btn = ui.Button(label="üë• Call Jury Vote", style=discord.ButtonStyle.secondary, custom_id=f"jury_{case_id}")
        jury_btn.callback = self.call_jury
        self.add_item(jury_btn)
        
        # Issue final verdict (magistrates only)
        verdict_btn = ui.Button(label="‚öñÔ∏è Final Verdict", style=discord.ButtonStyle.success, custom_id=f"final_{case_id}")
        verdict_btn.callback = self.final_verdict
        self.add_item(verdict_btn)
    
    async def prosecution_argue(self, interaction: discord.Interaction):
        await interaction.response.send_modal(SubmitArgumentModal(self.case_id, "prosecution"))
    
    async def defense_argue(self, interaction: discord.Interaction):
        await interaction.response.send_modal(SubmitArgumentModal(self.case_id, "defense"))
    
    async def call_jury(self, interaction: discord.Interaction):
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can call jury votes.")
        
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        # Create jury vote embed
        jury_embed = discord.Embed(
            title="üë• JURY VOTE CALLED",
            description=(
                f"**Case:** #{self.case_id}\n"
                f"**Called By:** {interaction.user.mention}\n\n"
                f"Jury members, please review the arguments above and cast your vote.\n\n"
                f"React with:\n"
                f"üî¥ = **Guilty**\n"
                f"üü¢ = **Not Guilty**"
            ),
            color=0xFFD700  # Gold
        )
        jury_embed.set_footer(text="Jury voting is open | Magistrates will review results")
        
        jury_msg = await interaction.channel.send(embed=jury_embed)
        
        # Add reaction options
        await jury_msg.add_reaction("üî¥")
        await jury_msg.add_reaction("üü¢")
        
        await interaction.edit_original_response(content="‚úÖ Jury vote called!")
    
    async def final_verdict(self, interaction: discord.Interaction):
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can issue final verdicts.")
        
        # Check case severity to determine if 3-judge panel is required
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.response.send_message("‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            requires_panel = case_data.get('requiresJudgePanel', False)
            
            # Route to appropriate verdict modal
            if requires_panel:
                # Serious case: Use 3-judge panel
                await interaction.response.send_modal(IssueVerdictModal(self.case_id, case_type=case_data.get("caseType", "Criminal")))
            else:
                # Normal case: Single judge verdict
                case_type = case_data.get('caseType', 'Criminal')
                await interaction.response.send_modal(SingleJudgeVerdictModal(self.case_id, case_type=case_type))
        except Exception as e:
            print(f"[ERR] Failed to check case severity: {e}")
            return await interaction.response.send_message("‚ùå Failed to load case data.")

# Court Case Action Buttons (for magistrates)
class ClaimProsecutorButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(label="üéØ Claim as Prosecutor", style=discord.ButtonStyle.green, custom_id=f"claim_prosecutor_{case_id}")
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        # Check if user is a prosecutor
        lawyer_data = get_lawyer_data(interaction.user.id)
        if not lawyer_data or lawyer_data.get('lawyerType') != 'prosecutor':
            return await interaction.edit_original_response(content="‚ùå Only registered State Prosecutors can claim cases.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if already has prosecutor
            if case_data.get('prosecutorId'):
                return await interaction.edit_original_response(content="‚ùå This case already has a prosecutor.")
            
            # Assign prosecutor
            await asyncio.to_thread(lambda: case_ref.update({
                'prosecutorId': interaction.user.id,
                'prosecutorName': str(interaction.user)
            }))
            
            # Update lawyer's active cases (avoid duplicates)
            lawyer_ref = db.collection(LAWYERS_COLLECTION).document(lawyer_data['id'])
            active_cases = lawyer_data.get('activeCases', [])
            if self.case_id not in active_cases:
                active_cases.append(self.case_id)
                await asyncio.to_thread(lambda lr=lawyer_ref, ac=active_cases: lr.update({'activeCases': ac}))
            
            # Send DM notification to prosecutor
            await notify_lawyer_assignment(interaction.user.id, self.case_id, case_data, "prosecutor", bot)
            
            # Update the message with new lawyer info
            if interaction.message:
                embed = interaction.message.embeds[0]
                embed.add_field(name="üéØ Prosecutor", value=interaction.user.mention, inline=True)
                await interaction.message.edit(embed=embed, view=CourtCaseActionView(self.case_id))
            
            await interaction.edit_original_response(content=f"‚úÖ You are now the prosecutor for case #{self.case_id}!")
        except Exception as e:
            print(f"[ERR] Failed to claim prosecutor: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to claim case. Please try again.")

class RequestDefenseLawyerButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(label="üõ°Ô∏è Request Defense Lawyer", style=discord.ButtonStyle.blurple, custom_id=f"request_defense_{case_id}")
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        # Show list of available defense lawyers
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Get available defense lawyers (attorneys and public defenders)
            lawyers = []
            for doc in db.collection(LAWYERS_COLLECTION).stream():
                lawyer = doc.to_dict()
                lawyer['doc_id'] = doc.id
                ltype = lawyer.get('lawyerType', '')
                if ltype in ['attorney', 'public_defender']:
                    lawyers.append(lawyer)
            
            if not lawyers:
                return await interaction.response.send_message("‚ùå No defense lawyers available. Please register one first!")
            
            # Create selection view
            view = ui.View()
            select = ui.Select(placeholder="Choose your defense lawyer...", custom_id=f"select_defense_{self.case_id}")
            
            for lawyer in lawyers[:25]:  # Discord limit
                ltype_emoji = "‚öñÔ∏è" if lawyer.get('lawyerType') == 'attorney' else "üõ°Ô∏è"
                select.add_option(
                    label=f"{lawyer.get('discordName', 'Unknown')} ({lawyer.get('lawyerType').title()})",
                    description=f"Bar #: {lawyer.get('barNumber', 'N/A')} | W/L: {lawyer.get('wins', 0)}/{lawyer.get('losses', 0)}",
                    value=str(lawyer.get('discordId')),
                    emoji=ltype_emoji
                )
            
            async def select_callback(select_interaction: discord.Interaction):
                await select_interaction.response.defer(ephemeral=True)
                lawyer_id = int(select.values[0])
                
                # Assign defense lawyer
                case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
                case_doc = case_ref.get()
                selected_lawyer = next((l for l in lawyers if l.get('discordId') == lawyer_id), None)
                
                if selected_lawyer and case_doc.exists:
                    case_data = case_doc.to_dict()
                    await asyncio.to_thread(lambda: case_ref.update({
                        'defenseLawyerId': lawyer_id,
                        'defenseLawyerName': selected_lawyer.get('discordName')
                    }))
                    
                    # Update lawyer's active cases (avoid duplicates)
                    lawyer_ref = db.collection(LAWYERS_COLLECTION).document(selected_lawyer['doc_id'])
                    active_cases = selected_lawyer.get('activeCases', [])
                    if self.case_id not in active_cases:
                        active_cases.append(self.case_id)
                        await asyncio.to_thread(lambda lr=lawyer_ref, ac=active_cases: lr.update({'activeCases': ac}))
                    
                    # Send DM notification to defense lawyer
                    await notify_lawyer_assignment(lawyer_id, self.case_id, case_data, "defense", bot)
                    
                    # Update the case message embed
                    try:
                        case_type = case_data.get('caseType')
                        channel_id = CRIMINAL_CASES_CHANNEL_ID if case_type == "Criminal" else CIVIL_CASES_CHANNEL_ID
                        case_channel = select_interaction.guild.get_channel(channel_id)
                        if case_channel and case_data.get('messageId'):
                            case_message = await case_channel.fetch_message(case_data.get('messageId'))
                            embed = case_message.embeds[0]
                            embed.add_field(name="üõ°Ô∏è Defense Lawyer", value=f"<@{lawyer_id}>", inline=True)
                            await case_message.edit(embed=embed, view=CourtCaseActionView(self.case_id))
                    except Exception as e:
                        print(f"[WARN] Could not update case message: {e}")
                    
                    await select_interaction.followup.send(f"‚úÖ <@{lawyer_id}> is now your defense lawyer!")
            
            select.callback = select_callback
            view.add_item(select)
            await interaction.response.send_message("**Select your defense lawyer:**", view=view, ephemeral=True)
        except Exception as e:
            print(f"[ERR] Failed to request defense lawyer: {e}")
            await interaction.response.send_message("‚ùå Failed to request lawyer. Please try again.")

class RequestPlaintiffLawyerButton(ui.Button):
    def __init__(self, case_id: str, plaintiff_id: int):
        super().__init__(label="‚öñÔ∏è Plaintiff: Request Lawyer", style=discord.ButtonStyle.blurple, custom_id=f"request_plaintiff_lawyer_{case_id}")
        self.case_id = case_id
        self.plaintiff_id = plaintiff_id
    
    async def callback(self, interaction: discord.Interaction):
        # Only plaintiff can request their lawyer
        if interaction.user.id != self.plaintiff_id:
            return await interaction.response.send_message("‚ùå Only the plaintiff can request a lawyer.")
        
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Get available attorneys
            lawyers = []
            for doc in db.collection(LAWYERS_COLLECTION).stream():
                lawyer = doc.to_dict()
                lawyer['doc_id'] = doc.id
                if lawyer.get('lawyerType') == 'attorney':
                    lawyers.append(lawyer)
            
            if not lawyers:
                return await interaction.response.send_message("‚ùå No attorneys available. Please register one first!")
            
            # Create selection view
            view = ui.View()
            select = ui.Select(placeholder="Choose your attorney...", custom_id=f"select_plaintiff_lawyer_{self.case_id}")
            
            for lawyer in lawyers[:25]:
                select.add_option(
                    label=f"{lawyer.get('discordName', 'Unknown')}",
                    description=f"Bar #: {lawyer.get('barNumber', 'N/A')} | W/L: {lawyer.get('wins', 0)}/{lawyer.get('losses', 0)}",
                    value=str(lawyer.get('discordId')),
                    emoji="‚öñÔ∏è"
                )
            
            async def select_callback(select_interaction: discord.Interaction):
                await select_interaction.response.defer(ephemeral=True)
                lawyer_id = int(select.values[0])
                
                # Assign plaintiff lawyer
                case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
                case_doc = case_ref.get()
                selected_lawyer = next((l for l in lawyers if l.get('discordId') == lawyer_id), None)
                
                if selected_lawyer and case_doc.exists:
                    case_data = case_doc.to_dict()
                    await asyncio.to_thread(lambda: case_ref.update({
                        'plaintiffLawyerId': lawyer_id,
                        'plaintiffLawyerName': selected_lawyer.get('discordName')
                    }))
                    
                    # Update lawyer's active cases (avoid duplicates)
                    lawyer_ref = db.collection(LAWYERS_COLLECTION).document(selected_lawyer['doc_id'])
                    active_cases = selected_lawyer.get('activeCases', [])
                    if self.case_id not in active_cases:
                        active_cases.append(self.case_id)
                        await asyncio.to_thread(lambda lr=lawyer_ref, ac=active_cases: lr.update({'activeCases': ac}))
                    
                    # Send DM notification to plaintiff's lawyer
                    await notify_lawyer_assignment(lawyer_id, self.case_id, case_data, "plaintiff", bot)
                    
                    # Update the case message embed
                    try:
                        case_type = case_data.get('caseType')
                        channel_id = CRIMINAL_CASES_CHANNEL_ID if case_type == "Criminal" else CIVIL_CASES_CHANNEL_ID
                        case_channel = select_interaction.guild.get_channel(channel_id)
                        if case_channel and case_data.get('messageId'):
                            case_message = await case_channel.fetch_message(case_data.get('messageId'))
                            embed = case_message.embeds[0]
                            embed.add_field(name="‚öñÔ∏è Plaintiff's Attorney", value=f"<@{lawyer_id}>", inline=True)
                            await case_message.edit(embed=embed, view=CourtCaseActionView(self.case_id))
                    except Exception as e:
                        print(f"[WARN] Could not update case message: {e}")
                    
                    await select_interaction.followup.send(f"‚úÖ <@{lawyer_id}> is now representing the plaintiff!")
            
            select.callback = select_callback
            view.add_item(select)
            await interaction.response.send_message("**Select your attorney:**", view=view, ephemeral=True)
        except Exception as e:
            print(f"[ERR] Failed to request plaintiff lawyer: {e}")
            await interaction.response.send_message("‚ùå Failed to request lawyer. Please try again.")

class RequestDefendantLawyerButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(label="‚öñÔ∏è Defendant: Request Lawyer", style=discord.ButtonStyle.green, custom_id=f"request_defendant_lawyer_{case_id}")
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        # Note: In civil cases, defendant can be anyone, we'll allow anyone to claim this for now
        # Could add permission check if needed
        
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Get available attorneys
            lawyers = []
            for doc in db.collection(LAWYERS_COLLECTION).stream():
                lawyer = doc.to_dict()
                lawyer['doc_id'] = doc.id
                if lawyer.get('lawyerType') == 'attorney':
                    lawyers.append(lawyer)
            
            if not lawyers:
                return await interaction.response.send_message("‚ùå No attorneys available. Please register one first!")
            
            # Create selection view
            view = ui.View()
            select = ui.Select(placeholder="Choose your attorney...", custom_id=f"select_defendant_lawyer_{self.case_id}")
            
            for lawyer in lawyers[:25]:
                select.add_option(
                    label=f"{lawyer.get('discordName', 'Unknown')}",
                    description=f"Bar #: {lawyer.get('barNumber', 'N/A')} | W/L: {lawyer.get('wins', 0)}/{lawyer.get('losses', 0)}",
                    value=str(lawyer.get('discordId')),
                    emoji="‚öñÔ∏è"
                )
            
            async def select_callback(select_interaction: discord.Interaction):
                await select_interaction.response.defer(ephemeral=True)
                lawyer_id = int(select.values[0])
                
                # Assign defendant lawyer
                case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
                case_doc = case_ref.get()
                selected_lawyer = next((l for l in lawyers if l.get('discordId') == lawyer_id), None)
                
                if selected_lawyer and case_doc.exists:
                    case_data = case_doc.to_dict()
                    await asyncio.to_thread(lambda: case_ref.update({
                        'defendantLawyerId': lawyer_id,
                        'defendantLawyerName': selected_lawyer.get('discordName')
                    }))
                    
                    # Update lawyer's active cases (avoid duplicates)
                    lawyer_ref = db.collection(LAWYERS_COLLECTION).document(selected_lawyer['doc_id'])
                    active_cases = selected_lawyer.get('activeCases', [])
                    if self.case_id not in active_cases:
                        active_cases.append(self.case_id)
                        await asyncio.to_thread(lambda lr=lawyer_ref, ac=active_cases: lr.update({'activeCases': ac}))
                    
                    # Send DM notification to defendant's lawyer
                    await notify_lawyer_assignment(lawyer_id, self.case_id, case_data, "defendant", bot)
                    
                    # Update the case message embed
                    try:
                        case_type = case_data.get('caseType')
                        channel_id = CRIMINAL_CASES_CHANNEL_ID if case_type == "Criminal" else CIVIL_CASES_CHANNEL_ID
                        case_channel = select_interaction.guild.get_channel(channel_id)
                        if case_channel and case_data.get('messageId'):
                            case_message = await case_channel.fetch_message(case_data.get('messageId'))
                            embed = case_message.embeds[0]
                            embed.add_field(name="‚öñÔ∏è Defendant's Attorney", value=f"<@{lawyer_id}>", inline=True)
                            await case_message.edit(embed=embed, view=CourtCaseActionView(self.case_id))
                    except Exception as e:
                        print(f"[WARN] Could not update case message: {e}")
                    
                    await select_interaction.followup.send(f"‚úÖ <@{lawyer_id}> is now representing the defendant!")
            
            select.callback = select_callback
            view.add_item(select)
            await interaction.response.send_message("**Select your attorney:**", view=view, ephemeral=True)
        except Exception as e:
            print(f"[ERR] Failed to request defendant lawyer: {e}")
            await interaction.response.send_message("‚ùå Failed to request lawyer. Please try again.")

# Plea Bargain Modal
class PleaBargainModal(ui.Modal, title="ü§ù Offer Plea Bargain"):
    plea_terms = ui.TextInput(
        label="Plea Bargain Terms",
        placeholder="e.g., Plead guilty to lesser charge, 3 days pearl instead of 7",
        style=discord.TextStyle.paragraph,
        required=True,
        max_length=500
    )
    
    def __init__(self, case_id: str):
        super().__init__()
        self.case_id = case_id
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("ü§ù Offering plea bargain...")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Update case with plea bargain offer
            await asyncio.to_thread(lambda: case_ref.update({
                'pleaBargainOffer': self.plea_terms.value.strip(),
                'pleaOfferedBy': str(interaction.user),
                'pleaOfferedById': interaction.user.id,
                'pleaOfferedAt': datetime.now(timezone.utc),
                'pleaStatus': 'offered'
            }))
            
            # Post plea bargain to case channel with accept/reject buttons for defendant
            case_type = case_data.get('caseType')
            channel_id = CRIMINAL_CASES_CHANNEL_ID if case_type == "Criminal" else CIVIL_CASES_CHANNEL_ID
            
            if interaction.guild:
                case_channel = interaction.guild.get_channel(channel_id)
                if case_channel:
                    plea_embed = discord.Embed(
                        title=f"ü§ù PLEA BARGAIN OFFERED: Case #{self.case_id}",
                        description=(
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Original Charges:** {case_data.get('charges')}\n\n"
                            f"**Plea Bargain Terms:**\n{self.plea_terms.value.strip()}\n\n"
                            f"**Offered By:** {interaction.user.mention}\n\n"
                            f"‚ö†Ô∏è **Defendant:** Use the buttons below to accept or reject this plea bargain."
                        ),
                        color=discord.Color.gold()
                    )
                    now_est = datetime.now(timezone.utc).astimezone(EST)
                    plea_embed.set_footer(text=f"Offered {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                    
                    # Create view with accept/reject buttons
                    plea_view = PleaResponseView(self.case_id, case_data.get('defendantDiscordId'))
                    await case_channel.send(embed=plea_embed, view=plea_view)
            
            await interaction.edit_original_response(content="‚úÖ Plea bargain offered to defendant!")
        except Exception as e:
            print(f"[ERR] Failed to offer plea bargain: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to offer plea bargain. Please try again.")

# Plea Response View (Accept/Reject buttons for defendant)
class PleaResponseView(ui.View):
    def __init__(self, case_id: str, defendant_discord_id: int):
        super().__init__(timeout=None)
        self.case_id = case_id
        self.defendant_discord_id = defendant_discord_id
        
        # Accept button
        accept_btn = ui.Button(label="‚úÖ Accept Plea", style=discord.ButtonStyle.success, custom_id=f"plea_accept_{case_id}")
        accept_btn.callback = self.accept_plea
        self.add_item(accept_btn)
        
        # Reject button
        reject_btn = ui.Button(label="‚ùå Reject Plea", style=discord.ButtonStyle.danger, custom_id=f"plea_reject_{case_id}")
        reject_btn.callback = self.reject_plea
        self.add_item(reject_btn)
    
    async def accept_plea(self, interaction: discord.Interaction):
        # Check if user is the defendant
        if self.defendant_discord_id and interaction.user.id != self.defendant_discord_id:
            return await interaction.response.send_message("‚ùå Only the defendant can accept this plea bargain.")
        
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Close case with plea bargain
            await asyncio.to_thread(lambda: case_ref.update({
                'pleaStatus': 'accepted',
                'pleaAcceptedAt': datetime.now(timezone.utc),
                'verdict': 'Plea Bargain Accepted',
                'sentence': case_data.get('pleaBargainOffer'),
                'status': 'closed'
            }))
            
            # Post acceptance to court status channel
            if COURT_STATUS_CHANNEL_ID and interaction.guild:
                status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                if status_channel:
                    acceptance_embed = discord.Embed(
                        title=f"ü§ù PLEA BARGAIN ACCEPTED: Case #{self.case_id}",
                        description=(
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Plea Terms:** {case_data.get('pleaBargainOffer')}\n"
                            f"**Accepted By:** {interaction.user.mention}\n\n"
                            f"**Status:** Case closed - No trial required"
                        ),
                        color=discord.Color.green()
                    )
                    now_est = datetime.now(timezone.utc).astimezone(EST)
                    acceptance_embed.set_footer(text=f"Accepted {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                    await status_channel.send(embed=acceptance_embed)
            
            await interaction.edit_original_response(content="‚úÖ Plea bargain accepted! Case closed.")
            
            # Disable the buttons
            for item in self.children:
                item.disabled = True
            await interaction.message.edit(view=self)
        except Exception as e:
            print(f"[ERR] Failed to accept plea: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to accept plea bargain.")
    
    async def reject_plea(self, interaction: discord.Interaction):
        # Check if user is the defendant
        if self.defendant_discord_id and interaction.user.id != self.defendant_discord_id:
            return await interaction.response.send_message("‚ùå Only the defendant can reject this plea bargain.")
        
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            await asyncio.to_thread(lambda: case_ref.update({
                'pleaStatus': 'rejected',
                'pleaRejectedAt': datetime.now(timezone.utc)
            }))
            
            await interaction.edit_original_response(content="‚úÖ Plea bargain rejected. Case will proceed to trial.")
            
            # Disable the buttons
            for item in self.children:
                item.disabled = True
            await interaction.message.edit(view=self)
        except Exception as e:
            print(f"[ERR] Failed to reject plea: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to reject plea bargain.")

class JoinAsCounselButton(ui.Button):
    """Allows any lawyer to opt-in to view the private courtroom thread"""
    def __init__(self, case_id: str):
        super().__init__(label="‚öñÔ∏è Join as Counsel", style=discord.ButtonStyle.gray, custom_id=f"join_counsel_{case_id}")
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        # Check if user has any lawyer role
        has_lawyer_role = False
        if interaction.user.roles:
            for role in interaction.user.roles:
                if role.id in [ATTORNEY_ROLE_ID, PUBLIC_DEFENDER_ROLE_ID, STATE_PROSECUTOR_ROLE_ID]:
                    has_lawyer_role = True
                    break
        
        if not has_lawyer_role:
            return await interaction.edit_original_response(content="‚ùå Only registered lawyers can join case threads.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            thread_id = case_data.get('courtroomThreadId')
            
            if not thread_id:
                return await interaction.edit_original_response(content="‚ùå No courtroom thread found for this case.")
            
            # Get the thread and add user
            try:
                thread = await interaction.guild.fetch_channel(thread_id)
                await thread.add_user(interaction.user)
                
                # Notify in thread
                await thread.send(f"‚öñÔ∏è **{interaction.user.mention} has joined as counsel.**")
                
                await interaction.edit_original_response(content=f"‚úÖ You've been added to the private courtroom thread for Case #{self.case_id}!")
            except discord.NotFound:
                return await interaction.edit_original_response(content="‚ùå Courtroom thread no longer exists.")
            except discord.Forbidden:
                return await interaction.edit_original_response(content="‚ùå Cannot access courtroom thread.")
                
        except Exception as e:
            print(f"[ERR] Failed to join counsel: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to join courtroom. Please try again.")

class CourtCaseActionView(ui.View):
    def __init__(self, case_id: str):
        super().__init__(timeout=None)
        self.case_id = case_id
        
        # Add "Join as Counsel" button first (for all lawyers to opt-in)
        self.add_item(JoinAsCounselButton(case_id))
        
        # Add lawyer assignment buttons (these will be shown initially)
        # Get case data to determine which buttons to show
        if db:
            try:
                case_doc = db.collection(COURT_CASES_COLLECTION).document(case_id).get()
                if case_doc.exists:
                    case_data = case_doc.to_dict()
                    case_type = case_data.get('caseType')
                    
                    # Criminal cases: show prosecutor and defense buttons
                    if case_type == "Criminal":
                        if not case_data.get('prosecutorId'):
                            self.add_item(ClaimProsecutorButton(case_id))
                        if not case_data.get('defenseLawyerId'):
                            self.add_item(RequestDefenseLawyerButton(case_id))
                    
                    # Civil cases: show lawyer request buttons for both parties
                    elif case_type == "Civil":
                        if not case_data.get('plaintiffLawyerId'):
                            self.add_item(RequestPlaintiffLawyerButton(case_id, case_data.get('plaintiffId')))
                        if not case_data.get('defendantLawyerId'):
                            self.add_item(RequestDefendantLawyerButton(case_id))
            except:
                pass
        
        # Offer Plea Bargain button (prosecutors only)
        plea_btn = ui.Button(label="ü§ù Offer Plea Bargain", style=discord.ButtonStyle.secondary, custom_id=f"plea_{case_id}")
        plea_btn.callback = self.offer_plea
        self.add_item(plea_btn)
        
        # Start Trial button (creates thread for arguments/jury)
        trial_btn = ui.Button(label="‚öñÔ∏è Start Trial", style=discord.ButtonStyle.primary, custom_id=f"trial_{case_id}")
        trial_btn.callback = self.start_trial
        self.add_item(trial_btn)
        
        # Issue Verdict button (quick verdict without trial)
        verdict_btn = ui.Button(label="üî® Quick Verdict", style=discord.ButtonStyle.danger, custom_id=f"verdict_{case_id}")
        verdict_btn.callback = self.issue_verdict
        self.add_item(verdict_btn)
        
        # Review Appeal button (for appeals court)
        appeal_review_btn = ui.Button(label="üì¢ Review Appeal", style=discord.ButtonStyle.secondary, custom_id=f"review_appeal_{case_id}")
        appeal_review_btn.callback = self.review_appeal
        self.add_item(appeal_review_btn)
        
        # Close Case button
        close_btn = ui.Button(label="‚úÖ Close Case", style=discord.ButtonStyle.success, custom_id=f"close_{case_id}")
        close_btn.callback = self.close_case
        self.add_item(close_btn)
    
    async def offer_plea(self, interaction: discord.Interaction):
        # Check if user is prosecutor or judge
        lawyer_data = get_lawyer_data(interaction.user.id)
        is_prosecutor = lawyer_data and lawyer_data.get('lawyerType') == 'prosecutor'
        is_judge = has_magistrate_role(interaction)
        
        if not is_prosecutor and not is_judge:
            return await interaction.response.send_message("‚ùå Only prosecutors or magistrates can offer plea bargains.")
        
        await interaction.response.send_modal(PleaBargainModal(self.case_id))
    
    async def start_trial(self, interaction: discord.Interaction):
        # Check if user has magistrate role
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can start trials.")
        
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Get case data
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Create thread for trial
            case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
            thread = await interaction.message.create_thread(
                name=f"{case_type_emoji} Trial: {self.case_id} - {case_data.get('defendantIgn')}",
                auto_archive_duration=1440  # 24 hours
            )
            
            # Update case with trial thread
            await asyncio.to_thread(lambda: case_ref.update({
                'trialThreadId': thread.id,
                'trialStartedBy': str(interaction.user),
                'trialStartedAt': datetime.now(timezone.utc)
            }))
            
            # Post trial introduction in thread
            trial_embed = discord.Embed(
                title=f"{case_type_emoji} TRIAL PROCEEDINGS: Case #{self.case_id}",
                description=(
                    f"**Defendant:** {case_data.get('defendantIgn')}\n"
                    f"**Charges:** {case_data.get('charges')}\n"
                    f"**Plaintiff:** <@{case_data.get('plaintiffId')}>\n"
                    f"**Presiding Magistrate:** {interaction.user.mention}\n\n"
                    f"**Evidence:**\n{case_data.get('evidence')}\n" +
                    (f"\nüìé **Evidence Links:**\n{case_data.get('evidenceLinks')}" if case_data.get('evidenceLinks') else "")
                ),
                color=0x008b8b
            )
            trial_embed.set_footer(text="Trial Started | Use buttons below for actions")
            
            # Create trial action view
            trial_view = TrialActionView(self.case_id)
            await thread.send(embed=trial_embed, view=trial_view)
            
            await interaction.edit_original_response(content=f"‚úÖ Trial started! Proceed to {thread.mention}")
        except Exception as e:
            print(f"[ERR] Failed to start trial: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to start trial. Please try again.")
    
    async def issue_verdict(self, interaction: discord.Interaction):
        # Check if user has magistrate role
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can issue verdicts.")
        
        # Check case severity to determine if 3-judge panel is required
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.response.send_message("‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            requires_panel = case_data.get('requiresJudgePanel', False)
            
            # Route to appropriate verdict modal
            if requires_panel:
                # Serious case: Use 3-judge panel
                await interaction.response.send_modal(IssueVerdictModal(self.case_id, case_type=case_data.get("caseType", "Criminal")))
            else:
                # Normal case: Single judge verdict
                await interaction.response.send_modal(SingleJudgeVerdictModal(self.case_id, case_type=case_data.get("caseType", "Criminal")))
        except Exception as e:
            print(f"[ERR] Failed to check case severity: {e}")
            return await interaction.response.send_message("‚ùå Failed to load case data.")
    
    async def close_case(self, interaction: discord.Interaction):
        # Check if user has magistrate role
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can close cases.")
        
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            await asyncio.to_thread(lambda: case_ref.update({
                'status': 'closed',
                'closedBy': str(interaction.user),
                'closedAt': datetime.now(timezone.utc)
            }))
            
            # Create close case embed
            case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
            
            close_embed = discord.Embed(
                title=f"{case_type_emoji} CASE CLOSED: #{self.case_id}",
                description=(
                    f"**Defendant:** {case_data.get('defendantIgn')}\n"
                    f"**Charges:** {case_data.get('charges')}\n"
                    f"**Closed By:** {interaction.user.mention}"
                ),
                color=0x808080  # Gray color for closed
            )
            now_est = datetime.now(timezone.utc).astimezone(EST)
            close_embed.set_footer(text=f"Closed {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
            
            # Send embed to the channel
            await interaction.channel.send(embed=close_embed)
            
            # Acknowledge to judge
            await interaction.edit_original_response(content="‚úÖ Case closed successfully!")
        except Exception as e:
            print(f"[ERR] Failed to close case: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to close case. Please try again.")
    
    async def review_appeal(self, interaction: discord.Interaction):
        # Check if user is a judge
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can review appeals.")
        
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if case has an appeal
            if not case_data.get('appealStatus') or case_data.get('appealStatus') != 'pending':
                return await interaction.edit_original_response(content="‚ùå No pending appeal for this case.")
            
            # Show appeal info with decision buttons
            appeal_embed = discord.Embed(
                title=f"üì¢ APPEALS COURT REVIEW: Case #{self.case_id}",
                description=(
                    f"**Defendant:** {case_data.get('defendantIgn')}\n"
                    f"**Original Charges:** {case_data.get('charges')}\n"
                    f"**Original Verdict:** {case_data.get('verdict')}\n"
                    f"**Original Sentence:** {case_data.get('sentence', 'None')}\n\n"
                    f"**Appeal Reason:**\n{case_data.get('appealReason')}\n\n"
                    f"**Appeal Filed By:** <@{case_data.get('appealedById')}>\n\n"
                    f"‚öñÔ∏è **Appeals Court:** Use buttons below to make a decision"
                ),
                color=discord.Color.orange()
            )
            
            # Create view with Uphold/Overturn buttons
            appeal_decision_view = AppealDecisionView(self.case_id)
            await interaction.edit_original_response(embed=appeal_embed, view=appeal_decision_view)
        except Exception as e:
            print(f"[ERR] Failed to review appeal: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to review appeal.")

# Appeals Court Decision View
class AppealDecisionView(ui.View):
    def __init__(self, case_id: str):
        super().__init__()
        self.case_id = case_id
        
        # Uphold button
        uphold_btn = ui.Button(label="‚úÖ Uphold Original Verdict", style=discord.ButtonStyle.success)
        uphold_btn.callback = self.uphold
        self.add_item(uphold_btn)
        
        # Overturn button
        overturn_btn = ui.Button(label="üîÑ Overturn Verdict", style=discord.ButtonStyle.danger)
        overturn_btn.callback = self.overturn
        self.add_item(overturn_btn)
    
    async def uphold(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            case_data = case_doc.to_dict()
            
            # Update appeal status
            await asyncio.to_thread(lambda: case_ref.update({
                'appealStatus': 'upheld',
                'appealDecision': 'Original verdict upheld',
                'appealDecidedBy': str(interaction.user),
                'appealDecidedAt': datetime.now(timezone.utc)
            }))
            
            # Post decision to court status channel
            if COURT_STATUS_CHANNEL_ID and interaction.guild:
                status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                if status_channel:
                    decision_embed = discord.Embed(
                        title=f"üì¢ APPEALS COURT DECISION: Case #{self.case_id}",
                        description=(
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Original Verdict:** {case_data.get('verdict')}\n\n"
                            f"**Decision:** Original verdict **UPHELD**\n"
                            f"**Decided By:** {interaction.user.mention}"
                        ),
                        color=discord.Color.green()
                    )
                    now_est = datetime.now(timezone.utc).astimezone(EST)
                    decision_embed.set_footer(text=f"Appeals Court Decision {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                    await status_channel.send(embed=decision_embed)
            
            await interaction.edit_original_response(content="‚úÖ Appeal denied. Original verdict upheld.")
        except Exception as e:
            print(f"[ERR] Failed to uphold verdict: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to process decision.")
    
    async def overturn(self, interaction: discord.Interaction):
        await interaction.response.send_modal(OverturnVerdictModal(self.case_id))

# Overturn Verdict Modal
class OverturnVerdictModal(ui.Modal, title="üîÑ Overturn Verdict"):
    new_verdict = ui.TextInput(
        label="New Verdict",
        placeholder="Guilty or Not Guilty",
        required=True,
        max_length=20
    )
    new_sentence = ui.TextInput(
        label="New Sentence (if guilty)",
        placeholder="e.g., 3 days pearl, 32 diamonds compensation",
        style=discord.TextStyle.paragraph,
        required=False,
        max_length=500
    )
    
    def __init__(self, case_id: str):
        super().__init__()
        self.case_id = case_id
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üîÑ Overturning verdict...")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            case_data = case_doc.to_dict()
            
            new_verdict_text = self.new_verdict.value.strip()
            new_sentence_text = self.new_sentence.value.strip() if self.new_sentence.value else ""
            
            # Update case with new verdict
            await asyncio.to_thread(lambda: case_ref.update({
                'verdict': new_verdict_text,
                'sentence': new_sentence_text,
                'appealStatus': 'overturned',
                'appealDecision': f'Verdict overturned to: {new_verdict_text}',
                'appealDecidedBy': str(interaction.user),
                'appealDecidedAt': datetime.now(timezone.utc)
            }))
            
            # Post decision to court status channel
            if COURT_STATUS_CHANNEL_ID and interaction.guild:
                status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                if status_channel:
                    verdict_color = discord.Color.red() if new_verdict_text.lower() == 'guilty' else discord.Color.green()
                    decision_embed = discord.Embed(
                        title=f"üì¢ APPEALS COURT DECISION: Case #{self.case_id}",
                        description=(
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Original Verdict:** {case_data.get('verdict')}\n\n"
                            f"**Decision:** Verdict **OVERTURNED**\n"
                            f"**New Verdict:** {new_verdict_text}\n" +
                            (f"**New Sentence:** {new_sentence_text}\n" if new_sentence_text else "") +
                            f"**Decided By:** {interaction.user.mention}"
                        ),
                        color=verdict_color
                    )
                    now_est = datetime.now(timezone.utc).astimezone(EST)
                    decision_embed.set_footer(text=f"Appeals Court Decision {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                    await status_channel.send(embed=decision_embed)
            
            await interaction.edit_original_response(content="‚úÖ Verdict overturned successfully!")
        except Exception as e:
            print(f"[ERR] Failed to overturn verdict: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to process decision.")

# Magistrate Assignment Button
class AssignMagistrateThreadButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(
            label="üèõÔ∏è Assign Magistrate",
            style=discord.ButtonStyle.primary,
            custom_id=f"assign_magistrate_thread_{case_id}"
        )
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Assigning magistrate...", ephemeral=True)
        
        # Check if user has magistrate role
        if not has_magistrate_role(interaction):
            return await interaction.edit_original_response(content="‚ùå Only Magistrates can assign themselves to cases.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if magistrate already assigned
            existing_magistrate = case_data.get('magistrateId')
            if existing_magistrate:
                return await interaction.edit_original_response(content=f"‚ùå Magistrate already assigned: <@{existing_magistrate}>")
            
            # Assign magistrate
            await asyncio.to_thread(lambda: case_ref.update({
                'magistrateId': interaction.user.id,
                'magistrateName': str(interaction.user)
            }))
            
            # Notify in thread
            await interaction.channel.send(f"üèõÔ∏è **Magistrate {interaction.user.mention} has been assigned to this case.**")
            await interaction.edit_original_response(content="‚úÖ You are now the Magistrate for this case!")
            
        except Exception as e:
            print(f"[ERR] Failed to assign magistrate: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content="‚ùå Failed to assign magistrate.")

class ViewRoleStatusButton(ui.Button):
    def __init__(self, case_id: str, case_type: str):
        super().__init__(
            label="üìã View Role Assignments",
            style=discord.ButtonStyle.secondary,
            custom_id=f"view_roles_{case_id}",
            row=0
        )
        self.case_id = case_id
        self.case_type = case_type
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        
        if not db:
            return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.followup.send("‚ùå Case not found.", ephemeral=True)
            
            case_data = case_doc.to_dict()
            
            role_embed = discord.Embed(
                title=f"üìã Role Assignments - Case #{self.case_id}",
                description=f"**Case Type:** {self.case_type}\n**Status:** {case_data.get('status', 'Unknown').title()}\n\n",
                color=0x5865F2
            )
            
            magistrate_id = case_data.get('magistrateId')
            magistrate_name = case_data.get('magistrateName', 'Not Assigned')
            if magistrate_id:
                role_embed.add_field(
                    name="üèõÔ∏è Magistrate",
                    value=f"<@{magistrate_id}> ({magistrate_name})",
                    inline=False
                )
            else:
                role_embed.add_field(
                    name="üèõÔ∏è Magistrate",
                    value="‚ùå **Not Assigned**",
                    inline=False
                )
            
            if self.case_type == "Criminal":
                prosecutor_id = case_data.get('prosecutorId')
                prosecutor_name = case_data.get('prosecutorName', 'Not Assigned')
                defense_id = case_data.get('defenseLawyerId')
                defense_name = case_data.get('defenseLawyerName', 'Not Assigned')
                
                if prosecutor_id:
                    role_embed.add_field(
                        name="‚öîÔ∏è State Prosecutor",
                        value=f"<@{prosecutor_id}> ({prosecutor_name})",
                        inline=True
                    )
                else:
                    role_embed.add_field(
                        name="‚öîÔ∏è State Prosecutor",
                        value="‚ùå **Not Assigned**",
                        inline=True
                    )
                
                if defense_id:
                    role_embed.add_field(
                        name="üõ°Ô∏è Defense Attorney",
                        value=f"<@{defense_id}> ({defense_name})",
                        inline=True
                    )
                else:
                    role_embed.add_field(
                        name="üõ°Ô∏è Defense Attorney",
                        value="‚ùå **Not Assigned**",
                        inline=True
                    )
            else:
                plaintiff_lawyer_id = case_data.get('plaintiffLawyerId')
                plaintiff_lawyer_name = case_data.get('plaintiffLawyerName', 'Not Assigned')
                defendant_lawyer_id = case_data.get('defendantLawyerId')
                defendant_lawyer_name = case_data.get('defendantLawyerName', 'Not Assigned')
                
                if plaintiff_lawyer_id:
                    role_embed.add_field(
                        name="üëî Plaintiff's Counsel",
                        value=f"<@{plaintiff_lawyer_id}> ({plaintiff_lawyer_name})",
                        inline=True
                    )
                else:
                    role_embed.add_field(
                        name="üëî Plaintiff's Counsel",
                        value="‚ùå **Not Assigned**",
                        inline=True
                    )
                
                if defendant_lawyer_id:
                    role_embed.add_field(
                        name="üëî Defendant's Counsel",
                        value=f"<@{defendant_lawyer_id}> ({defendant_lawyer_name})",
                        inline=True
                    )
                else:
                    role_embed.add_field(
                        name="üëî Defendant's Counsel",
                        value="‚ùå **Not Assigned**",
                        inline=True
                    )
            
            role_embed.set_footer(text=f"‚öñÔ∏è Case #{self.case_id} | Florab√≠s State Judiciary")
            role_embed.timestamp = datetime.now(timezone.utc)
            
            await interaction.followup.send(embed=role_embed, ephemeral=True)
            
        except Exception as e:
            print(f"[ERR] Failed to view role status: {e}")
            import traceback
            traceback.print_exc()
            await interaction.followup.send("‚ùå Failed to retrieve role assignments.", ephemeral=True)

# Interactive Panel for Courtroom Threads (Lawyers/Magistrates claim roles)
class CourtroomActionPanel(ui.View):
    def __init__(self, case_id: str, case_type: str):
        super().__init__(timeout=None)
        self.case_id = case_id
        self.case_type = case_type
        
        # Add role status button FIRST for visibility
        self.add_item(ViewRoleStatusButton(case_id, case_type))
        
        # Add magistrate assignment button
        self.add_item(AssignMagistrateThreadButton(case_id))
        
        # Add claim buttons based on case type
        if case_type == "Criminal":
            self.add_item(ClaimProsecutorThreadButton(case_id))
            self.add_item(ClaimDefenseLawyerThreadButton(case_id))
        else:  # Civil
            self.add_item(ClaimPlaintiffLawyerThreadButton(case_id))
            self.add_item(ClaimDefendantLawyerThreadButton(case_id))
        
        # Universal buttons
        self.add_item(IssueVerdictThreadButton(case_id))

class ClaimProsecutorThreadButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(
            label="‚öñÔ∏è Claim Prosecutor",
            style=discord.ButtonStyle.primary,
            custom_id=f"claim_prosecutor_thread_{case_id}"
        )
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Claiming prosecutor role...", ephemeral=True)
        
        # Check if user is a state prosecutor
        lawyer_data = get_lawyer_data(interaction.user.id)
        if not lawyer_data or lawyer_data.get('lawyerType') != 'prosecutor':
            return await interaction.edit_original_response(content="‚ùå Only registered State Prosecutors can claim this role.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if case is already closed/sentenced
            case_status = case_data.get('status', '').lower()
            if case_status in ['closed', 'sentenced', 'dismissed']:
                return await interaction.edit_original_response(content="üîí This case is already closed.")
            
            # Check if already claimed
            if case_data.get('prosecutorId'):
                return await interaction.edit_original_response(content=f"‚ùå Prosecutor already assigned: <@{case_data['prosecutorId']}>")
            
            # Assign prosecutor
            await asyncio.to_thread(lambda: case_ref.update({
                'prosecutorId': interaction.user.id,
                'prosecutorName': str(interaction.user)
            }))
            
            # Notify in thread
            await interaction.channel.send(f"‚öñÔ∏è **{interaction.user.mention} has claimed the Prosecutor role for this case.**")
            await interaction.edit_original_response(content="‚úÖ You are now the Prosecutor for this case!")
            
        except Exception as e:
            print(f"[ERR] Failed to claim prosecutor: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to claim prosecutor role.")

class ClaimDefenseLawyerThreadButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(
            label="üõ°Ô∏è Claim Defense Lawyer",
            style=discord.ButtonStyle.success,
            custom_id=f"claim_defense_thread_{case_id}"
        )
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Claiming defense lawyer role...", ephemeral=True)
        
        # Check if user is a lawyer
        lawyer_data = get_lawyer_data(interaction.user.id)
        if not lawyer_data or lawyer_data.get('lawyerType') not in ['attorney', 'public_defender']:
            return await interaction.edit_original_response(content="‚ùå Only registered Attorneys or Public Defenders can claim this role.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if case is already closed/sentenced
            case_status = case_data.get('status', '').lower()
            if case_status in ['closed', 'sentenced', 'dismissed']:
                return await interaction.edit_original_response(content="üîí This case is already closed.")
            
            # Check if already claimed
            if case_data.get('defenseLawyerId'):
                return await interaction.edit_original_response(content=f"‚ùå Defense lawyer already assigned: <@{case_data['defenseLawyerId']}>")
            
            # Assign defense lawyer
            await asyncio.to_thread(lambda: case_ref.update({
                'defenseLawyerId': interaction.user.id,
                'defenseLawyerName': str(interaction.user)
            }))
            
            # Notify in thread
            await interaction.channel.send(f"üõ°Ô∏è **{interaction.user.mention} has claimed the Defense Lawyer role for this case.**")
            await interaction.edit_original_response(content="‚úÖ You are now the Defense Lawyer for this case!")
            
        except Exception as e:
            print(f"[ERR] Failed to claim defense lawyer: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to claim defense lawyer role.")

class ClaimPlaintiffLawyerThreadButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(
            label="‚öñÔ∏è Claim Plaintiff Lawyer",
            style=discord.ButtonStyle.primary,
            custom_id=f"claim_plaintiff_thread_{case_id}"
        )
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Claiming plaintiff lawyer role...", ephemeral=True)
        
        # Check if user is a lawyer
        lawyer_data = get_lawyer_data(interaction.user.id)
        if not lawyer_data or lawyer_data.get('lawyerType') != 'attorney':
            return await interaction.edit_original_response(content="‚ùå Only registered Attorneys can claim this role.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if already claimed
            if case_data.get('plaintiffLawyerId'):
                return await interaction.edit_original_response(content=f"‚ùå Plaintiff lawyer already assigned: <@{case_data['plaintiffLawyerId']}>")
            
            # Assign plaintiff lawyer
            await asyncio.to_thread(lambda: case_ref.update({
                'plaintiffLawyerId': interaction.user.id,
                'plaintiffLawyerName': str(interaction.user)
            }))
            
            # Notify in thread
            await interaction.channel.send(f"‚öñÔ∏è **{interaction.user.mention} has claimed the Plaintiff Lawyer role for this case.**")
            await interaction.edit_original_response(content="‚úÖ You are now the Plaintiff Lawyer for this case!")
            
        except Exception as e:
            print(f"[ERR] Failed to claim plaintiff lawyer: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to claim plaintiff lawyer role.")

class ClaimDefendantLawyerThreadButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(
            label="üõ°Ô∏è Claim Defendant Lawyer",
            style=discord.ButtonStyle.success,
            custom_id=f"claim_defendant_thread_{case_id}"
        )
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Claiming defendant lawyer role...", ephemeral=True)
        
        # Check if user is a lawyer
        lawyer_data = get_lawyer_data(interaction.user.id)
        if not lawyer_data or lawyer_data.get('lawyerType') != 'attorney':
            return await interaction.edit_original_response(content="‚ùå Only registered Attorneys can claim this role.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if already claimed
            if case_data.get('defendantLawyerId'):
                return await interaction.edit_original_response(content=f"‚ùå Defendant lawyer already assigned: <@{case_data['defendantLawyerId']}>")
            
            # Assign defendant lawyer
            await asyncio.to_thread(lambda: case_ref.update({
                'defendantLawyerId': interaction.user.id,
                'defendantLawyerName': str(interaction.user)
            }))
            
            # Notify in thread
            await interaction.channel.send(f"üõ°Ô∏è **{interaction.user.mention} has claimed the Defendant Lawyer role for this case.**")
            await interaction.edit_original_response(content="‚úÖ You are now the Defendant Lawyer for this case!")
            
        except Exception as e:
            print(f"[ERR] Failed to claim defendant lawyer: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to claim defendant lawyer role.")

class IssueVerdictThreadButton(ui.Button):
    def __init__(self, case_id: str):
        super().__init__(
            label="üî® Issue Verdict",
            style=discord.ButtonStyle.danger,
            custom_id=f"issue_verdict_thread_{case_id}"
        )
        self.case_id = case_id
    
    async def callback(self, interaction: discord.Interaction):
        # Check if user is a judge
        if not has_magistrate_role(interaction):
            return await interaction.response.send_message("‚ùå Only Magistrates can issue verdicts.", ephemeral=True)
        
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(self.case_id)
            case_doc = case_ref.get()
            
            if not case_doc.exists:
                return await interaction.response.send_message("‚ùå Case not found.", ephemeral=True)
            
            case_data = case_doc.to_dict()
            
            # Check if case is already closed/sentenced
            case_status = case_data.get('status', '').lower()
            if case_status in ['closed', 'sentenced', 'dismissed']:
                return await interaction.response.send_message("üîí This case is already closed. No further verdicts can be issued.", ephemeral=True)
            
            # Check if serious case (requires 3-judge panel)
            if case_data.get('requiresJudgePanel'):
                # Start 3-judge voting
                view = JudgeVotingView(self.case_id, case_type=case_data.get('caseType', 'Criminal'))
                await interaction.response.send_message(
                    content="‚ö†Ô∏è **SERIOUS CASE - 3-JUDGE PANEL REQUIRED**\n\n"
                            "This case requires a panel of 3 magistrates to vote on the verdict.\n"
                            "Click the button below to cast your vote.",
                    view=view,
                    ephemeral=True
                )
            else:
                # Single judge verdict - send modal directly
                await interaction.response.send_modal(SingleJudgeVerdictModal(self.case_id, case_type=case_data.get("caseType", "Criminal")))
                
        except Exception as e:
            print(f"[ERR] Failed to issue verdict: {e}")
            import traceback
            traceback.print_exc()
            await interaction.response.send_message("‚ùå Failed to load verdict form.", ephemeral=True)

# Court Case Filing Modal
class CourtFileCaseModal(ui.Modal):
    def __init__(self, case_type: str = "Criminal", severity: str = "Normal", lang: str = "en"):
        # Get translations for this language with safe cascading fallback
        tr = get_translation_dict(lang)
        
        # Set modal title with translation
        case_type_text = tr.get('criminal_case' if case_type == "Criminal" else 'civil_case', case_type)
        super().__init__(title=f"{case_type_text} ({tr.get('serious_severity' if severity == 'Serious' else 'normal_severity', severity)})")
        
        self.case_type = case_type
        self.severity = severity
        
        # Create translated text inputs
        self.defendant_ign = ui.TextInput(
            label=tr.get('defendant_ign', 'Defendant IGN'),
            placeholder=tr.get('defendant_ign_placeholder', "Enter defendant's in-game name"),
            required=True,
            max_length=16
        )
        self.charges = ui.TextInput(
            label=tr.get('charges', 'Charges/Complaint'),
            placeholder=tr.get('charges_placeholder', 'Describe the charges or complaint'),
            required=True,
            max_length=200
        )
        self.evidence = ui.TextInput(
            label=tr.get('evidence', 'Evidence'),
            placeholder=tr.get('evidence_placeholder', 'Links, screenshots, witness testimony, etc.'),
            style=discord.TextStyle.paragraph,
            required=True,
            max_length=1000
        )
        self.evidence_links = ui.TextInput(
            label=tr.get('evidence', 'Evidence') + " (Optional)",
            placeholder=tr.get('evidence_placeholder', 'Screenshot URLs (one per line)'),
            style=discord.TextStyle.paragraph,
            required=False,
            max_length=500
        )
        
        # Add fields to modal
        self.add_item(self.defendant_ign)
        self.add_item(self.charges)
        self.add_item(self.evidence)
        self.add_item(self.evidence_links)
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚öñÔ∏è Filing case...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        ign = self.defendant_ign.value.strip()
        charges_text = self.charges.value.strip()
        evidence_text = self.evidence.value.strip()
        evidence_links_text = self.evidence_links.value.strip() if self.evidence_links.value else ""
        
        # Auto-extract category from charges (first word or phrase)
        category_text = charges_text.split(',')[0].strip() if ',' in charges_text else charges_text.split()[0] if charges_text else "Other"
        
        # Use severity from parameter
        severity_text = self.severity.lower()
        is_serious = severity_text in ['serious', 'constitutional']
        
        # Find similar precedent cases by category
        precedent_cases = []
        try:
            similar_cases_query = db.collection(COURT_CASES_COLLECTION).where(
                filter=FieldFilter('caseCategory', '==', category_text.lower())
            ).where(
                filter=FieldFilter('verdict', '!=', None)
            ).limit(3)
            precedent_cases = list(similar_cases_query.stream())
        except:
            pass
        
        # Generate case ID with type prefix
        import uuid
        case_prefix = "CR" if self.case_type == "Criminal" else "CV"
        case_id = f"{case_prefix}-{str(uuid.uuid4())[:6].upper()}"
        
        # Create case in database
        try:
            case_ref = db.collection(COURT_CASES_COLLECTION).document(case_id)
            await asyncio.to_thread(lambda: case_ref.set({
                'caseId': case_id,
                'caseType': self.case_type,
                'caseCategory': category_text.lower(),
                'caseSeverity': 'serious' if is_serious else 'normal',
                'requiresJudgePanel': is_serious,
                'defendantIgn': ign,
                'defendantDiscordId': None,
                'defendantDiscordUsername': None,
                'plaintiff': str(interaction.user),
                'plaintiffId': interaction.user.id,
                'charges': charges_text,
                'evidence': evidence_text,
                'evidenceLinks': evidence_links_text,
                'status': 'pending',
                'filedAt': datetime.now(timezone.utc),
                'verdict': None,
                'sentence': None,
                # Lawyer fields
                'prosecutorId': None,
                'prosecutorName': None,
                'defenseLawyerId': None,
                'defenseLawyerName': None,
                'plaintiffLawyerId': None,
                'plaintiffLawyerName': None,
                'defendantLawyerId': None,
                'defendantLawyerName': None
            }))
            
            # Post to appropriate channel based on case type
            if interaction.guild:
                # Route to correct channel
                channel_id = CRIMINAL_CASES_CHANNEL_ID if self.case_type == "Criminal" else CIVIL_CASES_CHANNEL_ID
                court_channel = interaction.guild.get_channel(channel_id)
                
                if court_channel:
                    case_type_emoji = "‚öîÔ∏è" if self.case_type == "Criminal" else "üìú"
                    
                    # Build description
                    severity_label = "‚ö†Ô∏è SERIOUS (3-Judge Panel Required)" if is_serious else "üìã Normal"
                    desc_parts = [
                        f"**Type:** {self.case_type}",
                        f"**Severity:** {severity_label}",
                        f"**Category:** {category_text} üèõÔ∏è",
                        f"**Defendant IGN:** {ign}",
                        f"**Plaintiff:** {interaction.user.mention}",
                        f"**Charges:** {charges_text}",
                        f"**Evidence:** {evidence_text}"
                    ]
                    
                    # Add precedent cases if found
                    if precedent_cases:
                        precedent_list = []
                        for pc_doc in precedent_cases:
                            pc = pc_doc.to_dict()
                            precedent_list.append(
                                f"‚Ä¢ **{pc.get('caseId')}**: {pc.get('verdict')} - {pc.get('sentence', 'No sentence')[:40]}"
                            )
                        desc_parts.append(f"\nüìö **Similar Precedent Cases:**\n" + "\n".join(precedent_list))
                    
                    # Parse evidence links for image embeds
                    evidence_images = []
                    non_image_links = []
                    if evidence_links_text:
                        # Split by newlines and filter out empty lines
                        links = [link.strip() for link in evidence_links_text.split('\n') if link.strip()]
                        # Filter for image URLs
                        evidence_images = [link for link in links if any(link.lower().endswith(ext) for ext in ['.png', '.jpg', '.jpeg', '.gif', '.webp']) or 'imgur.com' in link.lower() or 'discord' in link.lower()]
                        
                        # Show non-image links as text
                        non_image_links = [link for link in links if link not in evidence_images]
                        if non_image_links:
                            desc_parts.append(f"\nüìé **Evidence Links:**\n" + "\n".join(non_image_links))
                    
                    # Post case announcement to channel (without action buttons)
                    # Criminal = Red, Civil = Neutral blue-gray for visual distinction
                    case_color = 0xDC143C if self.case_type == "Criminal" else 0x607D8B
                    embed = discord.Embed(
                        title=f"{case_type_emoji} NEW {self.case_type.upper()} CASE FILED: #{case_id}",
                        description="\n".join(desc_parts),
                        color=case_color
                    )
                    embed.set_footer(text=f"Case #{case_id} | Status: Pending Trial | Private Courtroom Thread Created")
                    
                    # Set first image as main embed image
                    if evidence_images:
                        embed.set_image(url=evidence_images[0])
                    
                    # Post without buttons - SAVE THE MESSAGE!
                    case_message = await court_channel.send(embed=embed)
                    
                    # Save messageId and channelId to database immediately
                    await asyncio.to_thread(lambda: case_ref.update({
                        'messageId': case_message.id,
                        'channelId': court_channel.id
                    }))
                    print(f"[COURT] Posted case {case_id} to channel {court_channel.id}, message {case_message.id}")
                    
                    # Create SEPARATE PRIVATE courtroom thread (like banking)
                    try:
                        print(f"[COURT] Creating separate private courtroom thread for case {case_id}...")
                        
                        # Create separate private thread (NOT attached to message)
                        courtroom_thread = await court_channel.create_thread(
                            name=f"‚öñÔ∏è Courtroom: {case_id}",
                            type=discord.ChannelType.private_thread,
                            invitable=True,  # Allow lawyers to join when pinged
                            auto_archive_duration=10080  # 7 days
                        )
                        print(f"[COURT] ‚úÖ Separate private thread created: ID {courtroom_thread.id}")
                        
                        # Add plaintiff to the thread
                        await courtroom_thread.add_user(interaction.user)
                        print(f"[COURT] ‚úÖ Added plaintiff to thread: {interaction.user}")
                        
                        # Add all magistrates to the thread
                        if interaction.guild and MAGISTRATE_ROLE_ID:
                            magistrate_role = interaction.guild.get_role(MAGISTRATE_ROLE_ID)
                            if magistrate_role:
                                for member in magistrate_role.members:
                                    try:
                                        await courtroom_thread.add_user(member)
                                        print(f"[COURT] ‚úÖ Added magistrate to thread: {member}")
                                    except Exception as e:
                                        print(f"[WARN] Could not add magistrate {member}: {e}")
                        
                        # Small delay to ensure thread is ready
                        await asyncio.sleep(0.5)
                        
                        # Get current timestamp in EST
                        filed_time = datetime.now(timezone.utc).astimezone(EST)
                        
                        print(f"[COURT] Building case information embed for thread...")
                        # Build clean case information (NO === or box borders!)
                        case_info = (
                            f"**üèõÔ∏è FLORAB√çS STATE JUDICIARY**\n"
                            f"**COURTROOM: CASE #{case_id}**\n\n"
                            f"**üìã CASE INFORMATION**\n"
                            f"‚ñ∏ Case Number: **{case_id}**\n"
                            f"‚ñ∏ Type: **{self.case_type.upper()}**\n"
                            f"‚ñ∏ Severity: **{severity_text.title()}**\n"
                            f"‚ñ∏ Status: üü° **FILED - AWAITING ASSIGNMENT**\n"
                            f"‚ñ∏ Filed: {filed_time.strftime('%b %d, %Y at %I:%M %p EST')}\n\n"
                            f"**‚öñÔ∏è THE PARTIES**\n"
                            f"‚ñ∏ **Plaintiff/Complainant:** {interaction.user.mention}\n"
                            f"‚ñ∏ **Defendant/Respondent:** {ign} (IGN)\n\n"
                            f"**‚öîÔ∏è CHARGES/CLAIMS**\n"
                            f"{charges_text}\n"
                        )
                        
                        # Build evidence section
                        evidence_count = len(evidence_images) + len(non_image_links) if non_image_links else len(evidence_images)
                        evidence_info = (
                            f"\n**üìÇ EVIDENCE FILED**\n"
                            f"‚ñ∏ Total Items: **{evidence_count}**\n"
                            f"‚ñ∏ Status: ‚è≥ **PENDING REVIEW**\n\n"
                            f"**üìù CASE DESCRIPTION**\n"
                            f"{evidence_text}\n"
                        )
                        
                        # Build full description
                        full_description = case_info + evidence_info
                        
                        # Create main case embed
                        case_embed = discord.Embed(
                            title=f"{case_type_emoji} CASE FILED: {self.case_type.upper()}",
                            description=full_description,
                            color=0x1e3a5f  # Courthouse blue
                        )
                        case_embed.set_footer(text=f"‚öñÔ∏è Florab√≠s State Judiciary | Case #{case_id} | Private Courtroom")
                        
                        # Set first evidence image
                        if evidence_images:
                            case_embed.set_image(url=evidence_images[0])
                        
                        print(f"[COURT] Sending case information embed to thread...")
                        try:
                            await courtroom_thread.send(embed=case_embed)
                            print(f"[COURT] ‚úÖ Case information posted to thread")
                        except Exception as send_err:
                            print(f"[ERR] Failed to send case embed: {send_err}")
                            import traceback
                            traceback.print_exc()
                        
                        # Send additional evidence images (if more than 1)
                        if len(evidence_images) > 1:
                            for img_url in evidence_images[1:]:
                                try:
                                    img_embed = discord.Embed(color=0x008b8b)
                                    img_embed.set_image(url=img_url)
                                    img_embed.set_footer(text=f"Evidence for Case #{case_id}")
                                    await courtroom_thread.send(embed=img_embed)
                                except Exception as img_err:
                                    print(f"[ERR] Failed to send evidence image: {img_err}")
                        
                        # Auto-ping Magistrates + Lawyers (Prosecutors only for Criminal cases)
                        pings = []
                        
                        # Ping Magistrates
                        if MAGISTRATE_ROLE_ID:
                            pings.append(f"<@&{MAGISTRATE_ROLE_ID}>")
                        
                        # Ping attorney and public defender roles (all case types)
                        if ATTORNEY_ROLE_ID:
                            pings.append(f"<@&{ATTORNEY_ROLE_ID}>")
                        if PUBLIC_DEFENDER_ROLE_ID:
                            pings.append(f"<@&{PUBLIC_DEFENDER_ROLE_ID}>")
                        
                        # Only ping prosecutors for Criminal cases (case-insensitive)
                        if STATE_PROSECUTOR_ROLE_ID and self.case_type.lower() == "criminal":
                            pings.append(f"<@&{STATE_PROSECUTOR_ROLE_ID}>")
                        
                        # Try to find and ping defendant
                        defendant_user = None
                        try:
                            # Search for defendant in citizens database
                            print(f"[COURT] Searching for defendant IGN: {ign}")
                            citizens = list(db.collection(CITIZENS_COLLECTION).where(
                                filter=FieldFilter('ign', '==', ign)
                            ).limit(1).stream())
                            
                            if citizens:
                                citizen_data = citizens[0].to_dict()
                                defendant_discord_id = citizen_data.get('userId')
                                if defendant_discord_id and interaction.guild:
                                    defendant_user = interaction.guild.get_member(defendant_discord_id)
                                    if defendant_user:
                                        print(f"[COURT] Found defendant: {defendant_user}")
                                        pings.append(defendant_user.mention)
                                        # Save defendant Discord info to case
                                        await asyncio.to_thread(lambda: case_ref.update({
                                            'defendantDiscordId': defendant_discord_id,
                                            'defendantDiscordUsername': str(defendant_user)
                                        }))
                                    else:
                                        print(f"[COURT] Defendant Discord ID found but user not in guild")
                                else:
                                    print(f"[COURT] Defendant has no Discord ID in database")
                            else:
                                print(f"[COURT] Defendant IGN not found in citizens database")
                        except Exception as e:
                            print(f"[WARN] Could not find defendant: {e}")
                            import traceback
                            traceback.print_exc()
                        
                        # Send formal court notification
                        if pings:
                            print(f"[COURT] Sending notification with pings: {pings}")
                            ping_text = " ".join(pings)
                            try:
                                notification_embed = discord.Embed(
                                    title="üì¢ OFFICIAL COURT NOTICE",
                                    description=(
                                        f"**TO ALL COURT OFFICERS AND COUNSEL:**\n\n"
                                        f"A new {self.case_type.lower()} case has been filed with the Florab√≠s State Judiciary.\n\n"
                                        f"**Case Number:** {case_id}\n"
                                        f"**Parties:** {interaction.user.mention} v. {ign}\n\n"
                                        f"All legal professionals and magistrates are hereby notified:\n\n"
                                        f"{ping_text}\n\n"
                                        f"üîí **This is a PRIVATE courtroom thread.** Lawyers may use the buttons below to join as counsel."
                                    ),
                                    color=0xffd700  # Gold
                                )
                                notification_embed.set_footer(text=f"Florab√≠s State Judiciary | Case #{case_id}")
                                await courtroom_thread.send(embed=notification_embed)
                                print(f"[COURT] ‚úÖ Notification sent with pings")
                            except Exception as ping_err:
                                print(f"[ERR] Failed to send ping notification: {ping_err}")
                                import traceback
                                traceback.print_exc()
                        else:
                            print(f"[COURT] ‚ö†Ô∏è No pings to send (no roles configured)")
                        
                        # Add interactive action panel for case management
                        print(f"[COURT] Creating action panel for case type: {self.case_type}")
                        action_embed = discord.Embed(
                            title="‚öñÔ∏è COURTROOM ACTION PANEL",
                            description=(
                                f"**CASE MANAGEMENT & ROLE ASSIGNMENT**\n\n"
                                f"**üèõÔ∏è FOR MAGISTRATES:**\n"
                                f"‚ñ∏ Assign yourself to this case\n"
                                f"‚ñ∏ Issue verdicts and rulings\n"
                                f"‚ñ∏ Close case when concluded\n\n"
                                f"**‚öîÔ∏è FOR PROSECUTORS:**\n"
                                f"‚ñ∏ Claim prosecution of this case\n"
                                f"‚ñ∏ Offer plea bargains\n\n"
                                f"**üõ°Ô∏è FOR DEFENSE ATTORNEYS:**\n"
                                f"‚ñ∏ Join as defense counsel\n"
                                f"‚ñ∏ Represent the defendant\n\n"
                                f"**‚öñÔ∏è FOR ALL LAWYERS:**\n"
                                f"‚ñ∏ Participate in proceedings\n"
                                f"‚ñ∏ Access this private courtroom\n\n"
                                f"*Click the buttons below to take action*"
                            ),
                            color=0x1e3a5f  # Courthouse blue
                        )
                        action_embed.set_footer(text=f"‚öñÔ∏è Case #{case_id} | Florab√≠s State Judiciary")
                        
                        # Create view with claim buttons
                        print(f"[COURT] Initializing CourtroomActionPanel...")
                        try:
                            courtroom_view = CourtroomActionPanel(case_id, self.case_type)
                            print(f"[COURT] Sending action panel to thread...")
                            action_message = await courtroom_thread.send(embed=action_embed, view=courtroom_view)
                            print(f"[COURT] ‚úÖ Action panel posted successfully")
                            
                            # Save action panel message ID for re-registration
                            await asyncio.to_thread(lambda: case_ref.update({
                                'actionPanelMessageId': action_message.id
                            }))
                        except Exception as panel_err:
                            print(f"[ERR] Failed to send action panel: {panel_err}")
                            import traceback
                            traceback.print_exc()
                        
                        # Save thread ID to case
                        await asyncio.to_thread(lambda: case_ref.update({
                            'courtroomThreadId': courtroom_thread.id
                        }))
                        
                        print(f"[COURT] Created PRIVATE courtroom thread {courtroom_thread.id} for case {case_id}")
                    except Exception as thread_err:
                        print(f"[ERR] ‚ö†Ô∏è FAILED to create courtroom thread for case {case_id}: {thread_err}")
                        print(f"[ERR] Thread error type: {type(thread_err).__name__}")
                        import traceback
                        traceback.print_exc()
                        
                        # Alert the user that thread creation failed
                        try:
                            await court_channel.send(
                                f"‚ö†Ô∏è **Thread creation failed for case #{case_id}**\n"
                                f"An admin can fix this with: `/court_create_thread case_id:{case_id}`",
                                delete_after=300  # Delete after 5 minutes
                            )
                        except:
                            pass
            
            # Notify lawyers of the new case
            if interaction.guild and LAWYER_NOTIFICATIONS_CHANNEL_ID:
                case_info = {
                    'caseType': self.case_type,
                    'severity': self.severity,
                    'defendantIgn': ign,
                    'plaintiff': str(interaction.user),
                    'category': category_text if 'category_text' in dir() else 'N/A',
                    'charges': charges_text if 'charges_text' in dir() else 'N/A'
                }
                await notify_lawyers_of_case(interaction.guild, case_id, case_info)
            
            # Get user's language for success message with safe cascading fallback
            user_lang = get_user_language(interaction)
            tr = get_translation_dict(user_lang)
            
            await interaction.edit_original_response(
                content=f"{tr.get('case_filed')}\n\n**{tr.get('case_id')}:** #{case_id}\n**{tr.get('case_type')}:** {self.case_type}\n**{tr.get('defendant_ign')}:** {ign}\n\n‚öñÔ∏è {tr.get('check_thread')}"
            )
        except Exception as e:
            print(f"[ERR] Failed to file court case: {e}")
            # Get user's language for error message with safe cascading fallback
            user_lang = get_user_language(interaction)
            tr = get_translation_dict(user_lang)
            await interaction.edit_original_response(content=f"{tr.get('error')} Failed to file case. Please try again.")

# Case Severity Selection Dropdown
class SeveritySelect(ui.Select):
    def __init__(self, case_type: str):
        options = [
            discord.SelectOption(
                label="Normal Case",
                description="Standard case with single Magistrate",
                value="Normal",
                emoji="‚öñÔ∏è"
            ),
            discord.SelectOption(
                label="Serious Case",
                description="Important case requiring 3-Magistrate panel",
                value="Serious",
                emoji="‚ö†Ô∏è"
            )
        ]
        super().__init__(placeholder="Select case severity level...", options=options, custom_id="severity_select")
        self.case_type = case_type
    
    async def callback(self, interaction: discord.Interaction):
        try:
            selected_severity = self.values[0]
            user_lang = get_user_language(interaction)
            print(f"[COURT] Severity selected: {selected_severity} for case type: {self.case_type}, user language: {user_lang}")
            await interaction.response.send_modal(CourtFileCaseModal(case_type=self.case_type, severity=selected_severity, lang=user_lang))
            print(f"[COURT] Modal sent successfully")
        except Exception as e:
            print(f"[ERR] Severity dropdown callback failed: {e}")
            import traceback
            traceback.print_exc()
            try:
                await interaction.response.send_message(f"‚ùå Error opening modal: {str(e)}")
            except:
                pass

class SeveritySelectionView(ui.View):
    def __init__(self, case_type: str):
        super().__init__(timeout=180)
        self.add_item(SeveritySelect(case_type))

# Court Panel Buttons
class FileCriminalCaseButton(ui.Button):
    def __init__(self):
        super().__init__(label="‚öîÔ∏è File Criminal Case", style=discord.ButtonStyle.danger, custom_id="court_file_criminal")
    
    async def callback(self, interaction: discord.Interaction):
        try:
            print(f"[COURT] Criminal case button clicked by {interaction.user}")
            # Show severity selection dropdown first
            view = SeveritySelectionView(case_type="Criminal")
            embed = discord.Embed(
                title="‚öîÔ∏è File Criminal Case - Select Severity",
                description="Choose the severity level for this case:",
                color=discord.Color.dark_teal()
            )
            embed.add_field(name="‚öñÔ∏è Normal Case", value="Standard case with single judge", inline=False)
            embed.add_field(name="‚ö†Ô∏è Serious Case", value="Important case requiring 3-judge panel", inline=False)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
            print(f"[COURT] Severity dropdown sent successfully")
        except Exception as e:
            print(f"[ERR] Criminal case button failed: {e}")
            import traceback
            traceback.print_exc()
            try:
                await interaction.response.send_message(f"‚ùå Error: {str(e)}", ephemeral=True)
            except:
                pass

class FileCivilCaseButton(ui.Button):
    def __init__(self):
        super().__init__(label="üìú File Civil Case", style=discord.ButtonStyle.primary, custom_id="court_file_civil")
    
    async def callback(self, interaction: discord.Interaction):
        # Show severity selection dropdown first
        view = SeveritySelectionView(case_type="Civil")
        embed = discord.Embed(
            title="üìú File Civil Case - Select Severity",
            description="Choose the severity level for this case:",
            color=discord.Color.dark_teal()
        )
        embed.add_field(name="‚öñÔ∏è Normal Case", value="Standard case with single judge", inline=False)
        embed.add_field(name="‚ö†Ô∏è Serious Case", value="Important case requiring 3-judge panel", inline=False)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

class RefreshMyCasesButton(ui.Button):
    def __init__(self, user_id):
        super().__init__(label="üîÑ Refresh", style=discord.ButtonStyle.secondary)
        self.user_id = user_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing your cases...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            q = db.collection(COURT_CASES_COLLECTION).where(filter=FieldFilter('plaintiffId', '==', self.user_id))
            cases = []
            for doc in q.stream():
                data = doc.to_dict()
                status_emoji = {
                    'pending': '‚è≥',
                    'sentenced': '‚öñÔ∏è',
                    'closed': '‚úÖ',
                    'dismissed': 'üö´',
                    'appeal': 'üì¢'
                }.get(data.get('status'), '‚ùì')
                
                case_type = data.get('caseType', 'Unknown')
                type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
                
                cases.append(
                    f"{status_emoji} {type_emoji} **Case #{data.get('caseId')}** - {data.get('defendantIgn')}\n"
                    f"   Type: {case_type} | Status: {data.get('status').title()} | Charges: {data.get('charges')[:40]}..."
                )
            
            if not cases:
                return await interaction.edit_original_response(content="üìã You have not filed any cases.")
            
            embed = discord.Embed(
                title=f"‚öñÔ∏è Your Filed Cases ({len(cases)}) - REFRESHED",
                description="\n\n".join(cases[:10]),
                color=0x008b8b
            )
            if len(cases) > 10:
                embed.set_footer(text=f"Showing 10 of {len(cases)} cases | Click refresh to update")
            else:
                embed.set_footer(text="üîÑ Live data | Click refresh to update")
            
            await interaction.edit_original_response(embed=embed)
        except Exception as e:
            print(f"[ERR] Refresh my cases failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

class MyCasesView(ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)  # 5 minute timeout
        self.add_item(RefreshMyCasesButton(user_id))

class ViewMyCasesButton(ui.Button):
    def __init__(self):
        super().__init__(label="üìÇ My Cases", style=discord.ButtonStyle.secondary, custom_id="court_view_my_cases")
    
    async def callback(self, interaction: discord.Interaction):
        try:
            await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        except Exception as e:
            print(f"[ERR] Failed to defer interaction: {e}")
            return
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        # Find cases where user is plaintiff
        cases = []
        try:
            q = db.collection(COURT_CASES_COLLECTION).where(filter=FieldFilter('plaintiffId', '==', interaction.user.id))
            for doc in q.stream():
                data = doc.to_dict()
                status_emoji = {
                    'pending': '‚è≥',
                    'sentenced': '‚öñÔ∏è',
                    'closed': '‚úÖ',
                    'dismissed': 'üö´',
                    'appeal': 'üì¢'
                }.get(data.get('status'), '‚ùì')
                
                case_type = data.get('caseType', 'Unknown')
                type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
                
                cases.append(
                    f"{status_emoji} {type_emoji} **Case #{data.get('caseId')}** - {data.get('defendantIgn')}\n"
                    f"   Type: {case_type} | Status: {data.get('status').title()} | Charges: {data.get('charges')[:40]}..."
                )
            
            if not cases:
                return await interaction.edit_original_response(content="üìã You have not filed any cases.")
            
            embed = discord.Embed(
                title=f"‚öñÔ∏è Your Filed Cases ({len(cases)})",
                description="\n\n".join(cases[:10]),
                color=0x008b8b
            )
            if len(cases) > 10:
                embed.set_footer(text=f"Showing 10 of {len(cases)} cases | Click refresh to update")
            else:
                embed.set_footer(text="üîÑ Click refresh button below to update")
            
            # Add refresh button view
            view = MyCasesView(interaction.user.id)
            await interaction.edit_original_response(embed=embed, view=view)
        except Exception as e:
            print(f"[ERR] Failed to fetch user cases: {e}")
            try:
                await interaction.edit_original_response(content="‚ùå Failed to retrieve cases.")
            except:
                pass

class RefreshAllCasesButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh", style=discord.ButtonStyle.secondary)
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing all cases...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            pending_cases = []
            other_cases = []
            
            for doc in db.collection(COURT_CASES_COLLECTION).stream():
                data = doc.to_dict()
                status_emoji = {
                    'pending': '‚è≥',
                    'sentenced': '‚öñÔ∏è',
                    'closed': '‚úÖ',
                    'dismissed': 'üö´',
                    'appeal': 'üì¢'
                }.get(data.get('status'), '‚ùì')
                
                case_type = data.get('caseType', 'Unknown')
                type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
                
                case_line = (
                    f"{status_emoji} {type_emoji} **Case #{data.get('caseId')}** - {data.get('defendantIgn')}\n"
                    f"   Type: {case_type} | Plaintiff: {data.get('plaintiff')} | Status: {data.get('status').title()}"
                )
                
                if data.get('status') == 'pending':
                    pending_cases.append(case_line)
                else:
                    other_cases.append(case_line)
            
            cases = pending_cases + other_cases
            
            if not cases:
                return await interaction.edit_original_response(content="üìã No cases found in the system.")
            
            embed = discord.Embed(
                title=f"‚öñÔ∏è All Court Cases ({len(cases)}) - REFRESHED",
                description="\n\n".join(cases[:15]),
                color=0x008b8b
            )
            if len(cases) > 15:
                embed.set_footer(text=f"Showing 15 of {len(cases)} cases | Click refresh to update")
            else:
                embed.set_footer(text="üîÑ Live data | Click refresh to update")
            
            await interaction.edit_original_response(embed=embed)
        except Exception as e:
            print(f"[ERR] Refresh all cases failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

class AllCasesView(ui.View):
    def __init__(self):
        super().__init__(timeout=300)  # 5 minute timeout
        self.add_item(RefreshAllCasesButton())

class ViewAllCasesButton(ui.Button):
    def __init__(self):
        super().__init__(label="üìö Archive", style=discord.ButtonStyle.secondary, custom_id="court_view_all_cases")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        # Fetch all cases
        cases = []
        try:
            # Get pending cases first, then others
            pending_cases = []
            other_cases = []
            
            for doc in db.collection(COURT_CASES_COLLECTION).stream():
                data = doc.to_dict()
                status_emoji = {
                    'pending': '‚è≥',
                    'sentenced': '‚öñÔ∏è',
                    'closed': '‚úÖ',
                    'dismissed': 'üö´',
                    'appeal': 'üì¢'
                }.get(data.get('status'), '‚ùì')
                
                case_type = data.get('caseType', 'Unknown')
                type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
                
                case_line = (
                    f"{status_emoji} {type_emoji} **Case #{data.get('caseId')}** - {data.get('defendantIgn')}\n"
                    f"   Type: {case_type} | Plaintiff: {data.get('plaintiff')} | Status: {data.get('status').title()}"
                )
                
                if data.get('status') == 'pending':
                    pending_cases.append(case_line)
                else:
                    other_cases.append(case_line)
            
            # Combine pending first, then others
            cases = pending_cases + other_cases
            
            if not cases:
                return await interaction.edit_original_response(content="üìã No cases found in the system.")
            
            # Discord embed description limit is 4096 characters
            # Each case is ~150 chars, so we can fit ~25 cases safely
            max_cases_to_show = 50  # Increased from 15
            description_text = "\n\n".join(cases[:max_cases_to_show])
            
            # If description is too long, truncate
            if len(description_text) > 3900:
                # Find how many cases fit in 3900 chars
                truncated_cases = []
                char_count = 0
                for case in cases:
                    if char_count + len(case) + 2 > 3900:  # +2 for \n\n
                        break
                    truncated_cases.append(case)
                    char_count += len(case) + 2
                description_text = "\n\n".join(truncated_cases)
                max_cases_to_show = len(truncated_cases)
            
            embed = discord.Embed(
                title=f"‚öñÔ∏è All Court Cases ({len(cases)})",
                description=description_text,
                color=0x008b8b
            )
            if len(cases) > max_cases_to_show:
                embed.set_footer(text=f"Showing {max_cases_to_show} of {len(cases)} cases | Use /court search to find specific cases")
            else:
                embed.set_footer(text="üîÑ Click refresh button below to update")
            
            # Add refresh button view
            view = AllCasesView()
            await interaction.edit_original_response(embed=embed, view=view)
        except Exception as e:
            print(f"[ERR] Failed to fetch all cases: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to retrieve cases.")

class ViewClosedCasesButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîí Resolved", style=discord.ButtonStyle.secondary, custom_id="court_view_closed_cases")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Loading closed cases...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Fetch only closed/dismissed/sentenced cases
            closed_statuses = ['closed', 'dismissed', 'sentenced']
            cases = []
            
            for doc in db.collection(COURT_CASES_COLLECTION).stream():
                data = doc.to_dict()
                status = data.get('status', '')
                if status not in closed_statuses:
                    continue
                
                status_emoji = {
                    'sentenced': '‚öñÔ∏è',
                    'closed': '‚úÖ',
                    'dismissed': 'üö´'
                }.get(status, '‚ùì')
                
                case_type = data.get('caseType', 'Unknown')
                type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
                
                verdict = data.get('verdict', '')
                verdict_str = f" | Verdict: {verdict}" if verdict else ""
                
                case_line = (
                    f"{status_emoji} {type_emoji} **Case #{data.get('caseId')}** - {data.get('defendantIgn')}\n"
                    f"   Type: {case_type} | Status: {status.title()}{verdict_str}"
                )
                cases.append(case_line)
            
            if not cases:
                return await interaction.edit_original_response(content="üìÅ No closed cases found.")
            
            # Limit description length
            description_text = "\n\n".join(cases[:30])
            if len(description_text) > 3900:
                truncated_cases = []
                char_count = 0
                for case in cases:
                    if char_count + len(case) + 2 > 3900:
                        break
                    truncated_cases.append(case)
                    char_count += len(case) + 2
                description_text = "\n\n".join(truncated_cases)
            
            embed = discord.Embed(
                title=f"üîí Resolved Cases ({len(cases)})",
                description=description_text,
                color=0x607d8b
            )
            if len(cases) > 30:
                embed.set_footer(text=f"Showing 30 of {len(cases)} closed cases")
            
            await interaction.edit_original_response(embed=embed)
        except Exception as e:
            print(f"[ERR] Failed to fetch closed cases: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to retrieve closed cases.")


class ViewLawyersButton(ui.Button):
    def __init__(self):
        super().__init__(label="üìã Lawyer List", style=discord.ButtonStyle.secondary, custom_id="view_lawyers_list", row=2)
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        
        if not db:
            return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
        
        try:
            lawyers = await asyncio.to_thread(lambda: list(db.collection(LAWYERS_COLLECTION).stream()))
            
            if not lawyers:
                return await interaction.followup.send("üìã No lawyers registered yet.", ephemeral=True)
            
            attorneys = []
            public_defenders = []
            prosecutors = []
            
            for doc in lawyers:
                data = doc.to_dict()
                name = data.get('ign', data.get('discordName', 'Unknown'))
                bar_num = data.get('barNumber', 'N/A')
                wins = data.get('wins', 0)
                losses = data.get('losses', 0)
                ltype = data.get('lawyerType', 'attorney')
                
                entry = f"**{name}** (Bar #{bar_num}) - W/L: {wins}/{losses}"
                
                if ltype == 'attorney':
                    attorneys.append(entry)
                elif ltype == 'public_defender':
                    public_defenders.append(entry)
                elif ltype == 'prosecutor':
                    prosecutors.append(entry)
            
            embed = discord.Embed(
                title="‚öñÔ∏è FLORAB√çS BAR ASSOCIATION",
                description="*Licensed Legal Practitioners*",
                color=0x1a237e
            )
            
            if attorneys:
                embed.add_field(
                    name=f"üëî Private Attorneys ({len(attorneys)})",
                    value="\n".join(attorneys[:10]) or "None",
                    inline=False
                )
            
            if public_defenders:
                embed.add_field(
                    name=f"üõ°Ô∏è Public Defenders ({len(public_defenders)})",
                    value="\n".join(public_defenders[:10]) or "None",
                    inline=False
                )
            
            if prosecutors:
                embed.add_field(
                    name=f"üéØ State Prosecutors ({len(prosecutors)})",
                    value="\n".join(prosecutors[:10]) or "None",
                    inline=False
                )
            
            embed.set_footer(text=f"Total: {len(lawyers)} registered lawyers")
            
            await interaction.followup.send(embed=embed, ephemeral=True)
            
        except Exception as e:
            print(f"[ERR] View lawyers failed: {e}")
            await interaction.followup.send(f"‚ùå Failed to load lawyers: {str(e)}", ephemeral=True)


class RefreshCourtButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Cases", style=discord.ButtonStyle.secondary, custom_id="refresh_court")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing court cases...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Get all court cases
            all_cases = list(db.collection(COURT_CASES_COLLECTION).stream())
            
            if not all_cases:
                embed = discord.Embed(
                    title="‚öñÔ∏è Court Cases Refreshed",
                    description="No cases filed in the system.",
                    color=0x008b8b
                )
                return await interaction.edit_original_response(embed=embed)
            
            # Separate by status
            pending = []
            active = []
            closed = []
            
            for case_doc in all_cases:
                data = case_doc.to_dict()
                case_id = data.get('caseId', '???')
                case_type = data.get('caseType', 'Unknown')
                status = data.get('status', 'unknown')
                
                case_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìã"
                
                if status == 'pending':
                    pending.append(f"{case_emoji} **Case #{case_id}** - {status.title()}")
                elif status in ['open', 'in_trial']:
                    active.append(f"{case_emoji} **Case #{case_id}** - {status.title()}")
                else:
                    closed.append(f"{case_emoji} **Case #{case_id}** - {status.title()}")
            
            embed = discord.Embed(
                title="‚öñÔ∏è COURT SYSTEM - LIVE DOCKET",
                description=f"*{len(all_cases)} total cases in the system*\n\n",
                color=0x008b8b
            )
            
            if pending:
                embed.add_field(
                    name="‚è≥ PENDING CASES",
                    value="\n".join(pending[:5]) or "None",
                    inline=False
                )
            
            if active:
                embed.add_field(
                    name="‚öñÔ∏è ACTIVE TRIALS",
                    value="\n".join(active[:5]) or "None",
                    inline=False
                )
            
            embed.set_footer(text=f"üìä Pending: {len(pending)} | Active: {len(active)} | Closed: {len(closed)}")
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Refresh court failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh cases: {str(e)}")

class ActiveCasesView(ui.View):
    def __init__(self):
        super().__init__(timeout=300)  # 5 minute timeout
        self.add_item(RefreshActiveCasesButton())

class ViewActiveCasesButton(ui.Button):
    """Button to view only active/in-progress cases (pending, in_trial, open, appeal)"""
    def __init__(self):
        super().__init__(label="üü¢ Open Docket", style=discord.ButtonStyle.success, custom_id="court_view_active_cases")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Loading active cases...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        # Fetch only active cases (not closed/sentenced)
        active_statuses = ['pending', 'in_trial', 'open', 'appeal']
        cases = []
        
        try:
            pending_cases = []
            other_active_cases = []
            
            for doc in db.collection(COURT_CASES_COLLECTION).stream():
                data = doc.to_dict()
                status = data.get('status', 'unknown')
                
                # Skip closed/sentenced cases
                if status not in active_statuses:
                    continue
                
                status_emoji = {
                    'pending': '‚è≥',
                    'in_trial': '‚öñÔ∏è',
                    'open': 'üîì',
                    'appeal': 'üì¢'
                }.get(status, '‚ùì')
                
                case_type = data.get('caseType', 'Unknown')
                type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
                
                case_line = (
                    f"{status_emoji} {type_emoji} **Case #{data.get('caseId')}** - {data.get('defendantIgn')}\n"
                    f"   Type: {case_type} | Plaintiff: {data.get('plaintiff')} | Status: {status.replace('_', ' ').title()}"
                )
                
                if status == 'pending':
                    pending_cases.append(case_line)
                else:
                    other_active_cases.append(case_line)
            
            # Combine pending first, then other active cases
            cases = pending_cases + other_active_cases
            
            if not cases:
                return await interaction.edit_original_response(content="‚úÖ **No active cases!**\n\nAll cases have been resolved or sentenced.")
            
            # Discord embed description limit is 4096 characters
            max_cases_to_show = 50
            description_text = "\n\n".join(cases[:max_cases_to_show])
            
            # If description is too long, truncate
            if len(description_text) > 3900:
                truncated_cases = []
                char_count = 0
                for case in cases:
                    if char_count + len(case) + 2 > 3900:
                        break
                    truncated_cases.append(case)
                    char_count += len(case) + 2
                description_text = "\n\n".join(truncated_cases)
                max_cases_to_show = len(truncated_cases)
            
            embed = discord.Embed(
                title=f"üü¢ Open Docket ({len(cases)} pending)",
                description=description_text,
                color=0xFF4444
            )
            if len(cases) > max_cases_to_show:
                embed.set_footer(text=f"Showing {max_cases_to_show} of {len(cases)} active cases | Excludes closed/sentenced cases")
            else:
                embed.set_footer(text="üîÑ Click refresh button below to update | Excludes closed/sentenced cases")
            
            # Add refresh button view
            view = ActiveCasesView()
            await interaction.edit_original_response(embed=embed, view=view)
        except Exception as e:
            print(f"[ERR] Failed to fetch active cases: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content="‚ùå Failed to retrieve active cases.")

class RefreshActiveCasesButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh", style=discord.ButtonStyle.secondary, custom_id="refresh_active_cases")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing active cases...", ephemeral=True)
        
        if not db:
            return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Re-fetch active cases
            active_statuses = ['pending', 'in_trial', 'open', 'appeal']
            cases = []
            pending_cases = []
            other_active_cases = []
            
            for doc in db.collection(COURT_CASES_COLLECTION).stream():
                data = doc.to_dict()
                status = data.get('status', 'unknown')
                
                if status not in active_statuses:
                    continue
                
                status_emoji = {
                    'pending': '‚è≥',
                    'in_trial': '‚öñÔ∏è',
                    'open': 'üîì',
                    'appeal': 'üì¢'
                }.get(status, '‚ùì')
                
                case_type = data.get('caseType', 'Unknown')
                type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
                
                case_line = (
                    f"{status_emoji} {type_emoji} **Case #{data.get('caseId')}** - {data.get('defendantIgn')}\n"
                    f"   Type: {case_type} | Plaintiff: {data.get('plaintiff')} | Status: {status.replace('_', ' ').title()}"
                )
                
                if status == 'pending':
                    pending_cases.append(case_line)
                else:
                    other_active_cases.append(case_line)
            
            cases = pending_cases + other_active_cases
            
            if not cases:
                # Success! Show confirmation then auto-delete after 2 seconds
                confirmation_msg = await interaction.followup.send(content="‚úÖ No active cases! All cases resolved.", ephemeral=True)
                await asyncio.sleep(2)
                try:
                    await confirmation_msg.delete()
                except:
                    pass
                return
            
            # Success! Show confirmation then auto-delete after 2 seconds
            confirmation_msg = await interaction.followup.send(content=f"‚úÖ Active cases refreshed! ({len(cases)} active)", ephemeral=True)
            await asyncio.sleep(2)
            try:
                await confirmation_msg.delete()
            except:
                pass
            
        except Exception as e:
            print(f"[ERR] Refresh active cases failed: {e}")
            import traceback
            traceback.print_exc()
            await interaction.followup.send(content=f"‚ùå Failed to refresh: {str(e)}", ephemeral=True)

# ========================================
# LAWYER CASE NOTIFICATION SYSTEM
# ========================================

class LawyerCaseClaimView(ui.View):
    """View for lawyers to claim defense/prosecution roles on a case"""
    def __init__(self, case_id: str, case_type: str):
        super().__init__(timeout=None)
        self.case_id = case_id
        self.case_type = case_type
        
        # Defense button (for both criminal and civil)
        defense_label = "üõ°Ô∏è Claim Defense" if case_type == "Criminal" else "üõ°Ô∏è Represent Respondent"
        defense_btn = ui.Button(label=defense_label, style=discord.ButtonStyle.primary, custom_id=f"lawyer_claim_defense_{case_id}")
        defense_btn.callback = self.claim_defense
        self.add_item(defense_btn)
        
        # Prosecution/Plaintiff button
        if case_type == "Criminal":
            pros_btn = ui.Button(label="‚öîÔ∏è Claim Prosecutor", style=discord.ButtonStyle.danger, custom_id=f"lawyer_claim_prosecutor_{case_id}")
            pros_btn.callback = self.claim_prosecutor
            self.add_item(pros_btn)
        else:
            plaintiff_btn = ui.Button(label="üìú Represent Petitioner", style=discord.ButtonStyle.secondary, custom_id=f"lawyer_claim_petitioner_{case_id}")
            plaintiff_btn.callback = self.claim_petitioner
            self.add_item(plaintiff_btn)
        
        # View case button
        view_btn = ui.Button(label="üìã View Case Details", style=discord.ButtonStyle.secondary, custom_id=f"lawyer_view_case_{case_id}")
        view_btn.callback = self.view_case
        self.add_item(view_btn)
    
    async def _check_lawyer(self, interaction: discord.Interaction) -> dict:
        """Check if user is a registered lawyer and return their data"""
        if not db:
            return None
        try:
            lawyers = list(db.collection(LAWYERS_COLLECTION).where(
                filter=FieldFilter('discordId', '==', interaction.user.id)
            ).limit(1).stream())
            if lawyers:
                return lawyers[0].to_dict()
        except:
            pass
        return None
    
    async def _add_to_thread(self, interaction: discord.Interaction, case_id: str):
        """Add lawyer to courtroom thread"""
        try:
            case_doc = db.collection(COURT_CASES_COLLECTION).document(case_id).get()
            if case_doc.exists:
                thread_id = case_doc.to_dict().get('courtroomThreadId')
                if thread_id:
                    thread = interaction.guild.get_thread(thread_id)
                    if not thread:
                        thread = await interaction.guild.fetch_channel(thread_id)
                    if thread:
                        if thread.archived:
                            await thread.edit(archived=False)
                        await thread.add_user(interaction.user)
                        return thread
        except Exception as e:
            print(f"[WARN] Could not add lawyer to thread: {e}")
        return None
    
    async def claim_defense(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Claiming defense role...", ephemeral=True)
        
        lawyer_data = await self._check_lawyer(interaction)
        if not lawyer_data:
            return await interaction.edit_original_response(content="‚ùå You must be a registered lawyer to claim cases. Use the court panel to register.")
        
        try:
            case_doc = db.collection(COURT_CASES_COLLECTION).document(self.case_id).get()
            if not case_doc.exists:
                return await interaction.edit_original_response(content=f"‚ùå Case {self.case_id} not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if already claimed
            if case_data.get('defenseAttorneyId'):
                existing = case_data.get('defenseAttorney', 'Someone')
                return await interaction.edit_original_response(content=f"‚ùå Defense already claimed by {existing}")
            
            # Claim the role
            case_doc.reference.update({
                'defenseAttorneyId': interaction.user.id,
                'defenseAttorney': str(interaction.user),
                'defenseBarNumber': lawyer_data.get('barNumber', 'N/A'),
                'defenseClaimedAt': datetime.now(timezone.utc)
            })
            
            # Add to thread
            thread = await self._add_to_thread(interaction, self.case_id)
            thread_msg = f"\n\nüëâ {thread.mention}" if thread else ""
            
            # Post in thread
            if thread:
                await thread.send(f"üõ°Ô∏è **Defense Attorney Assigned:** {interaction.user.mention} (Bar #{lawyer_data.get('barNumber', 'N/A')})")
            
            await interaction.edit_original_response(
                content=f"‚úÖ **You are now the Defense Attorney for Case {self.case_id}!**\n\nYou've been added to the courtroom thread.{thread_msg}"
            )
            
            # Update the notification message
            try:
                embed = interaction.message.embeds[0] if interaction.message.embeds else None
                if embed:
                    embed.add_field(name="üõ°Ô∏è Defense", value=f"{interaction.user.mention}", inline=True)
                    await interaction.message.edit(embed=embed)
            except:
                pass
            
            print(f"[COURT] {interaction.user} claimed defense for case {self.case_id}")
            
        except Exception as e:
            print(f"[ERR] Claim defense failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to claim: {str(e)}")
    
    async def claim_prosecutor(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Claiming prosecutor role...", ephemeral=True)
        
        lawyer_data = await self._check_lawyer(interaction)
        if not lawyer_data:
            return await interaction.edit_original_response(content="‚ùå You must be a registered lawyer to claim cases.")
        
        # Allow any lawyer type to claim prosecution (attorney, prosecutor, or public_defender)
        # Only requirement is being a registered lawyer
        
        try:
            case_doc = db.collection(COURT_CASES_COLLECTION).document(self.case_id).get()
            if not case_doc.exists:
                return await interaction.edit_original_response(content=f"‚ùå Case {self.case_id} not found.")
            
            case_data = case_doc.to_dict()
            
            if case_data.get('prosecutorId'):
                existing = case_data.get('prosecutor', 'Someone')
                return await interaction.edit_original_response(content=f"‚ùå Prosecutor already claimed by {existing}")
            
            case_doc.reference.update({
                'prosecutorId': interaction.user.id,
                'prosecutor': str(interaction.user),
                'prosecutorBarNumber': lawyer_data.get('barNumber', 'N/A'),
                'prosecutorClaimedAt': datetime.now(timezone.utc)
            })
            
            thread = await self._add_to_thread(interaction, self.case_id)
            thread_msg = f"\n\nüëâ {thread.mention}" if thread else ""
            
            if thread:
                await thread.send(f"‚öîÔ∏è **Prosecutor Assigned:** {interaction.user.mention} (Bar #{lawyer_data.get('barNumber', 'N/A')})")
            
            await interaction.edit_original_response(
                content=f"‚úÖ **You are now the Prosecutor for Case {self.case_id}!**{thread_msg}"
            )
            
            try:
                embed = interaction.message.embeds[0] if interaction.message.embeds else None
                if embed:
                    embed.add_field(name="‚öîÔ∏è Prosecutor", value=f"{interaction.user.mention}", inline=True)
                    await interaction.message.edit(embed=embed)
            except:
                pass
            
            print(f"[COURT] {interaction.user} claimed prosecutor for case {self.case_id}")
            
        except Exception as e:
            print(f"[ERR] Claim prosecutor failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to claim: {str(e)}")
    
    async def claim_petitioner(self, interaction: discord.Interaction):
        """For civil cases - represent the petitioner/plaintiff"""
        await interaction.response.send_message("‚è≥ Claiming petitioner counsel role...", ephemeral=True)
        
        lawyer_data = await self._check_lawyer(interaction)
        if not lawyer_data:
            return await interaction.edit_original_response(content="‚ùå You must be a registered lawyer to claim cases.")
        
        try:
            case_doc = db.collection(COURT_CASES_COLLECTION).document(self.case_id).get()
            if not case_doc.exists:
                return await interaction.edit_original_response(content=f"‚ùå Case {self.case_id} not found.")
            
            case_data = case_doc.to_dict()
            
            if case_data.get('petitionerCounselId'):
                existing = case_data.get('petitionerCounsel', 'Someone')
                return await interaction.edit_original_response(content=f"‚ùå Petitioner counsel already claimed by {existing}")
            
            case_doc.reference.update({
                'petitionerCounselId': interaction.user.id,
                'petitionerCounsel': str(interaction.user),
                'petitionerCounselBarNumber': lawyer_data.get('barNumber', 'N/A'),
                'petitionerCounselClaimedAt': datetime.now(timezone.utc)
            })
            
            thread = await self._add_to_thread(interaction, self.case_id)
            thread_msg = f"\n\nüëâ {thread.mention}" if thread else ""
            
            if thread:
                await thread.send(f"üìú **Petitioner Counsel Assigned:** {interaction.user.mention} (Bar #{lawyer_data.get('barNumber', 'N/A')})")
            
            await interaction.edit_original_response(
                content=f"‚úÖ **You are now representing the Petitioner in Case {self.case_id}!**{thread_msg}"
            )
            
            print(f"[COURT] {interaction.user} claimed petitioner counsel for case {self.case_id}")
            
        except Exception as e:
            print(f"[ERR] Claim petitioner counsel failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to claim: {str(e)}")
    
    async def view_case(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Loading case details...", ephemeral=True)
        
        try:
            case_doc = db.collection(COURT_CASES_COLLECTION).document(self.case_id).get()
            if not case_doc.exists:
                return await interaction.edit_original_response(content=f"‚ùå Case {self.case_id} not found.")
            
            case_data = case_doc.to_dict()
            
            case_type_emoji = "‚öîÔ∏è" if case_data.get('caseType') == "Criminal" else "üìú"
            
            embed = discord.Embed(
                title=f"{case_type_emoji} Case Details: {self.case_id}",
                color=0xDC143C if case_data.get('caseType') == "Criminal" else 0x607D8B
            )
            embed.add_field(name="Type", value=case_data.get('caseType', 'Unknown'), inline=True)
            embed.add_field(name="Status", value=case_data.get('status', 'Unknown').title(), inline=True)
            embed.add_field(name="Severity", value=case_data.get('severity', 'Normal'), inline=True)
            embed.add_field(name="Defendant", value=case_data.get('defendantIgn', 'Unknown'), inline=True)
            embed.add_field(name="Plaintiff", value=case_data.get('plaintiff', 'Unknown'), inline=True)
            embed.add_field(name="Category", value=case_data.get('category', 'N/A'), inline=True)
            embed.add_field(name="Charges/Complaint", value=case_data.get('charges', 'N/A')[:500], inline=False)
            
            # Show current assignments
            assignments = []
            if case_data.get('defenseAttorney'):
                assignments.append(f"üõ°Ô∏è Defense: {case_data['defenseAttorney']}")
            if case_data.get('prosecutor'):
                assignments.append(f"‚öîÔ∏è Prosecutor: {case_data['prosecutor']}")
            if case_data.get('petitionerCounsel'):
                assignments.append(f"üìú Petitioner Counsel: {case_data['petitionerCounsel']}")
            if case_data.get('judge'):
                assignments.append(f"üë®‚Äç‚öñÔ∏è Judge: {case_data['judge']}")
            
            if assignments:
                embed.add_field(name="Current Assignments", value="\n".join(assignments), inline=False)
            
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] View case failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")


async def notify_lawyers_of_case(guild: discord.Guild, case_id: str, case_data: dict):
    """Post a notification to the lawyer channel when a new case is filed"""
    if not LAWYER_NOTIFICATIONS_CHANNEL_ID or LAWYER_NOTIFICATIONS_CHANNEL_ID == 0:
        return  # No channel configured
    
    try:
        channel = guild.get_channel(LAWYER_NOTIFICATIONS_CHANNEL_ID)
        if not channel:
            print(f"[WARN] Lawyer notification channel {LAWYER_NOTIFICATIONS_CHANNEL_ID} not found")
            return
        
        case_type = case_data.get('caseType', 'Unknown')
        case_type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
        severity = case_data.get('severity', 'Normal')
        severity_emoji = "‚ö†Ô∏è" if severity == "Serious" else "‚öñÔ∏è"
        
        embed = discord.Embed(
            title=f"üì¢ NEW CASE NEEDS COUNSEL: {case_id}",
            description=(
                f"**{case_type_emoji} {case_type} Case** | {severity_emoji} {severity}\n\n"
                f"**Defendant:** {case_data.get('defendantIgn', 'Unknown')}\n"
                f"**Plaintiff:** {case_data.get('plaintiff', 'Unknown')}\n"
                f"**Category:** {case_data.get('category', 'N/A')}\n"
                f"**Charges:** {case_data.get('charges', 'N/A')[:300]}...\n\n"
                f"*Click below to claim a role on this case!*"
            ),
            color=0xDC143C if case_type == "Criminal" else 0x607D8B
        )
        embed.set_footer(text=f"Filed {datetime.now(EST).strftime('%b %d, %Y at %I:%M %p EST')}")
        
        view = LawyerCaseClaimView(case_id, case_type)
        await channel.send(embed=embed, view=view)
        print(f"[COURT] Posted lawyer notification for case {case_id}")
        
    except Exception as e:
        print(f"[ERR] Failed to notify lawyers: {e}")


class OpenThreadButton(ui.Button):
    """Button to get a link to a case's courtroom thread"""
    def __init__(self):
        super().__init__(label="üîó Open Thread", style=discord.ButtonStyle.secondary, custom_id="court_open_thread")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_modal(OpenThreadModal())


class OpenThreadModal(ui.Modal, title="üîó Open Case Thread"):
    case_id = ui.TextInput(
        label="Case ID",
        placeholder="e.g. CR-ABC123 or CV-XYZ789",
        max_length=20,
        required=True
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üîç Finding thread...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_id = self.case_id.value.strip().upper()
            
            # Get case from database
            case_doc = db.collection(COURT_CASES_COLLECTION).document(case_id).get()
            if not case_doc.exists:
                return await interaction.edit_original_response(content=f"‚ùå Case `{case_id}` not found.")
            
            case_data = case_doc.to_dict()
            thread_id = case_data.get('courtroomThreadId')
            
            if not thread_id:
                return await interaction.edit_original_response(
                    content=f"‚ùå Case `{case_id}` doesn't have a courtroom thread yet.\n\nUse `/court create_thread case_id:{case_id}` to create one."
                )
            
            # Try to get the thread
            thread = interaction.guild.get_thread(thread_id)
            if not thread:
                try:
                    thread = await interaction.guild.fetch_channel(thread_id)
                except:
                    return await interaction.edit_original_response(
                        content=f"‚ùå Thread for case `{case_id}` could not be found. It may have been deleted or archived."
                    )
            
            # Unarchive if needed
            if thread.archived:
                try:
                    await thread.edit(archived=False)
                except:
                    pass
            
            # Check if user has access, try to add them
            try:
                await thread.add_user(interaction.user)
            except:
                pass  # May already be in thread or no permission
            
            await interaction.edit_original_response(
                content=f"‚úÖ **Case {case_id} Thread**\n\nüëâ {thread.mention}\n\nClick the link above to open the courtroom."
            )
            
        except Exception as e:
            print(f"[ERR] Failed to open thread: {e}")
            await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")


class AppealCaseButton(ui.Button):
    """Button to file an appeal from the court panel"""
    def __init__(self):
        super().__init__(label="üì¢ Appeal Case", style=discord.ButtonStyle.danger, custom_id="court_appeal_case")
    
    async def callback(self, interaction: discord.Interaction):
        # Show modal to enter case ID
        await interaction.response.send_modal(AppealCaseModal())


class AppealCaseModal(ui.Modal, title="üì¢ File an Appeal"):
    case_id = ui.TextInput(
        label="Case ID",
        placeholder="e.g. CR-ABC123 or CV-XYZ789",
        max_length=20,
        required=True
    )
    reason = ui.TextInput(
        label="Appeal Reason",
        style=discord.TextStyle.paragraph,
        placeholder="Explain why you are appealing this verdict...",
        max_length=1000,
        required=True
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üì¢ Processing appeal...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_id = self.case_id.value.strip().upper()
            
            # Get case from database
            case_doc = db.collection(COURT_CASES_COLLECTION).document(case_id).get()
            if not case_doc.exists:
                return await interaction.edit_original_response(content=f"‚ùå Case `{case_id}` not found.")
            
            case_data = case_doc.to_dict()
            
            # Check if user is defendant or petitioner
            defendant_id = case_data.get('defendantDiscordId')
            petitioner_id = case_data.get('filedBy')
            
            if interaction.user.id != defendant_id and interaction.user.id != petitioner_id:
                # Allow admins/magistrates to appeal on behalf
                if not any(r.id in [ADMIN_ROLE_ID, MAGISTRATE_ROLE_ID] for r in interaction.user.roles):
                    return await interaction.edit_original_response(
                        content="‚ùå Only the defendant, petitioner, or a judge can file an appeal for this case."
                    )
            
            # Check case status - must be sentenced/closed to appeal
            status = case_data.get('status', '')
            if status not in ['sentenced', 'closed']:
                return await interaction.edit_original_response(
                    content=f"‚ùå Cannot appeal a case with status `{status}`. Only sentenced or closed cases can be appealed."
                )
            
            # Check if already appealed
            if case_data.get('appealStatus'):
                return await interaction.edit_original_response(content="‚ùå This case has already been appealed.")
            
            # Check 7-day deadline
            sentenced_at = case_data.get('sentencedAt') or case_data.get('closedAt')
            if sentenced_at:
                if hasattr(sentenced_at, 'replace'):
                    sentenced_dt = sentenced_at
                else:
                    sentenced_dt = sentenced_at.to_datetime() if hasattr(sentenced_at, 'to_datetime') else datetime.fromtimestamp(sentenced_at.timestamp(), tz=timezone.utc)
                
                deadline = sentenced_dt + timedelta(days=7)
                if datetime.now(timezone.utc) > deadline:
                    deadline_est = deadline.astimezone(EST)
                    return await interaction.edit_original_response(
                        content=f"‚ùå Appeal deadline has passed. Deadline was {deadline_est.strftime('%b %d, %Y at %I:%M %p EST')}"
                    )
            
            # File the appeal
            case_doc.reference.update({
                'status': 'appeal',
                'appealStatus': 'pending',
                'appealReason': self.reason.value.strip(),
                'appealedBy': str(interaction.user),
                'appealedById': interaction.user.id,
                'appealedAt': datetime.now(timezone.utc)
            })
            
            # Post notification to court status channel
            now_est = datetime.now(EST)
            try:
                status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                if status_channel:
                    appeal_embed = discord.Embed(
                        title=f"üì¢ APPEAL FILED: Case #{case_id}",
                        description=(
                            f"**Appellant:** {interaction.user.mention}\n"
                            f"**Original Verdict:** {case_data.get('verdict', 'N/A')}\n"
                            f"**Appeal Reason:** {self.reason.value.strip()}\n\n"
                            f"*The Appeals Court will review this case.*"
                        ),
                        color=0xFFA500
                    )
                    appeal_embed.set_footer(text=f"Filed {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
                    await status_channel.send(embed=appeal_embed)
            except Exception as notify_err:
                print(f"[WARN] Could not post appeal notification: {notify_err}")
            
            await interaction.edit_original_response(
                content=f"‚úÖ **Appeal Filed Successfully!**\n\nCase `{case_id}` is now under appeal. The Appeals Court will review your case."
            )
            print(f"[OK] {interaction.user} filed appeal for case {case_id}")
            
        except Exception as e:
            print(f"[ERR] Failed to file appeal: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to file appeal: {str(e)}")


class CourtPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        # Row 1: Filing buttons
        self.add_item(FileCriminalCaseButton())
        self.add_item(FileCivilCaseButton())
        self.add_item(AppealCaseButton())        # üì¢ Appeal Case
        self.add_item(LawyerRegistrationButton())
        # Row 2: Case viewing buttons (Open/Resolved/Archive/My Cases)
        self.add_item(ViewActiveCasesButton())   # üü¢ Open Docket
        self.add_item(ViewClosedCasesButton())   # üîí Resolved
        self.add_item(ViewAllCasesButton())      # üìö Archive
        self.add_item(ViewMyCasesButton())       # üë§ My Cases
        # Row 3: Utilities
        self.add_item(OpenThreadButton())        # üîó Open Thread
        self.add_item(ViewLawyersButton())       # üìã Lawyer List
        self.add_item(RefreshCourtButton())

# Court Panel Command
@bot.tree.command(name="court_panel", description="[ADMIN ONLY] Post the interactive court panel")
async def court_panel_cmd(interaction: discord.Interaction):
    try:
        # CRITICAL: Respond IMMEDIATELY (within 3 seconds) or interaction expires
        await interaction.response.send_message("‚è≥ Creating court panel...", ephemeral=True)
        
        # Check admin
        if not has_admin_role(interaction):
            return await interaction.followup.send("‚ùå Only administrators can post the court panel.", ephemeral=True)
        
        # Count lawyers by type
        attorneys = 0
        public_defenders = 0
        prosecutors = 0
        
        if db:
            try:
                lawyers = list(db.collection(LAWYERS_COLLECTION).stream())
                for lawyer_doc in lawyers:
                    lawyer = lawyer_doc.to_dict()
                    ltype = lawyer.get('lawyerType', '')
                    if ltype == 'attorney':
                        attorneys += 1
                    elif ltype == 'public_defender':
                        public_defenders += 1
                    elif ltype == 'prosecutor':
                        prosecutors += 1
            except:
                pass
        
        # Clean embed with lawyer counts
        embed = discord.Embed(
            title="üèõÔ∏è FLORAB√çS STATE JUDICIARY",
            description=(
                "**STATE JUDICIARY OF FLORAB√çS**\n"
                "*Excellence in Justice ‚Ä¢ Integrity in Service ‚Ä¢ Equal Rights for All*\n\n"
                
                "**‚öîÔ∏è CRIMINAL DIVISION**\n"
                "Prosecute crimes against the State and its citizens\n"
                "‚ñ∏ Griefing  ‚ñ∏ Theft  ‚ñ∏ Murder  ‚ñ∏ Assault  ‚ñ∏ Vandalism\n\n"
                
                "**üìú CIVIL DIVISION**\n"
                "Resolve private disputes and contractual matters\n"
                "‚ñ∏ Contracts  ‚ñ∏ Property Rights  ‚ñ∏ Damages  ‚ñ∏ Business Disputes\n\n"
                
                "**‚öñÔ∏è THE BAR ASSOCIATION**\n"
                f"üëî Private Attorneys: **{attorneys}** licensed\n"
                f"üõ°Ô∏è Public Defenders: **{public_defenders}** on duty\n"
                f"üéØ State Prosecutors: **{prosecutors}** serving\n\n"
                
                "**HOW TO PROCEED:**\n"
                "‚ñ∏ File a Case ‚Üí Choose Criminal or Civil ‚Üí Fill Details\n"
                "‚ñ∏ Join the Bar ‚Üí Register as Attorney, Defender, or Prosecutor\n"
                "‚ñ∏ Track Cases ‚Üí View your active cases and their status\n\n"
                
                "*Presided over by the Honorable Magistrates of Florab√≠s*"
            ),
            color=0x1a237e
        )
        embed.set_footer(text="‚öñÔ∏è Florab√≠s State Judiciary ‚Ä¢ Est. 2025")
        
        # Delete old panel if exists
        if db and interaction.guild:
            try:
                current_db = await ensure_firestore()
                court_panel_doc = await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('court_panel').get())
                if court_panel_doc.exists:
                    old_data = court_panel_doc.to_dict()
                    old_channel = interaction.guild.get_channel(old_data.get('channelId'))
                    if old_channel:
                        try:
                            old_message = await old_channel.fetch_message(old_data.get('messageId'))
                            await old_message.delete()
                        except:
                            pass
            except:
                pass
        
        # Post new panel
        message = await interaction.channel.send(embed=embed, view=CourtPanel())
        
        # Save location
        if db:
            try:
                current_db = await ensure_firestore()
                await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('court_panel').set({
                    'guildId': interaction.guild.id,
                    'channelId': interaction.channel.id,
                    'messageId': message.id
                }))
            except:
                pass
        
        # Try to send success message, but don't fail if interaction expired
        try:
            await interaction.followup.send("‚úÖ Court panel posted!", ephemeral=True)
        except discord.errors.NotFound:
            # Interaction expired, but panel was posted successfully - that's fine!
            print("[INFO] Court panel posted successfully, but interaction expired before confirmation")
        
    except Exception as e:
        print(f"[ERR] Court panel command failed: {e}")
        import traceback
        traceback.print_exc()
        # Don't try to send error message if interaction expired
        if "10062" not in str(e):
            try:
                await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)
            except:
                pass

# ========================================
# BETTING PANEL - Tom Brady's Royal Betting Exchange
# ========================================

class RefreshBettingEventsButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh", style=discord.ButtonStyle.secondary)
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing events...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            open_events = list(db.collection(BETTING_EVENTS_COLLECTION).where(filter=FieldFilter('status', '==', 'open')).stream())
            
            if not open_events:
                return await interaction.edit_original_response(content="üìã No active betting events right now. Check back soon!")
            
            embed = discord.Embed(
                title=f"{BETTING_MASCOT_NAME} - REFRESHED",
                description=f"**Active Betting Events**\n\n*\"Choose wisely, citizens!\"*",
                color=BETTING_COLOR
            )
            embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
            
            est_tz = EST
            
            for event_doc in open_events[:10]:
                event_data = event_doc.to_dict()
                title = event_data.get('title', 'Unknown Event')
                total_pool = event_data.get('totalPool', 0.0)
                closes_at = event_data.get('closesAt')
                closes_est = closes_at.astimezone(est_tz)
                
                embed.add_field(
                    name=f"üé∞ {title}",
                    value=f"üí∞ Pool: {total_pool:,.0f}d | ‚è∞ Closes: {closes_est.strftime('%I:%M %p EST')}\nID: `{event_doc.id}`",
                    inline=False
                )
            
            embed.set_footer(text="üîÑ Live data | Click refresh to update")
            await interaction.edit_original_response(content=None, embed=embed)
        except Exception as e:
            print(f"[ERR] Refresh events failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

class BettingEventsView(ui.View):
    def __init__(self):
        super().__init__(timeout=300)  # 5 minute timeout
        self.add_item(RefreshBettingEventsButton())

class ViewBettingEventsButton(ui.Button):
    def __init__(self):
        super().__init__(label="üé∞ View Active Events", style=discord.ButtonStyle.success, custom_id="betting_view_events")
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        await interaction.response.send_message("‚è≥ Loading events...", ephemeral=True)
        
        try:
            # Get open events
            open_events = list(db.collection(BETTING_EVENTS_COLLECTION).where(filter=FieldFilter('status', '==', 'open')).stream())
            
            if not open_events:
                return await interaction.edit_original_response(content="üìã No active betting events right now. Check back soon!")
            
            embed = discord.Embed(
                title=f"{BETTING_MASCOT_NAME}",
                description=f"**Active Betting Events**\n\n*\"Choose wisely, citizens!\"*",
                color=BETTING_COLOR
            )
            embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
            
            est_tz = EST
            
            for event_doc in open_events[:10]:  # Show top 10
                event_data = event_doc.to_dict()
                title = event_data.get('title', 'Unknown Event')
                total_pool = event_data.get('totalPool', 0.0)
                closes_at = event_data.get('closesAt')
                closes_est = closes_at.astimezone(est_tz)
                
                embed.add_field(
                    name=f"üé∞ {title}",
                    value=f"üí∞ Pool: {total_pool:,.0f}d | ‚è∞ Closes: {closes_est.strftime('%I:%M %p EST')}\nID: `{event_doc.id}`",
                    inline=False
                )
            
            embed.set_footer(text="üîÑ Click refresh button below to update")
            
            # Add refresh button view
            view = BettingEventsView()
            await interaction.edit_original_response(content=None, embed=embed, view=view)
            
        except Exception as e:
            print(f"[ERR] View events failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to view events: {str(e)}")

class MyBettingStatsButton(ui.Button):
    def __init__(self):
        super().__init__(label="üìä My Stats", style=discord.ButtonStyle.primary, custom_id="betting_my_stats")
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        await interaction.response.send_message("‚è≥ Loading your stats...", ephemeral=True)
        
        try:
            # Get user stats
            stats_doc = get_betting_stats(interaction.user.id)
            
            if not stats_doc:
                return await interaction.edit_original_response(content="üìä You haven't placed any bets yet! Check active events above.")
            
            stats = stats_doc.to_dict()
            
            embed = discord.Embed(
                title=f"üìä Your Betting Stats",
                description=f"**{interaction.user.display_name}**",
                color=BETTING_COLOR
            )
            embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
            
            # Overall stats
            embed.add_field(
                name="üí∞ Net Profit",
                value=f"{stats.get('netProfit', 0.0):+,.2f}d",
                inline=True
            )
            embed.add_field(
                name="üìà Win Rate",
                value=f"{stats.get('winRate', 0.0):.1f}%",
                inline=True
            )
            embed.add_field(
                name="üé≤ Total Bets",
                value=f"{stats.get('totalBets', 0)} bets",
                inline=True
            )
            
            embed.add_field(
                name="‚úÖ Wins",
                value=f"{stats.get('wins', 0)}",
                inline=True
            )
            embed.add_field(
                name="‚ùå Losses",
                value=f"{stats.get('losses', 0)}",
                inline=True
            )
            embed.add_field(
                name=f"{DIAMOND_EMOJI} Total Wagered",
                value=f"{stats.get('totalWagered', 0.0):,.2f}d",
                inline=True
            )
            
            embed.add_field(
                name="üèÜ Biggest Win",
                value=f"+{stats.get('biggestWin', 0.0):,.2f}d",
                inline=True
            )
            embed.add_field(
                name="üíÄ Biggest Loss",
                value=f"-{stats.get('biggestLoss', 0.0):,.2f}d",
                inline=True
            )
            
            embed.set_footer(text="Keep betting to improve your stats!")
            
            await interaction.edit_original_response(content=None, embed=embed)
            
        except Exception as e:
            print(f"[ERR] My stats failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to view stats: {str(e)}")

class BettingLeaderboardButton(ui.Button):
    def __init__(self):
        super().__init__(label="üèÜ Leaderboard", style=discord.ButtonStyle.secondary, custom_id="betting_leaderboard")
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        await interaction.response.send_message("‚è≥ Loading leaderboard...", ephemeral=True)
        
        try:
            # Get all stats, sorted by net profit
            all_stats = list(db.collection(BETTING_LEADERBOARD_COLLECTION).stream())
            
            if not all_stats:
                return await interaction.edit_original_response(content="üèÜ No betting activity yet. Be the first to place a bet!")
            
            # Sort by net profit
            sorted_stats = sorted(all_stats, key=lambda x: x.to_dict().get('netProfit', 0.0), reverse=True)
            
            embed = discord.Embed(
                title=f"üèÜ Betting Champions",
                description=f"*\"The bold and the lucky!\"* - {BETTING_MASCOT_NAME}",
                color=BETTING_COLOR
            )
            embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
            
            # Top 10
            for i, stat_doc in enumerate(sorted_stats[:10], 1):
                stats = stat_doc.to_dict()
                user_id = stats.get('userId')
                
                try:
                    user = await interaction.client.fetch_user(user_id)
                    user_name = user.mention
                except:
                    user_name = f"<@{user_id}>"
                
                net_profit = stats.get('netProfit', 0.0)
                win_rate = stats.get('winRate', 0.0)
                total_bets = stats.get('totalBets', 0)
                biggest_win = stats.get('biggestWin', 0.0)
                
                medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"#{i}"
                
                embed.add_field(
                    name=f"{medal} {user_name}",
                    value=f"{DIAMOND_EMOJI} Profit: **{net_profit:+,.2f}d** | üìä Win Rate: {win_rate:.1f}% ({total_bets} bets)\nüèÜ Biggest Win: {biggest_win:,.2f}d",
                    inline=False
                )
            
            embed.set_footer(text="Place bets to climb the leaderboard!")
            
            await interaction.edit_original_response(content=None, embed=embed)
            
        except Exception as e:
            print(f"[ERR] Leaderboard failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to view leaderboard: {str(e)}")

# Event Selection Dropdown
class EventSelect(ui.Select):
    def __init__(self, event_list):
        options = []
        for event_id, event_data in event_list[:25]:  # Discord limit 25
            title = event_data.get('title', 'Untitled Event')
            contestants = event_data.get('contestants', [])
            pool = event_data.get('totalPool', 0)
            options.append(
                discord.SelectOption(
                    label=title,
                    description=f"Pool: {pool:,.0f}d | {len(contestants)} contestants",
                    value=event_id,
                    emoji="üé∞"
                )
            )
        super().__init__(placeholder="Select a betting event...", options=options, custom_id="event_select")
        self.events_dict = {event_id: event_data for event_id, event_data in event_list}
    
    async def callback(self, interaction: discord.Interaction):
        selected_event_id = self.values[0]
        event_data = self.events_dict[selected_event_id]
        
        # Show event details with contestant buttons
        await interaction.response.send_message(
            f"üé∞ **{event_data.get('title')}**\n\n"
            f"Pool: **{event_data.get('totalPool', 0):,.0f}d**\n"
            f"Contestants: {', '.join(event_data.get('contestants', []))}\n\n"
            f"Use `/betting` commands to place your bet on this event!")

class EventSelectionView(ui.View):
    def __init__(self, event_list):
        super().__init__(timeout=180)
        self.add_item(EventSelect(event_list))

class OpenBettingThreadButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="üé∞ Open Betting Thread",
            style=discord.ButtonStyle.primary,
            custom_id="open_betting_thread"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately
        await interaction.response.send_message("‚è≥ Opening your private betting thread...", ephemeral=True)
        
        try:
            if not db:
                return await interaction.edit_original_response(content="‚ùå Database not available.")
            
            # Check if user already has a betting thread stored
            user_bets = db.collection(BETTING_BETS_COLLECTION).where(
                filter=FieldFilter('userId', '==', interaction.user.id)
            ).limit(1).stream()
            
            existing_thread_id = None
            for bet_doc in user_bets:
                bet_data = bet_doc.to_dict()
                existing_thread_id = bet_data.get('bettingThreadId')
                if existing_thread_id:
                    break
            
            # Try to find and reuse existing thread
            thread = None
            if existing_thread_id and interaction.guild:
                try:
                    thread = interaction.guild.get_thread(existing_thread_id)
                    if not thread:
                        thread = await interaction.guild.fetch_channel(existing_thread_id)
                    
                    # Unarchive if archived
                    if thread and thread.archived:
                        await thread.edit(archived=False)
                        print(f"[BETTING] Unarchived existing thread for {interaction.user}")
                except Exception as e:
                    print(f"[BETTING] Could not find existing thread: {e}")
                    thread = None
            
            # Create new thread if none exists
            if not thread:
                thread_name = f"üé∞ {interaction.user.name}'s Betting"
                thread = await interaction.channel.create_thread(
                    name=thread_name,
                    type=discord.ChannelType.private_thread,
                    invitable=False
                )
                
                # Save thread ID to all user's bets
                if db:
                    user_bets_update = db.collection(BETTING_BETS_COLLECTION).where(
                        filter=FieldFilter('userId', '==', interaction.user.id)
                    ).stream()
                    for bet_doc in user_bets_update:
                        bet_doc.reference.update({'bettingThreadId': thread.id})
                print(f"[BETTING] Created new betting thread for {interaction.user}")
            
            # Add the user to the thread
            await thread.add_user(interaction.user)
            
            # Ping Betting Manager
            pings = []
            if interaction.guild and BETTING_MANAGER_ROLE_ID:
                pings.append(f"<@&{BETTING_MANAGER_ROLE_ID}>")
                if pings:
                    ping_text = " ".join(pings)
                    await thread.send(f"üé∞ **Betting Thread Notification**\n\n{ping_text}\n\nNew betting thread opened for {interaction.user.mention}")
            
            # Get user's betting stats
            all_user_bets = list(db.collection(BETTING_BETS_COLLECTION).where(
                filter=FieldFilter('userId', '==', interaction.user.id)
            ).stream())
            
            total_wagered = sum(bet.to_dict().get('amount', 0.0) for bet in all_user_bets if bet.to_dict().get('status') == 'paid')
            active_bets = [bet for bet in all_user_bets if bet.to_dict().get('eventStatus') == 'open']
            won_bets = [bet for bet in all_user_bets if bet.to_dict().get('result') == 'won']
            total_winnings = sum(bet.to_dict().get('payout', 0.0) for bet in won_bets)
            net_profit = total_winnings - total_wagered
            
            # Send premium welcome message in thread
            welcome_embed = discord.Embed(
                title="üé∞ TOM BRADY'S ROYAL BETTING EXCHANGE",
                description=(
                    f"*\"The house always wins... unless you do!\"*\n"
                    f"**Private Betting for {interaction.user.mention}**\n\n"
                ),
                color=0xFFD700  # Gold
            )
            
            # Betting Stats
            welcome_embed.add_field(
                name="üìä YOUR BETTING STATS",
                value=(
                    f"**Total Wagered:** {DIAMOND_EMOJI} {total_wagered:,.0f}d\n"
                    f"**Total Winnings:** {DIAMOND_EMOJI} {total_winnings:,.0f}d\n"
                    f"**Net Profit/Loss:** {DIAMOND_EMOJI} **{net_profit:+,.0f}d**\n"
                    f"**Active Bets:** {len(active_bets)} bet(s)\n"
                    f"**Win Rate:** {(len(won_bets)/len(all_user_bets)*100):.1f}%" if all_user_bets else "**Win Rate:** N/A"
                ),
                inline=False
            )
            
            # Active Bets Preview
            if active_bets:
                active_text = ""
                for bet_doc in active_bets[:3]:
                    bet = bet_doc.to_dict()
                    event_title = bet.get('eventTitle', 'Unknown Event')
                    contestant = bet.get('contestant', 'Unknown')
                    amount = bet.get('amount', 0.0)
                    status = bet.get('status', 'pending')
                    
                    status_emoji = "‚úÖ" if status == "paid" else "‚è≥"
                    active_text += f"{status_emoji} **{amount:,.0f}d** on {contestant} ({event_title[:20]}...)\n"
                
                welcome_embed.add_field(
                    name="üé≤ ACTIVE BETS",
                    value=active_text or "No active bets",
                    inline=False
                )
            
            # Betting Services
            welcome_embed.add_field(
                name="üé∞ BETTING SERVICES",
                value=(
                    "**Place Bets:**\n"
                    "‚Ä¢ Use buttons on betting panel to place bets\n"
                    "‚Ä¢ `/betting my_bets` - View all your bets\n"
                    "\n**Track Performance:**\n"
                    "‚Ä¢ `/betting my_stats` - Detailed betting statistics\n"
                    "‚Ä¢ `/betting leaderboard` - See top bettors\n"
                    "\n**Payment:**\n"
                    "‚Ä¢ Pay admin in-game after placing bet\n"
                    "‚Ä¢ Admin will confirm payment (25% house cut on winnings)"
                ),
                inline=False
            )
            
            welcome_embed.set_footer(text="üé∞ Tom Brady's Royal Betting Exchange | Private betting thread")
            
            await thread.send(embed=welcome_embed)
            
            # Notify user
            await interaction.edit_original_response(content=f"‚úÖ Your private betting thread is ready! {thread.mention}")
            
        except Exception as e:
            print(f"[ERR] Open betting thread failed: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to open betting thread: {str(e)}")

class PlaceBetPanelButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Place Bet",
            style=discord.ButtonStyle.success,
            emoji="üí∞",
            custom_id="place_bet_panel"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        await interaction.response.send_message("‚è≥ Loading betting events...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Get active betting events
            events = db.collection(BETTING_EVENTS_COLLECTION).where(filter=FieldFilter('status', '==', 'open')).stream()
            
            event_list = []
            for event in events:
                event_data = event.to_dict()
                # Check if event is still open
                closes_at = event_data.get('closesAt')
                if closes_at and closes_at.replace(tzinfo=timezone.utc) > datetime.now(timezone.utc):
                    event_list.append((event.id, event_data))
            
            if not event_list:
                return await interaction.edit_original_response(content="‚ùå No active betting events right now. Check back later!")
            
            # Create dropdown select menu
            view = EventSelectionView(event_list)
            embed = discord.Embed(
                title=f"{DIAMOND_EMOJI} Place Bet - Select Event",
                description="Choose an event to bet on from the dropdown below:",
                color=BETTING_COLOR
            )
            embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
            embed.set_footer(text="Select event, then view contestants and place your bet!")
            
            await interaction.edit_original_response(content=None, embed=embed, view=view)
            
        except Exception as e:
            print(f"[ERR] Place bet panel failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to load betting events: {str(e)}")

class CreateEventModal(ui.Modal, title="Create Betting Event"):
    event_title = ui.TextInput(
        label="Event Title",
        placeholder="e.g., 'Q4 Diamond Market Forecast' or 'Presidential Election'",
        required=True,
        max_length=100
    )
    
    contestants = ui.TextInput(
        label="Contestants (one per line)",
        placeholder="Bull Market\nBear Market\nSideways\n(minimum 2)",
        required=True,
        max_length=200,
        style=discord.TextStyle.paragraph
    )
    
    closes_in = ui.TextInput(
        label="Betting Duration (minutes) - Optional",
        placeholder="Leave blank for 30 minutes (default)",
        required=False,
        max_length=5
    )
    
    def __init__(self, event_type: str, event_label: str):
        super().__init__(title=f"Create {event_label} Event")
        self.event_type = event_type
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üé∞ Creating betting event...")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Parse contestants (one per line)
            contestant_list = [c.strip() for c in self.contestants.value.split('\n') if c.strip()]
            
            if len(contestant_list) < 2:
                return await interaction.edit_original_response(content="‚ùå You need at least 2 contestants! Put each one on a new line.")
            
            # Parse duration (default to 30 minutes if not provided)
            closes_in_minutes = 30  # Default
            if self.closes_in.value and self.closes_in.value.strip():
                try:
                    closes_in_minutes = int(self.closes_in.value)
                    if closes_in_minutes < 1 or closes_in_minutes > 10080:  # Max 1 week
                        return await interaction.edit_original_response(content="‚ùå Duration must be between 1 and 10080 minutes (1 week)!")
                except ValueError:
                    return await interaction.edit_original_response(content="‚ùå Invalid duration! Please enter a number of minutes.")
            
            now_utc = datetime.now(timezone.utc)
            closes_at = now_utc + timedelta(minutes=closes_in_minutes)
            
            # Use pre-selected event type from button
            event_type_value = self.event_type
            
            # Create event with auto-generated ID
            import uuid
            event_id = str(uuid.uuid4())[:8]  # Short ID for readability
            
            db.collection(BETTING_EVENTS_COLLECTION).document(event_id).set({
                'title': self.event_title.value,
                'eventType': event_type_value,
                'contestants': contestant_list,
                'createdBy': interaction.user.id,
                'createdAt': now_utc,
                'closesAt': closes_at,
                'status': 'open',
                'totalPool': 0.0,
                'betsPerContestant': {c: 0.0 for c in contestant_list},
                'winner': None,
                'messageId': None
            })
            
            # Create betting panel
            embed = discord.Embed(
                title=f"{BETTING_MASCOT_NAME}",
                description=f"**{self.event_title.value}**\n\n*\"Welcome, citizens! Place your bets and fortune favors the bold!\"*",
                color=BETTING_COLOR
            )
            embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
            
            # Event details
            event_icons = {
                'horse_race': 'üèá',
                'pvp_arena': '‚öîÔ∏è',
                'political': 'üèõÔ∏è',
                'other': 'üéØ'
            }
            icon = event_icons.get(event_type_value, 'üé∞')
            
            event_names = {
                'horse_race': 'üèá Horse Race',
                'pvp_arena': '‚öîÔ∏è PvP Arena',
                'political': 'üèõÔ∏è Political Bet',
                'other': 'üéØ Other Event'
            }
            
            embed.add_field(
                name=f"{icon} Event Type",
                value=event_names.get(event_type_value, 'üéØ Other Event'),
                inline=True
            )
            
            # Betting closes
            est_tz = EST
            closes_est = closes_at.astimezone(est_tz)
            embed.add_field(
                name="‚è∞ Betting Closes",
                value=closes_est.strftime('%m/%d/%y %I:%M %p EST'),
                inline=True
            )
            
            # Current odds (all even at start)
            odds_text = "\n".join([f"**{c}**: Pending (No bets yet)" for c in contestant_list])
            embed.add_field(
                name="üìä Live Odds",
                value=odds_text,
                inline=False
            )
            
            embed.add_field(
                name="üí∞ Total Pool",
                value="0 diamonds",
                inline=True
            )
            
            embed.add_field(
                name="üìà Total Bets",
                value="0 bets placed",
                inline=True
            )
            
            embed.set_footer(text=f"Event ID: {event_id} | Click 'Place Bet' to participate!")
            
            # Create button
            view = discord.ui.View(timeout=None)
            bet_button = discord.ui.Button(
                label="Place Bet",
                style=discord.ButtonStyle.success,
                custom_id=f"bet_place_{event_id}",
                emoji="üí∞"
            )
            view.add_item(bet_button)
            
            # Post to channel
            channel = interaction.channel
            message = await channel.send(embed=embed, view=view)
            
            # Save message ID
            db.collection(BETTING_EVENTS_COLLECTION).document(event_id).update({
                'messageId': message.id,
                'channelId': channel.id
            })
            
            # Ping Betting Manager role about new event
            if interaction.guild and BETTING_MANAGER_ROLE_ID:
                await channel.send(
                    f"üé∞ **New Betting Event Created**\n\n<@&{BETTING_MANAGER_ROLE_ID}>\n\n"
                    f"Event **{self.event_title.value}** (ID: `{event_id}`) is now open for betting!"
                )
            
            await interaction.edit_original_response(content=f"‚úÖ Betting event created! Event ID: `{event_id}`")
            print(f"[BETTING] Event created: {self.event_title.value} by {interaction.user}")
            
        except Exception as e:
            print(f"[ERR] Betting event creation failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to create event: {str(e)}")

class CreateEventButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Create Event",
            style=discord.ButtonStyle.primary,
            emoji="‚ûï",
            custom_id="create_event_panel"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Check admin permission
        if not has_admin_role(interaction):
            return await interaction.response.send_message("‚ùå Only administrators can create betting events.", ephemeral=True)
        
        # Show event type selection buttons
        view = EventTypeSelectionView()
        embed = discord.Embed(
            title="üé∞ Select Event Type",
            description="Choose the type of betting event to create:",
            color=BETTING_COLOR
        )
        embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# Event Type Select Menu
class EventTypeSelect(ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="Horse Race", description="Horse racing event", emoji="üèá", value="horse_race"),
            discord.SelectOption(label="PvP Arena", description="Player vs Player combat", emoji="‚öîÔ∏è", value="pvp_arena"),
            discord.SelectOption(label="Political", description="Political/Election event", emoji="üèõÔ∏è", value="political"),
            discord.SelectOption(label="Other", description="Other event type", emoji="üéØ", value="other"),
        ]
        super().__init__(placeholder="Select Event Type...", options=options, custom_id="event_type_select")
    
    async def callback(self, interaction: discord.Interaction):
        selected_type = self.values[0]
        
        # Get label for modal title
        type_labels = {
            "horse_race": "Horse Race",
            "pvp_arena": "PvP Arena",
            "political": "Political",
            "other": "Other"
        }
        event_label = type_labels.get(selected_type, "Betting")
        
        await interaction.response.send_modal(CreateEventModal(selected_type, event_label))

class EventTypeSelectionView(ui.View):
    def __init__(self):
        super().__init__(timeout=180)
        self.add_item(EventTypeSelect())

class RefreshBettingButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Events", style=discord.ButtonStyle.secondary, custom_id="refresh_betting")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing betting events...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Get all open betting events
            open_events = list(db.collection(BETTING_EVENTS_COLLECTION).where(
                filter=FieldFilter('status', '==', 'open')
            ).stream())
            
            if not open_events:
                embed = discord.Embed(
                    title="üé∞ Betting Events Refreshed",
                    description="No active betting events at the moment.\n\nAdmins can create new events using the ‚ûï Create Event button.",
                    color=BETTING_COLOR
                )
                return await interaction.edit_original_response(embed=embed)
            
            embed = discord.Embed(
                title="üé∞ Live Betting Events",
                description=f"**{len(open_events)} active event(s)** ready for betting!",
                color=BETTING_COLOR
            )
            
            for event_doc in open_events[:10]:  # Show top 10
                data = event_doc.to_dict()
                title = data.get('title', 'Unknown Event')
                event_type = data.get('eventType', 'other')
                contestants = data.get('contestants', [])
                
                # Get total pool
                bets = list(db.collection(BETTING_BETS_COLLECTION).where(
                    filter=FieldFilter('eventId', '==', event_doc.id)
                ).where(
                    filter=FieldFilter('status', '==', 'paid')
                ).stream())
                
                total_pool = sum(b.to_dict().get('amount', 0.0) for b in bets)
                
                event_emoji = {"horse_race": "üèá", "pvp_arena": "‚öîÔ∏è", "political": "üèõÔ∏è", "other": "üéØ"}.get(event_type, "üé∞")
                
                embed.add_field(
                    name=f"{event_emoji} {title}",
                    value=f"üí∞ Pool: **{total_pool:,.0f}d** | üë• Options: {len(contestants)}",
                    inline=False
                )
            
            embed.set_footer(text="Click 'Place Bet' to bet on an event | Live pool data")
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Refresh betting failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh events: {str(e)}")

class BettingPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(OpenBettingThreadButton())
        self.add_item(CreateEventButton())
        self.add_item(PlaceBetPanelButton())
        self.add_item(ViewBettingEventsButton())
        self.add_item(MyBettingStatsButton())
        self.add_item(BettingLeaderboardButton())
        self.add_item(RefreshBettingButton())

# Betting Panel Command
@bot.tree.command(name="betting_panel", description="[ADMIN ONLY] Post Tom Brady's Royal Betting Exchange panel")
async def betting_panel_cmd(interaction: discord.Interaction):
    # CRITICAL: Respond IMMEDIATELY (within 3 seconds) or interaction expires
    await interaction.response.send_message("‚è≥ Creating betting panel...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.followup.send("‚ùå Only administrators can post the betting panel.", ephemeral=True)
    
    embed = discord.Embed(
        title="üé∞ Tom Brady's Royal Betting Exchange",
        description=(
            "*\"Choose wisely, citizens!\"*\n\n"
            "\n"
        ),
        color=0xFFD700  # Gold for premium Vegas feel
    )
    
    # How to Play
    embed.add_field(
        name="üèÜ How to Win Big",
        value=(
            f"**1.** üìã **Browse Events** - View live betting opportunities\n"
            f"**2.** {DIAMOND_EMOJI} **Place Your Bet** - Pick your winner & stake diamonds\n"
            f"**3.** üí∞ **Pay In-Game** - Confirm payment with an Admin\n"
            f"**4.** üéâ **Collect Winnings** - Pari-mutuel payout system"
        ),
        inline=True
    )
    
    # Betting Features
    embed.add_field(
        name="‚ö° Exchange Features",
        value=(
            "üìä **Live Odds** - Real-time pool tracking\n"
            "üîí **Private Betting** - Secure bet placement\n"
            "üèÖ **Leaderboard** - Top bettors ranked\n"
            "üìà **Stats Tracking** - Win/loss history"
        ),
        inline=True
    )
    
    # Diamond System
    embed.add_field(
        name=f"{DIAMOND_EMOJI} Real Diamond Wagering",
        value=(
            "‚Ä¢ **100% Real Stakes** - No fake currency\n"
            "‚Ä¢ **In-Game Settlement** - Diamond payouts\n"
            "‚Ä¢ **25% House Edge** - Fair & transparent\n"
            "‚Ä¢ **Full Audit Trail** - Every bet tracked\n"
            "‚Ä¢ **Pari-Mutuel Odds** - Pool-based returns\n"
            "‚Ä¢ **Event Types:** üèá Races | ‚öîÔ∏è PvP | üèõÔ∏è Politics"
        ),
        inline=False
    )
    
    embed.set_author(name="Tom Brady - Master of Odds", icon_url=BETTING_MASCOT_AVATAR)
    embed.set_footer(text="üé∞ Fortune Favors the Bold | Tom Brady's Royal Betting Exchange | Est. 2025")
    
    # Check for existing betting panel and delete old message
    if db and interaction.guild:
        try:
            current_db = await ensure_firestore()
            betting_panel_doc = await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('betting_panel').get())
            if betting_panel_doc.exists:
                old_data = betting_panel_doc.to_dict()
                old_channel = interaction.guild.get_channel(old_data.get('channelId'))
                if old_channel:
                    try:
                        old_message = await old_channel.fetch_message(old_data.get('messageId'))
                        await old_message.delete()
                        print(f"[OK] Deleted old betting panel message")
                    except discord.NotFound:
                        print(f"[INFO] Old betting panel message already deleted")
                    except Exception as e:
                        print(f"[WARN] Could not delete old betting panel: {e}")
                else:
                    print(f"[INFO] Old betting panel channel not found, skipping deletion")
        except Exception as e:
            print(f"[WARN] Error checking for old betting panel: {e}")
    
    # Post panel
    message = await interaction.channel.send(embed=embed, view=BettingPanel())
    
    # Store panel location in Firestore
    if db:
        try:
            current_db = await ensure_firestore()
            await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('betting_panel').set({
                'guildId': interaction.guild.id,
                'channelId': interaction.channel.id,
                'messageId': message.id
            }))
            print(f"[OK] Re-registered betting panel in guild {interaction.guild.id}")
        except Exception as e:
            print(f"[WARN] Could not save betting panel location: {e}")
    
    await interaction.followup.send("‚úÖ Betting panel posted!", ephemeral=True)

# ========================================
# MARKET/BUSINESS PANEL
# ========================================

class RegisterBusinessButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Register Business",
            style=discord.ButtonStyle.primary,
            emoji="üè¢",
            custom_id="market_register_business"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Show sector selection buttons
        view = BusinessSectorSelectionView()
        embed = discord.Embed(
            title="üè¢ Select Business Sector",
            description="Choose the sector for your new business:",
            color=discord.Color.blue()
        )
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# Business Sector Select Menu
class BusinessSectorSelect(ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="Mining", description="Mining & Extraction", emoji="‚õèÔ∏è", value="Mining"),
            discord.SelectOption(label="Trade", description="Commerce & Trading", emoji="üõí", value="Trade"),
            discord.SelectOption(label="Manufacturing", description="Production & Manufacturing", emoji="üè≠", value="Manufacturing"),
            discord.SelectOption(label="Agriculture", description="Farming & Agriculture", emoji="üåæ", value="Agriculture"),
            discord.SelectOption(label="Tech", description="Technology & Innovation", emoji="üíª", value="Tech"),
            discord.SelectOption(label="Finance", description="Banking & Finance", emoji="üí∞", value="Finance"),
            discord.SelectOption(label="Real Estate", description="Property & Real Estate", emoji="üèòÔ∏è", value="Real Estate"),
            discord.SelectOption(label="Other", description="Other Business Type", emoji="üì¶", value="Other"),
        ]
        super().__init__(placeholder="Select a Business Sector...", options=options, custom_id="business_sector_select")
    
    async def callback(self, interaction: discord.Interaction):
        selected_sector = self.values[0]
        await interaction.response.send_modal(RegisterBusinessModal(selected_sector))

class BusinessSectorSelectionView(ui.View):
    def __init__(self):
        super().__init__(timeout=180)
        self.add_item(BusinessSectorSelect())

class RegisterBusinessModal(ui.Modal, title="Register New Business"):
    business_name = ui.TextInput(
        label="Business Name",
        placeholder="e.g., Florab√≠s Mining Co.",
        required=True,
        max_length=100
    )
    description = ui.TextInput(
        label="Business Description",
        placeholder="What does your business do?",
        style=discord.TextStyle.paragraph,
        required=True,
        max_length=500
    )
    initial_shares = ui.TextInput(
        label="Total Shares (100-10000)",
        placeholder="e.g., 1000",
        required=True,
        max_length=10
    )
    
    def __init__(self, sector: str):
        super().__init__(title=f"Register {sector} Business")
        self.sector = sector
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Registering business...", ephemeral=True)
        
        try:
            shares = int(self.initial_shares.value)
            if shares < 100 or shares > 10000:
                return await interaction.edit_original_response(content="‚ùå Shares must be between 100 and 10,000.")
            
            # Check if business name already exists
            existing = db.collection(BUSINESSES_COLLECTION).where(filter=FieldFilter('name', '==', self.business_name.value)).limit(1).stream()
            if len(list(existing)) > 0:
                return await interaction.edit_original_response(content=f"‚ùå Business name **{self.business_name.value}** is already taken.")
            
            # Create business (sector already selected from button)
            _, business_ref = db.collection(BUSINESSES_COLLECTION).add({
                'name': self.business_name.value,
                'description': self.description.value,
                'sector': self.sector,
                'ownerId': interaction.user.id,
                'ownerName': interaction.user.name,
                'totalShares': shares,
                'createdAt': datetime.now(timezone.utc),
                'status': 'private'
            })
            
            # Give all shares to owner
            db.collection(SHARES_COLLECTION).add({
                'businessId': business_ref.id,
                'businessName': self.business_name.value,
                'ownerId': interaction.user.id,
                'ownerName': interaction.user.name,
                'shares': shares,
                'acquiredAt': datetime.now(timezone.utc)
            })
            
            embed = discord.Embed(
                title="üè¢ Business Registered!",
                description=f"**{self.business_name.value}**\n{self.description.value}",
                color=discord.Color.green()
            )
            embed.add_field(name="Sector", value=self.sector, inline=True)
            embed.add_field(name="Your Shares", value=f"{shares:,} (100%)", inline=True)
            embed.set_footer(text="Use 'Launch IPO' to go public and sell shares")
            
            await interaction.edit_original_response(content=None, embed=embed)
            
        except ValueError:
            await interaction.edit_original_response(content="‚ùå Invalid number of shares.")
        except Exception as e:
            print(f"[ERR] Business registration failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to register business: {str(e)}")

class LaunchIPOButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Launch IPO",
            style=discord.ButtonStyle.success,
            emoji="üìà",
            custom_id="market_launch_ipo"
        )
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Loading your businesses...", ephemeral=True)
        
        # Get user's businesses
        businesses = list(db.collection(BUSINESSES_COLLECTION).where(filter=FieldFilter('ownerId', '==', interaction.user.id)).stream())
        
        if not businesses:
            return await interaction.edit_original_response(content="‚ùå You don't own any businesses. Register one first!")
        
        # Show modal by responding again
        await interaction.delete_original_response()
        await interaction.followup.send_modal(LaunchIPOModal(businesses[0].to_dict()['name']))

class LaunchIPOModal(ui.Modal, title="Launch IPO"):
    def __init__(self, business_name: str):
        super().__init__()
        self.business_name = business_name
        self.add_item(ui.TextInput(
            label=f"Shares to Sell (from {business_name})",
            placeholder="e.g., 500",
            required=True,
            max_length=10
        ))
        self.add_item(ui.TextInput(
            label="Price Per Share (Diamonds)",
            placeholder="e.g., 10",
            required=True,
            max_length=10
        ))
    
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message("üöÄ Launching IPO...")
        
        try:
            shares_offered = int(self.children[0].value)
            price_per_share = float(self.children[1].value)
            
            if shares_offered < 1:
                return await interaction.edit_original_response(content="‚ùå Must offer at least 1 share.")
            
            if price_per_share < 0.1:
                return await interaction.edit_original_response(content="‚ùå Minimum price is 0.1 diamonds per share.")
            
            # Check for active IPO
            active_ipos = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', self.business_name)).where(filter=FieldFilter('status', '==', 'active')).limit(1).stream())
            if len(active_ipos) > 0:
                return await interaction.edit_original_response(content="‚ùå This business already has an active IPO.")
            
            # Create IPO
            db.collection(IPOS_COLLECTION).add({
                'businessName': self.business_name,
                'sharesOffered': shares_offered,
                'pricePerShare': price_per_share,
                'sharesRemaining': shares_offered,
                'totalRaised': 0.0,
                'jurisdiction': jurisdiction,
            'status': 'active',
                'createdAt': datetime.now(timezone.utc),
                'createdBy': interaction.user.id
            })
            
            embed = discord.Embed(
                title="üìà IPO Launched!",
                description=f"**{self.business_name}** is now public!",
                color=discord.Color.blue()
            )
            embed.add_field(name="Shares Available", value=f"{shares_offered:,}", inline=True)
            embed.add_field(name="Price", value=f"{price_per_share:,.1f}d/share", inline=True)
            embed.add_field(name="Total Value", value=f"{shares_offered * price_per_share:,.0f}d", inline=True)
            
            await interaction.edit_original_response(content=None, embed=embed)
            
        except ValueError:
            await interaction.edit_original_response(content="‚ùå Invalid numbers provided.")
        except Exception as e:
            print(f"[ERR] IPO launch failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to launch IPO: {str(e)}")

# Stock Selection Dropdown
class StockSelect(ui.Select):
    def __init__(self, active_ipos):
        options = []
        for ipo in active_ipos[:25]:  # Discord limit 25 options
            ipo_data = ipo.to_dict()
            options.append(
                discord.SelectOption(
                    label=ipo_data['businessName'],
                    description=f"{ipo_data['sharesRemaining']:,} shares @ {ipo_data['pricePerShare']:,.1f}d each",
                    value=ipo_data['businessName'],
                    emoji="üè¢"
                )
            )
        super().__init__(placeholder="Select a business to invest in...", options=options, custom_id="stock_select")
        self.ipos_dict = {ipo.to_dict()['businessName']: ipo.to_dict() for ipo in active_ipos}
    
    async def callback(self, interaction: discord.Interaction):
        selected_business = self.values[0]
        ipo_data = self.ipos_dict[selected_business]
        
        # Show purchase modal - PRIVATE MESSAGE
        await interaction.response.send_message(
            f"üí∞ **{selected_business}**\n\n"
            f"Available: **{ipo_data['sharesRemaining']:,}** shares\n"
            f"Price: **{ipo_data['pricePerShare']:,.1f}d** per share\n\n"
            f"Use `/market buy_stock` command with business name: `{selected_business}` to purchase!",
            ephemeral=True)

class StockSelectionView(ui.View):
    def __init__(self, active_ipos):
        super().__init__(timeout=180)
        self.add_item(StockSelect(active_ipos))

class BuyStockButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Buy Stock",
            style=discord.ButtonStyle.success,
            emoji="üí∞",
            custom_id="market_buy_stock"
        )
    
    @safe_interaction
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        await interaction.response.send_message("‚è≥ Loading stocks...", ephemeral=True)
        
        # Get active IPOs
        active_ipos = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
        
        print(f"[DEBUG] Buy Stock button: Found {len(active_ipos)} active IPOs")
        for ipo in active_ipos:
            ipo_data = ipo.to_dict()
            print(f"[DEBUG] IPO: {ipo_data.get('businessName')} - {ipo_data.get('sharesRemaining')} shares @ {ipo_data.get('pricePerShare')}d")
        
        if not active_ipos:
            return await interaction.edit_original_response(content="‚ùå No active IPOs right now.")
        
        # Create dropdown select menu
        view = StockSelectionView(active_ipos)
        embed = discord.Embed(
            title="üí∞ Buy Stock - Select Business",
            description="Choose a business to invest in from the dropdown below:",
            color=discord.Color.blue()
        )
        
        embed.set_footer(text="Select from dropdown then use /market buy_stock command")
        await interaction.edit_original_response(content=None, embed=embed, view=view)
        print(f"[DEBUG] Buy Stock button: Successfully sent dropdown with {len(active_ipos)} options")

class RefreshPortfolioButton(ui.Button):
    def __init__(self, user_id):
        super().__init__(label="üîÑ Refresh", style=discord.ButtonStyle.secondary)
        self.user_id = user_id
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing portfolio...", ephemeral=True)
        
        try:
            holdings = list(db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', self.user_id)).stream())
            
            if not holdings:
                return await interaction.edit_original_response(content="üìä **Your Portfolio**\n\nYou don't own any shares yet. Start investing!")
            
            embed = discord.Embed(
                title=f"üìä Portfolio - REFRESHED",
                description="Your stock holdings (live update):",
                color=discord.Color.gold()
            )
            
            total_value = 0
            for holding in holdings:
                data = holding.to_dict()
                business_name = data.get('businessName', 'Unknown')
                shares = data.get('shares', 0)
                
                ipo = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).limit(1).stream())
                price = ipo[0].to_dict()['pricePerShare'] if ipo else 0
                value = shares * price
                total_value += value
                
                embed.add_field(
                    name=f"üè¢ {business_name}",
                    value=f"**{shares:,}** shares | ~{value:,.0f}d value",
                    inline=False
                )
            
            embed.set_footer(text=f"üîÑ Live data | Total Value: {total_value:,.0f} diamonds")
            await interaction.edit_original_response(content=None, embed=embed)
        except Exception as e:
            print(f"[ERR] Refresh portfolio failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

class PortfolioView(ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)  # 5 minute timeout
        self.add_item(RefreshPortfolioButton(user_id))

class ViewPortfolioButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="My Portfolio",
            style=discord.ButtonStyle.secondary,
            emoji="üìä",
            custom_id="market_portfolio"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        await interaction.response.send_message("‚è≥ Loading portfolio...", ephemeral=True)
        
        try:
            holdings = list(db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', interaction.user.id)).stream())
            
            if not holdings:
                return await interaction.edit_original_response(content="üìä **Your Portfolio**\n\nYou don't own any shares yet. Start investing!")
            
            embed = discord.Embed(
                title=f"üìä {interaction.user.name}'s Portfolio",
                description="Your stock holdings:",
                color=discord.Color.gold()
            )
            
            total_value = 0
            for holding in holdings:
                data = holding.to_dict()
                business_name = data.get('businessName', 'Unknown')
                shares = data.get('shares', 0)
                
                # Try to get current IPO price
                ipo = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).limit(1).stream())
                price = ipo[0].to_dict()['pricePerShare'] if ipo else 0
                value = shares * price
                total_value += value
                
                embed.add_field(
                    name=f"üè¢ {business_name}",
                    value=f"**{shares:,}** shares | ~{value:,.0f}d value",
                    inline=False
                )
            
            embed.set_footer(text=f"Estimated Total Value: {total_value:,.0f} diamonds | Click refresh to update")
            
            # Add refresh button view
            view = PortfolioView(interaction.user.id)
            await interaction.edit_original_response(content=None, embed=embed, view=view)
            
        except Exception as e:
            print(f"[ERR] Portfolio view failed: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to view portfolio.")

class ViewMarketGraphButton(ui.Button):
    """Button to view market cap graph on demand"""
    def __init__(self):
        super().__init__(
            label="View Market Graph",
            style=discord.ButtonStyle.secondary,
            emoji="üìä",
            custom_id="view_market_graph"
        )
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("üìä Generating market cap graph...", ephemeral=True)
        
        try:
            graph_buffer = generate_market_cap_graph()
            
            if graph_buffer:
                now_est = datetime.now(timezone.utc).astimezone(EST)
                
                embed = discord.Embed(
                    title="üìä FLORAB√çS MARKET CAP TREND",
                    description=f"*Historical Stock Market Performance*",
                    color=0x00C853
                )
                embed.set_footer(text=f"Updated: {now_est.strftime('%b %d, %Y at %I:%M %p EST')} | All-time market cap history")
                
                file = discord.File(graph_buffer, filename="market_cap.png")
                embed.set_image(url="attachment://market_cap.png")
                await interaction.edit_original_response(content=None, embed=embed, attachments=[file])
            else:
                await interaction.edit_original_response(content="üìã **No Market Data Available**\n\nThe market cap graph will appear once stock trading begins (IPOs, share purchases, etc.).")
        except Exception as e:
            print(f"[ERR] Failed to generate market graph: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to generate graph: {str(e)}")

class MarketDashboardButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Market Dashboard",
            style=discord.ButtonStyle.primary,
            emoji="üìà",
            custom_id="market_dashboard"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        await interaction.response.send_message("‚è≥ Loading dashboard with graphs...", ephemeral=True)
        
        try:
            businesses = list(db.collection(BUSINESSES_COLLECTION).stream())
            active_ipos = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
            
            # Calculate total market cap
            total_market_cap = 0
            total_volume = 0
            for ipo in active_ipos:
                data = ipo.to_dict()
                total_shares = data.get('sharesOffered', 0)
                price = data.get('pricePerShare', 0)
                total_raised = data.get('totalRaised', 0)
                total_market_cap += (total_shares * price)
                total_volume += total_raised
            
            embed = discord.Embed(
                title="üìä Florab√≠s Stock Market Dashboard",
                description=f"*Real-time market data | {len(active_ipos)} companies trading*\n\n",
                color=0x1e3a5f
            )
            
            # Market Overview
            embed.add_field(
                name="üìà Market Stats",
                value=(
                    f"{DIAMOND_EMOJI} **Market Cap:** {total_market_cap:,.0f}d\n"
                    f"üí∞ **Volume:** {total_volume:,.0f}d\n"
                    f"üè¢ **Companies:** {len(businesses)}\n"
                    f"üîî **Active IPOs:** {len(active_ipos)}"
                ),
                inline=True
            )
            
            # Trading Status
            market_status = "üü¢ OPEN" if len(active_ipos) > 0 else "üî¥ CLOSED"
            embed.add_field(
                name="üèõÔ∏è Exchange Status",
                value=(
                    f"**Status:** {market_status}\n"
                    f"**Time:** <t:{int(datetime.now(timezone.utc).timestamp())}:T>\n"
                    f"**Zone:** EST"
                ),
                inline=True
            )
            
            # Live Ticker - Top companies
            if active_ipos:
                sorted_ipos = sorted(active_ipos, key=lambda x: x.to_dict().get('pricePerShare', 0), reverse=True)
                ticker_text = ""
                for ipo in sorted_ipos[:5]:
                    data = ipo.to_dict()
                    name = data['businessName']
                    price = data['pricePerShare']
                    shares_left = data.get('sharesRemaining', 0)
                    
                    ticker_text += f"**{name}** - {price:,.1f}d/share ({shares_left:,} left)\n"
                
                embed.add_field(
                    name="üíπ Top Companies",
                    value=ticker_text or "No companies trading",
                    inline=False
                )
            
            # Footer - graphs are optional, view via button
            embed.set_footer(text="üìä Live data | Click 'View Market Graph' button to see trends")
            
            await interaction.edit_original_response(content=None, embed=embed)
            
        except Exception as e:
            print(f"[ERR] Market dashboard failed: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content="‚ùå Failed to load dashboard.")

class SellStockButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="Sell Stock",
            style=discord.ButtonStyle.danger,
            emoji="üí∏",
            custom_id="market_sell_stock"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately to prevent timeout
        await interaction.response.send_message("‚è≥ Loading your holdings...", ephemeral=True)
        
        if not is_citizen(interaction.user.id):
            return await interaction.edit_original_response(content="‚ùå Only citizens can sell shares.")
        
        try:
            # Get user's holdings
            holdings = list(db.collection(SHARES_COLLECTION).where(
                filter=FieldFilter('ownerId', '==', interaction.user.id)
            ).stream())
            
            if not holdings:
                return await interaction.edit_original_response(
                    content="üìä You don't own any shares to sell.\n\nBuy stock first to start trading!"
                )
            
            # Build list of holdings
            holdings_text = "**Your Stock Holdings:**\n\n"
            for holding in holdings:
                data = holding.to_dict()
                business_name = data.get('businessName', 'Unknown')
                shares = data.get('shares', 0)
                
                # Get current price
                ipo = list(db.collection(IPOS_COLLECTION).where(
                    filter=FieldFilter('businessName', '==', business_name)
                ).limit(1).stream())
                price = ipo[0].to_dict()['pricePerShare'] if ipo else 0
                value = shares * price
                
                holdings_text += f"üè¢ **{business_name}**: {shares:,} shares (~{value:,.0f}d)\n"
            
            holdings_text += f"\nüí° Use `/market sell_stock` to sell your shares."
            
            await interaction.edit_original_response(content=holdings_text)
            
        except Exception as e:
            print(f"[ERR] Sell stock button failed: {e}")
            await interaction.edit_original_response(content="‚ùå Failed to load holdings.")

class RefreshMarketButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Market", style=discord.ButtonStyle.secondary, custom_id="refresh_market")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing market data...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            businesses = list(db.collection(BUSINESSES_COLLECTION).stream())
            active_ipos = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
            
            embed = discord.Embed(
                title="üìà Market Data Refreshed",
                description=f"**üè¢ Total Businesses:** {len(businesses)}\n**üìà Active IPOs:** {len(active_ipos)}",
                color=discord.Color.green()
            )
            
            # Show top businesses by share price
            if active_ipos:
                sorted_ipos = sorted(active_ipos, key=lambda x: x.to_dict().get('pricePerShare', 0), reverse=True)
                top_text = ""
                for ipo in sorted_ipos[:5]:
                    data = ipo.to_dict()
                    shares_left = data.get('sharesRemaining', 0)
                    top_text += f"**{data['businessName']}** - {data['pricePerShare']:,.1f}d/share ({shares_left:,} left)\n"
                
                embed.add_field(
                    name=f"{DIAMOND_EMOJI} Live Stock Prices",
                    value=top_text or "No IPOs active",
                    inline=False
                )
            
            embed.set_footer(text="Live market data | Stock prices update with each trade")
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Refresh market failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh market data: {str(e)}")

class MarketPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(RegisterBusinessButton())
        self.add_item(LaunchIPOButton())
        self.add_item(BuyStockButton())
        self.add_item(SellStockButton())
        self.add_item(ViewPortfolioButton())
        self.add_item(MarketDashboardButton())
        self.add_item(ViewMarketGraphButton())
        self.add_item(RefreshMarketButton())

@bot.tree.command(name="market_panel", description="[ADMIN] Post Florab√≠s Stock Market panel")
async def market_panel_cmd(interaction: discord.Interaction):
    # CRITICAL: Respond IMMEDIATELY (within 3 seconds) or interaction expires
    await interaction.response.send_message("‚è≥ Creating market panel...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.followup.send("‚ùå Only administrators can post the market panel.", ephemeral=True)
    
    embed = discord.Embed(
        title="üìä Florab√≠s Stock Market",
        description=(
            f"*Buy & sell shares of businesses with {DIAMOND_EMOJI} diamonds*\n\n"
            "**üè¢ Business Owners** can launch companies and sell shares\n"
            "**üíπ Investors** can buy shares and earn dividends\n"
        ),
        color=0x1e3a5f  # Professional blue
    )
    
    # Simple action buttons explanation
    embed.add_field(
        name="üéØ Quick Actions",
        value=(
            "üè¢ Register your business\n"
            "üîî Launch your IPO\n"
            "üí∞ Buy shares\n"
            "üì§ Sell shares\n"
            "üìä View your portfolio\n"
            "üìà Market dashboard\n"
            "üîÑ Refresh prices"
        ),
        inline=False
    )
    
    # Key features - simplified
    embed.add_field(
        name=f"{DIAMOND_EMOJI} How It Works",
        value=(
            "‚úÖ All trades use real diamonds\n"
            "‚úÖ Prices change with supply & demand\n"
            "‚úÖ Earn dividends from profits\n"
            "‚úÖ Live market prices"
        ),
        inline=False
    )
    
    embed.set_footer(text="üí° Tip: Click any button below to get started!")
    
    # Check for existing panel and delete
    if db and interaction.guild:
        try:
            current_db = await ensure_firestore()
            panel_doc = await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('market_panel').get())
            if panel_doc.exists:
                old_data = panel_doc.to_dict()
                old_channel = interaction.guild.get_channel(old_data.get('channelId'))
                if old_channel:
                    try:
                        old_message = await old_channel.fetch_message(old_data.get('messageId'))
                        await old_message.delete()
                        print(f"[OK] Deleted old market panel message")
                    except discord.NotFound:
                        print(f"[INFO] Old market panel message already deleted")
                    except Exception as e:
                        print(f"[WARN] Could not delete old market panel: {e}")
                else:
                    print(f"[INFO] Old market panel channel not found, skipping deletion")
        except Exception as e:
            print(f"[WARN] Error checking for old market panel: {e}")
    
    # Post panel
    message = await interaction.channel.send(embed=embed, view=MarketPanel())
    
    # Store panel location
    if db:
        try:
            current_db = await ensure_firestore()
            await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('market_panel').set({
                'guildId': interaction.guild.id,
                'channelId': interaction.channel.id,
                'messageId': message.id
            }))
            print(f"[OK] Posted market panel in guild {interaction.guild.id}")
        except Exception as e:
            print(f"[WARN] Could not save market panel location: {e}")
    
    await interaction.followup.send("‚úÖ Market panel posted!", ephemeral=True)

# ========================================
# FLORAB√çS STATE BANK PANEL
# ========================================

class OpenBankingThreadButton(ui.Button):
    def __init__(self):
        super().__init__(
            label="üè¶ Open Banking Thread",
            style=discord.ButtonStyle.primary,
            custom_id="open_banking_thread"
        )
    
    async def callback(self, interaction: discord.Interaction):
        # Respond immediately
        await interaction.response.send_message("‚è≥ Opening your private banking thread...", ephemeral=True)
        
        try:
            # Banking is now open to foreigners (non-citizens) for international trade
            # No citizenship check required
            
            # Get or create bank account
            account = get_or_create_bank_account(interaction.user.id)
            if not account or not account.exists:
                return await interaction.edit_original_response(content="‚ùå Could not create your bank account.")
            
            account_data = account.to_dict()
            existing_thread_id = account_data.get('bankingThreadId')
            
            # Try to find and reuse existing thread
            thread = None
            if existing_thread_id and interaction.guild:
                try:
                    # Try to get the thread
                    thread = interaction.guild.get_thread(existing_thread_id)
                    if not thread:
                        thread = await interaction.guild.fetch_channel(existing_thread_id)
                    
                    # Unarchive if archived
                    if thread and thread.archived:
                        await thread.edit(archived=False)
                        print(f"[BANK] Unarchived existing thread for {interaction.user}")
                except Exception as e:
                    print(f"[BANK] Could not find existing thread: {e}")
                    thread = None
            
            # Create new thread if none exists
            if not thread:
                thread_name = f"üè¶ {interaction.user.name}'s Banking"
                thread = await interaction.channel.create_thread(
                    name=thread_name,
                    type=discord.ChannelType.private_thread,
                    invitable=False
                )
                
                # Save thread ID to account
                if db:
                    account.reference.update({'bankingThreadId': thread.id})
                print(f"[BANK] Created new banking thread for {interaction.user}")
            
            # Add the user to the thread
            await thread.add_user(interaction.user)
            
            # Ping Bancquero and Treasury Manager (Financial Management Roles)
            # Only ping if the roles actually exist in the guild (prevents @unknown)
            pings = []
            if interaction.guild:
                # Check if Bancquero role exists before mentioning
                if BANCQUERO_ROLE_ID:
                    bancquero_role = interaction.guild.get_role(BANCQUERO_ROLE_ID)
                    if bancquero_role:
                        pings.append(f"<@&{BANCQUERO_ROLE_ID}>")
                
                # Check if Treasury Manager role exists before mentioning
                if TREASURY_MANAGER_ROLE_ID:
                    treasury_role = interaction.guild.get_role(TREASURY_MANAGER_ROLE_ID)
                    if treasury_role:
                        pings.append(f"<@&{TREASURY_MANAGER_ROLE_ID}>")
                
                if pings:
                    ping_text = " ".join(pings)
                    await thread.send(f"üíº **Banking Thread Notification**\n\n{ping_text}\n\nNew banking thread opened for {interaction.user.mention}")
            
            # Get recent transactions for preview
            recent_txs = []
            if db:
                tx_query = db.collection(BANK_TRANSACTIONS_COLLECTION).where(
                    filter=FieldFilter('userId', '==', interaction.user.id)
                ).order_by('timestamp', direction='DESCENDING').limit(3)
                recent_txs = list(tx_query.stream())
            
            # Get multi-commodity balances
            account_data = account.to_dict()
            account_number = account_data.get('accountNumber', 'Unknown')
            diamond_balance = account_data.get('diamondBalance', account_data.get('balance', 0.0))
            essence_balance = account_data.get('essenceBalance', 0.0)
            iron_balance = account_data.get('ironBalance', 0.0)
            gold_balance = account_data.get('goldBalance', 0.0)
            
            # Get live market prices
            essence_price = get_market_price('essence')
            iron_price = get_market_price('iron')
            gold_price = get_market_price('gold')
            
            # Calculate total portfolio value in diamonds
            total_value = diamond_balance + (essence_balance * essence_price) + (iron_balance * iron_price) + (gold_balance * gold_price)
            
            # Send premium welcome message in thread
            welcome_embed = discord.Embed(
                title="üèõÔ∏è FLORAB√çS STATE ECONOMY",
                description=(
                    f"*State Reserve & Commodities Exchange*\n"
                    f"**Private Banking for {interaction.user.mention}**\n\n"
                ),
                color=0x003d5c  # Federal blue
            )
            
            # Multi-Commodity Account Summary
            welcome_embed.add_field(
                name="üíº ACCOUNT SUMMARY",
                value=(
                    f"**Account:** `{account_number}`\n"
                    f"**Total Value:** {DIAMOND_EMOJI} **{total_value:,.2f}d**\n"
                    f"**Status:** ‚úÖ Active & Verified"
                ),
                inline=False
            )
            
            # Commodity Balances
            welcome_embed.add_field(
                name="üí∞ COMMODITY BALANCES",
                value=(
                    f"{DIAMOND_EMOJI} **Diamonds:** {diamond_balance:,.2f}d\n"
                    f"{ESSENCE_EMOJI} **Essence:** {essence_balance:,.0f} essence\n"
                    f"{IRON_EMOJI} **Iron:** {iron_balance:,.0f} ingots\n"
                    f"{GOLD_EMOJI} **Gold:** {gold_balance:,.0f} ingots"
                ),
                inline=True
            )
            
            # Live Market Prices
            welcome_embed.add_field(
                name="üìà LIVE MARKET PRICES",
                value=(
                    f"{DIAMOND_EMOJI} **Diamond:** 1.00d (base)\n"
                    f"{ESSENCE_EMOJI} **Essence:** {(1/essence_price):.2f}es/1d\n"
                    f"{IRON_EMOJI} **Iron:** {(1/iron_price):.2f}i/1d\n"
                    f"{GOLD_EMOJI} **Gold:** {(1/gold_price):.1f}gld/1d"
                ),
                inline=True
            )
            
            # Recent Activity Preview
            if recent_txs:
                activity_text = ""
                for tx_doc in recent_txs[:3]:
                    tx = tx_doc.to_dict()
                    tx_type = tx.get('type', 'unknown')
                    amount = tx.get('amount', 0)
                    memo = tx.get('memo', 'No description')
                    
                    # Icon based on type
                    if tx_type == 'transfer_out':
                        icon = "‚ÜóÔ∏è"
                    elif tx_type == 'transfer_in':
                        icon = "‚ÜôÔ∏è"
                    elif tx_type == 'admin_deposit':
                        icon = "üí∞"
                    elif tx_type == 'admin_withdrawal':
                        icon = "üèß"
                    else:
                        icon = "üìù"
                    
                    activity_text += f"{icon} **{amount:,.2f}d** - {memo[:30]}\n"
                
                welcome_embed.add_field(
                    name="üìà RECENT ACTIVITY",
                    value=activity_text or "No recent transactions",
                    inline=False
                )
            
            # Banking Services
            welcome_embed.add_field(
                name="üèõÔ∏è AVAILABLE SERVICES",
                value=(
                    "**Core Banking:**\n"
                    "‚Ä¢ `/bank dashboard` - Full account overview\n"
                    "‚Ä¢ `/bank transfer` - Diamond P2P transfers\n"
                    "\n**Commodity Trading:**\n"
                    "‚Ä¢ Essence & Iron deposits/withdrawals\n"
                    "‚Ä¢ Live market pricing\n"
                    "‚Ä¢ Multi-asset portfolio management"
                ),
                inline=False
            )
            
            welcome_embed.set_footer(
                text="üèõÔ∏è Florab√≠s State Economy | State Reserve & Commodities Exchange | Est. 2025",
                icon_url=None
            )
            
            await thread.send(embed=welcome_embed)
            
            # Confirm to user
            await interaction.edit_original_response(
                content=f"‚úÖ Banking thread opened! Check {thread.mention}"
            )
            
        except Exception as e:
            print(f"[ERR] Failed to create banking thread: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to open banking thread: {str(e)}")

class RefreshBankButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Stats", style=discord.ButtonStyle.secondary, custom_id="refresh_bank")
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing bank statistics...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Get all bank accounts
            all_accounts = list(db.collection(BANK_ACCOUNTS_COLLECTION).stream())
            
            # Get market prices
            essence_price = get_market_price('essence')
            iron_price = get_market_price('iron')
            gold_price = get_market_price('gold')
            emerald_price = get_market_price('emerald')
            
            # Calculate total deposits across all commodities
            total_diamonds = 0
            total_essence = 0
            total_iron = 0
            total_gold = 0
            total_emerald = 0
            
            for acc_doc in all_accounts:
                acc = acc_doc.to_dict()
                total_diamonds += acc.get('diamondBalance', acc.get('balance', 0))
                total_essence += acc.get('essenceBalance', 0)
                total_iron += acc.get('ironBalance', 0)
                total_gold += acc.get('goldBalance', 0)
                total_emerald += acc.get('emeraldBalance', 0)
            
            # Calculate total value in diamonds
            total_value = (total_diamonds + 
                          (total_essence * essence_price) + 
                          (total_iron * iron_price) + 
                          (total_gold * gold_price) + 
                          (total_emerald * emerald_price))
            
            # Get recent transactions
            recent_txs = list(db.collection(BANK_TRANSACTIONS_COLLECTION).order_by(
                'timestamp', direction='DESCENDING'
            ).limit(5).stream())
            
            embed = discord.Embed(
                title="üí∞ BANK STATISTICS REFRESHED",
                description="*Live banking system metrics*\n\n",
                color=0x1a1a1a  # Premium black
            )
            
            # Key Metrics
            embed.add_field(
                name="üìä SYSTEM OVERVIEW",
                value=(
                    f"**Total Accounts:** {len(all_accounts)}\n"
                    f"{DIAMOND_EMOJI} Diamonds: **{total_diamonds:,.0f}d**\n"
                    f"{ESSENCE_EMOJI} Essence: **{total_essence:,.0f}** (~{total_essence*essence_price:,.0f}d)\n"
                    f"{IRON_EMOJI} Iron: **{total_iron:,.0f}** (~{total_iron*iron_price:,.0f}d)\n"
                    f"{GOLD_EMOJI} Gold: **{total_gold:,.0f}** (~{total_gold*gold_price:,.0f}d)\n"
                    f"{EMERALD_EMOJI} Emerald: **{total_emerald:,.0f}** (~{total_emerald*emerald_price:,.0f}d)\n"
                    f"üìä **Total Value:** {total_value:,.0f}d\n"
                    f"**Status:** üü¢ Online"
                ),
                inline=True
            )
            
            # Recent Activity
            if recent_txs:
                activity_lines = []
                for tx_doc in recent_txs:
                    tx = tx_doc.to_dict()
                    tx_type = tx.get('type', 'unknown')
                    amount = tx.get('amount', 0)
                    
                    if tx_type == 'transfer_out':
                        activity_lines.append(f"‚ÜóÔ∏è Transfer: {amount:,.0f}d")
                    elif tx_type == 'transfer_in':
                        activity_lines.append(f"‚ÜôÔ∏è Received: {amount:,.0f}d")
                    elif tx_type == 'admin_deposit':
                        activity_lines.append(f"üí∞ Deposit: {amount:,.0f}d")
                    else:
                        activity_lines.append(f"üìù {tx_type}: {amount:,.0f}d")
                
                embed.add_field(
                    name="üìà RECENT ACTIVITY",
                    value="\n".join(activity_lines[:5]) or "No activity",
                    inline=True
                )
            
            embed.set_footer(text="üèõÔ∏è Live Bank Statistics | Florab√≠s State Bank")
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Refresh bank failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh stats: {str(e)}")

class BankPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(OpenBankingThreadButton())
        self.add_item(ViewBankingGraphButton())
        self.add_item(RefreshBankButton())

# ARCHIVED: Bank panel command disabled
# @bot.tree.command(name="bank_panel", description="[ADMIN] Post Florab√≠s State Bank panel")
async def bank_panel_cmd_archived(interaction: discord.Interaction):
    # CRITICAL: Respond IMMEDIATELY (within 3 seconds) or interaction expires
    await interaction.response.send_message("‚è≥ Creating bank panel...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.followup.send("‚ùå Only administrators can post the bank panel.", ephemeral=True)
    
    # Get live market rates for display
    diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread = get_market_rate('diamond')
    essence_rate, essence_unit, essence_buy, essence_sell, essence_spread = get_market_rate('essence')
    iron_rate, iron_unit, iron_buy, iron_sell, iron_spread = get_market_rate('iron')
    gold_rate, gold_unit, gold_buy, gold_sell, gold_spread = get_market_rate('gold')
    emerald_rate, emerald_unit, emerald_buy, emerald_sell, emerald_spread = get_market_rate('emerald')
    iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, iron_block_spread = get_market_rate('iron_block')
    gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, gold_block_spread = get_market_rate('gold_block')
    emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, emerald_block_spread = get_market_rate('emerald_block')
    
    # Format rates cleanly with CivMC-style spreads if set
    diamond_display = format_market_rate('diamond')
    essence_display = format_market_rate('essence')
    iron_display = format_market_rate('iron')
    gold_display = format_market_rate('gold')
    emerald_display = format_market_rate('emerald')
    iron_block_display = format_market_rate('iron_block')
    gold_block_display = format_market_rate('gold_block')
    emerald_block_display = format_market_rate('emerald_block')
    
    embed = discord.Embed(
        title="üè¶ FLORAB√çS FINANCIAL CENTER",
        description="*Multi-commodity banking with state-guaranteed security*",
        color=0x003d5c  # Keep original bank color
    )
    
    # Calculate ratios (how much of each commodity = 1 diamond)
    essence_price = get_market_price('essence')
    iron_price = get_market_price('iron')
    gold_price = get_market_price('gold')
    emerald_price = get_market_price('emerald')
    iron_block_price = get_market_price('iron_block')
    gold_block_price = get_market_price('gold_block')
    emerald_block_price = get_market_price('emerald_block')
    
    # Calculate ratios
    essence_ratio = f"{1/essence_price:.2f}" if essence_price > 0 else "N/A"
    iron_ratio = f"{1/iron_price:.2f}" if iron_price > 0 else "N/A"
    gold_ratio = f"{1/gold_price:.2f}" if gold_price > 0 else "N/A"
    emerald_ratio = f"{1/emerald_price:.2f}" if emerald_price > 0 else "N/A"
    iron_block_ratio = f"{1/iron_block_price:.2f}" if iron_block_price > 0 else "N/A"
    gold_block_ratio = f"{1/gold_block_price:.2f}" if gold_block_price > 0 else "N/A"
    emerald_block_ratio = f"{1/emerald_block_price:.2f}" if emerald_block_price > 0 else "N/A"
    
    # Exchange Rates
    embed.add_field(
        name="üíπ EXCHANGE RATES",
        value=(
            f"**{DIAMOND_EMOJI} d** ‚Äî {diamond_display}\n"
            f"**{ESSENCE_EMOJI} es** ‚Äî {essence_display}\n"
            f"**{IRON_EMOJI} i** ‚Äî {iron_display}\n"
            f"**{GOLD_EMOJI} gld** ‚Äî {gold_display}\n"
            f"**{EMERALD_EMOJI} em** ‚Äî {emerald_display}"
        ),
        inline=True
    )
    
    # Block Rates
    embed.add_field(
        name="üì¶ BLOCK RATES",
        value=(
            f"**{IRON_BLOCK_EMOJI} i-blk** ‚Äî {iron_block_display}\n"
            f"**{GOLD_BLOCK_EMOJI} gld-blk** ‚Äî {gold_block_display}\n"
            f"**{EMERALD_BLOCK_EMOJI} em-blk** ‚Äî {emerald_block_display}"
        ),
        inline=True
    )
    
    # Commodity Ratios (how much = 1 diamond)
    embed.add_field(
        name="üìä COMMODITY RATIOS",
        value=(
            f"**1{DIAMOND_EMOJI} equals:**\n"
            f"{ESSENCE_EMOJI} {essence_ratio} es\n"
            f"{IRON_EMOJI} {iron_ratio} i\n"
            f"{GOLD_EMOJI} {gold_ratio} gld\n"
            f"{EMERALD_EMOJI} {emerald_ratio} em\n"
            f"{IRON_BLOCK_EMOJI} {iron_block_ratio} i-blk\n"
            f"{GOLD_BLOCK_EMOJI} {gold_block_ratio} gld-blk\n"
            f"{EMERALD_BLOCK_EMOJI} {emerald_block_ratio} em-blk"
        ),
        inline=False
    )
    
    # Banking Services
    embed.add_field(
        name="üè¶ BANKING SERVICES",
        value=(
            "‚Ä¢ 8 commodity accounts (d, es, i, gld, em + blocks)\n"
            "‚Ä¢ Private banking threads\n"
            "‚Ä¢ Real-time portfolio tracking\n"
            "‚Ä¢ Instant P2P transfers\n"
            "‚Ä¢ State-guaranteed security"
        ),
        inline=False
    )
    
    embed.set_footer(text="üèõÔ∏è Florab√≠s State Economy | Est. 2025 | State Reserve & Wall Street Commodities Exchange")
    
    # Check for existing bank panel and delete old message
    if db and interaction.guild:
        try:
            current_db = await ensure_firestore()
            bank_panel_doc = await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('bank_panel').get())
            if bank_panel_doc.exists:
                old_data = bank_panel_doc.to_dict()
                old_channel = interaction.guild.get_channel(old_data.get('channelId'))
                if old_channel:
                    try:
                        old_message = await old_channel.fetch_message(old_data.get('messageId'))
                        await old_message.delete()
                        print(f"[OK] Deleted old bank panel message")
                    except discord.NotFound:
                        print(f"[INFO] Old bank panel message already deleted")
                    except Exception as e:
                        print(f"[WARN] Could not delete old bank panel: {e}")
                else:
                    print(f"[INFO] Old bank panel channel not found, skipping deletion")
        except Exception as e:
            print(f"[WARN] Error checking for old bank panel: {e}")
    
    # Post panel
    message = await interaction.channel.send(embed=embed, view=BankPanel())
    
    # Store panel location
    if db:
        try:
            current_db = await ensure_firestore()
            await asyncio.to_thread(lambda: current_db.collection(PORTAL_PANELS_COLLECTION).document('bank_panel').set({
                'guildId': interaction.guild.id,
                'channelId': interaction.channel.id,
                'messageId': message.id
            }))
            print(f"[OK] Posted bank panel in guild {interaction.guild.id}")
        except Exception as e:
            print(f"[WARN] Could not save bank panel location: {e}")
    
    await interaction.followup.send("‚úÖ Bank panel posted!", ephemeral=True)

# ========================================
# ECONOMY PANEL - STATE ECONOMY DASHBOARD
# ========================================

class RefreshEconomyButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh Dashboard", style=discord.ButtonStyle.secondary, custom_id="refresh_economy")
    
    async def callback(self, interaction: discord.Interaction):
        # CRITICAL: Defer IMMEDIATELY before ANY checks to prevent timeout
        await interaction.response.defer(ephemeral=True)
        
        if not db:
            return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Get market prices for calculations
            essence_price = get_market_price('essence')
            iron_price = get_market_price('iron')
            gold_price = get_market_price('gold')
            emerald_price = get_market_price('emerald')
            iron_block_price = get_market_price('iron_block')
            gold_block_price = get_market_price('gold_block')
            emerald_block_price = get_market_price('emerald_block')
            
            # Get market rates for display
            diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread = get_market_rate('diamond')
            essence_rate, essence_unit, essence_buy, essence_sell, essence_spread = get_market_rate('essence')
            iron_rate, iron_unit, iron_buy, iron_sell, iron_spread = get_market_rate('iron')
            gold_rate, gold_unit, gold_buy, gold_sell, gold_spread = get_market_rate('gold')
            emerald_rate, emerald_unit, emerald_buy, emerald_sell, emerald_spread = get_market_rate('emerald')
            iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, iron_block_spread = get_market_rate('iron_block')
            gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, gold_block_spread = get_market_rate('gold_block')
            emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, emerald_block_spread = get_market_rate('emerald_block')
            
            # Ensure Firestore client is healthy
            current_db = await ensure_firestore()
            
            # Get STATE TREASURY RESERVES - wrap blocking .stream() call
            treasury_items = await asyncio.to_thread(
                lambda: list(current_db.collection(TREASURY_COLLECTION).stream())
            )
            treasury_reserves = {}
            state_treasury_value = 0
            
            for doc in treasury_items:
                data = doc.to_dict()
                # Use document ID as resource name (document ID = commodity name)
                resource = doc.id
                amount = data.get('amount', 0)
                if amount > 0:
                    treasury_reserves[resource] = amount
                    
                    # Calculate value
                    if resource == 'Diamonds':
                        state_treasury_value += amount
                    elif resource == 'Essence':
                        state_treasury_value += amount * essence_price
                    elif resource == 'Iron':
                        state_treasury_value += amount * iron_price
                    elif resource == 'Gold':
                        state_treasury_value += amount * gold_price
                    elif resource == 'Emeralds':
                        state_treasury_value += amount // 10
                    elif resource == 'Xp (Bottles)':
                        state_treasury_value += amount // 64
            
            # Get state-owned stock portfolio - wrap blocking .stream() call
            STATE_USER_ID = 0
            state_holdings = await asyncio.to_thread(
                lambda: list(current_db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', STATE_USER_ID)).stream())
            )
            state_portfolio_value = 0
            
            for holding in state_holdings:
                data = holding.to_dict()
                business_name = data.get('businessName', 'Unknown')
                shares = data.get('shares', 0)
                
                # Get current IPO price - wrap blocking .stream() call
                ipo = await asyncio.to_thread(
                    lambda bn=business_name: list(current_db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', bn)).limit(1).stream())
                )
                price = ipo[0].to_dict()['pricePerShare'] if ipo else 10.0
                state_portfolio_value += shares * price
            
            # Calculate total deposits across all citizen accounts - wrap blocking .stream() call
            all_accounts = await asyncio.to_thread(
                lambda: list(current_db.collection(BANK_ACCOUNTS_COLLECTION).stream())
            )
            
            total_diamonds = 0
            total_essence = 0
            total_iron = 0
            total_gold = 0
            total_emerald = 0
            total_iron_blocks = 0
            total_gold_blocks = 0
            total_emerald_blocks = 0
            
            for acc_doc in all_accounts:
                acc = acc_doc.to_dict()
                total_diamonds += acc.get('diamondBalance', acc.get('balance', 0))
                total_essence += acc.get('essenceBalance', 0)
                total_iron += acc.get('ironBalance', 0)
                total_gold += acc.get('goldBalance', 0)
                total_emerald += acc.get('emeraldBalance', 0)
                total_iron_blocks += acc.get('ironBlockBalance', 0)
                total_gold_blocks += acc.get('goldBlockBalance', 0)
                total_emerald_blocks += acc.get('emeraldBlockBalance', 0)
            
            # Calculate total value in diamonds
            total_essence_value = total_essence * essence_price
            total_iron_value = total_iron * iron_price
            total_gold_value = total_gold * gold_price
            total_emerald_value = total_emerald * emerald_price
            total_iron_block_value = total_iron_blocks * iron_block_price
            total_gold_block_value = total_gold_blocks * gold_block_price
            total_emerald_block_value = total_emerald_blocks * emerald_block_price
            total_liquidity = (total_diamonds + total_essence_value + total_iron_value + total_gold_value + 
                              total_emerald_value + total_iron_block_value + total_gold_block_value + total_emerald_block_value)
            
            # Get active bonds - wrap blocking .stream() call
            active_bonds = await asyncio.to_thread(
                lambda: list(current_db.collection(TREASURY_BONDS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
            )
            
            total_bond_principal = sum(bond.to_dict().get('principal', 0) for bond in active_bonds)
            
            # Get active certificates - wrap blocking .stream() call
            active_certs = await asyncio.to_thread(
                lambda: list(current_db.collection(ESSENCE_CERTIFICATES_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
            )
            
            locked_essence = sum(cert.to_dict().get('essenceAmount', 0) for cert in active_certs)
            
            # Build dashboard embed
            embed = discord.Embed(
                title="üèõÔ∏è FLORAB√çS STATE ECONOMY DASHBOARD",
                description="*State Reserve & Commodities Exchange*\n",
                color=0x003d5c
            )
            
            # Market Exchange Rates - Ingots/Units
            embed.add_field(
                name="üíπ EXCHANGE RATES",
                value=(
                    f"{DIAMOND_EMOJI} **Diamond:** {diamond_rate:.2f}{diamond_unit}\n"
                    f"{ESSENCE_EMOJI} **Essence:** {essence_rate:.2f}es/1d\n"
                    f"{IRON_EMOJI} **Iron:** {iron_rate:.2f}i/1d\n"
                    f"{GOLD_EMOJI} **Gold:** {gold_rate:.1f}gld/1d\n"
                    f"{EMERALD_EMOJI} **Emerald:** {emerald_rate:.2f}em/1d"
                ),
                inline=True
            )
            
            # Market Exchange Rates - Blocks
            embed.add_field(
                name="üíπ BLOCK RATES",
                value=(
                    f"{IRON_BLOCK_EMOJI} **Iron Block:** {iron_block_rate:.2f}iblk/1d\n"
                    f"{GOLD_BLOCK_EMOJI} **Gold Block:** {gold_block_rate:.1f}gblk/1d\n"
                    f"{EMERALD_BLOCK_EMOJI} **Emerald Block:** {emerald_block_rate:.2f}eblk/1d"
                ),
                inline=True
            )
            
            # STATE TREASURY
            treasury_text = ""
            for resource, amount in treasury_reserves.items():
                if resource == 'Diamonds':
                    treasury_text += f"{DIAMOND_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Essence':
                    treasury_text += f"{ESSENCE_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Iron':
                    treasury_text += f"{IRON_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Gold':
                    treasury_text += f"{GOLD_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Emeralds':
                    treasury_text += f"{EMERALD_EMOJI} **{resource}:** {amount:,.0f}\n"
                else:
                    treasury_text += f"**{resource}:** {amount:,.0f}\n"
            
            total_state_value = state_treasury_value + state_portfolio_value
            if not treasury_text:
                treasury_text = "No reserves"
            else:
                treasury_text += f"\nüìä **Treasury Value:** {state_treasury_value:,.0f}d"
                if state_portfolio_value > 0:
                    treasury_text += f"\nüìà **Stock Portfolio:** {state_portfolio_value:,.0f}d"
                    treasury_text += f"\nüí∞ **Total State Assets:** {total_state_value:,.0f}d"
            
            embed.add_field(
                name="üèõÔ∏è STATE TREASURY",
                value=treasury_text,
                inline=False
            )
            
            # Citizen Bank Liquidity
            embed.add_field(
                name="üí∞ CITIZEN LIQUIDITY (Bank Accounts)",
                value=(
                    f"{DIAMOND_EMOJI} Diamonds: **{total_diamonds:,.0f}d**\n"
                    f"{ESSENCE_EMOJI} Essence: **{total_essence:,.0f}** (~{total_essence_value:,.0f}d)\n"
                    f"{IRON_EMOJI} Iron: **{total_iron:,.0f}** (~{total_iron_value:,.0f}d)\n"
                    f"{GOLD_EMOJI} Gold: **{total_gold:,.0f}** (~{total_gold_value:,.0f}d)\n"
                    f"{EMERALD_EMOJI} Emerald: **{total_emerald:,.0f}** (~{total_emerald_value:,.0f}d)\n"
                    f"{IRON_BLOCK_EMOJI} Iron Blocks: **{total_iron_blocks:,.0f}** (~{total_iron_block_value:,.0f}d)\n"
                    f"{GOLD_BLOCK_EMOJI} Gold Blocks: **{total_gold_blocks:,.0f}** (~{total_gold_block_value:,.0f}d)\n"
                    f"{EMERALD_BLOCK_EMOJI} Emerald Blocks: **{total_emerald_blocks:,.0f}** (~{total_emerald_block_value:,.0f}d)\n"
                    f"\n"
                    f"üìä **Total Value:** {total_liquidity:,.0f}d"
                ),
                inline=False
            )
            
            # Investment Activity
            embed.add_field(
                name="üìà INVESTMENT ACTIVITY",
                value=(
                    f"üí∞ **Active Bonds:** {len(active_bonds)}\n"
                    f"{DIAMOND_EMOJI} **Bond Principal:** {total_bond_principal:,.0f}d\n"
                    f"üìú **Active Certificates:** {len(active_certs)}\n"
                    f"{ESSENCE_EMOJI} **Locked Essence:** {locked_essence:,.0f} essence"
                ),
                inline=False
            )
            
            # Economic Indicators
            liquidity_ratio = "Healthy" if total_liquidity > 1000 else "Low"
            market_heat = "Moderate" if len(active_bonds) > 0 else "Cool"
            
            embed.add_field(
                name="üìä ECONOMIC INDICATORS",
                value=(
                    f"üìà **Inflation Rate:** 0% (stable)\n"
                    f"üî• **Market Heat:** {market_heat}\n"
                    f"üíß **Liquidity Ratio:** {liquidity_ratio}\n"
                    f"‚öñÔ∏è **State Reserves:** Adequate\n"
                    f"üë• **Total Accounts:** {len(all_accounts)}"
                ),
                inline=False
            )
            
            now_est = datetime.now(timezone.utc).astimezone(EST)
            embed.set_footer(text=f"üîÑ Refreshed: {now_est.strftime('%I:%M %p EST')} | Florab√≠s State Economy")
            
            # Update the persistent panel message (not the ephemeral response)
            await interaction.message.edit(embed=embed, view=EconomyPanel())
            # Success! Panel updated visually - delete the "loading" response silently
            await interaction.delete_original_response()
            print(f"[ECONOMY] Dashboard refreshed by {interaction.user}")
            
        except Exception as e:
            print(f"[ERR] Refresh economy dashboard failed: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

class EconomyPanel(ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(ViewGDPGraphButton())
        self.add_item(RefreshEconomyButton())

@bot.tree.command(name="economy_panel", description="[ADMIN] Post State Economy Dashboard panel")
async def economy_panel_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.followup.send("‚ùå Only administrators can post the economy panel.", ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    try:
        print(f"[ECONOMY-PANEL] Starting foreground panel creation...")
        # BUILD PANEL IN FOREGROUND WITH FULL ERROR LOGGING
        await bot.process_economy_panel_job({}, interaction.guild, interaction.channel)
        await interaction.followup.send("‚úÖ Economy panel posted successfully!", ephemeral=True)
        print(f"[ECONOMY-PANEL] ‚úÖ Panel created successfully")
    except Exception as e:
        print(f"[ECONOMY-PANEL] ‚ùå ERROR creating panel:")
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Failed to create panel:\n```{str(e)}```", ephemeral=True)

# Case Search Command


@court_group.command(name="force_close", description="[ADMIN] Force close a case with optional verdict (bypasses panel requirements)")
@app_commands.describe(
    case_id="Case ID to force close (e.g., CR-FCC2A8)",
    verdict="Verdict to record (Guilty, Not Guilty, or leave blank for no verdict)",
    sentence="Sentence if guilty (e.g., '30 days pearl')",
    reason="Reason for force closing"
)
@app_commands.choices(verdict=[
    app_commands.Choice(name="Guilty", value="Guilty"),
    app_commands.Choice(name="Not Guilty", value="Not Guilty"),
    app_commands.Choice(name="Dismissed", value="Dismissed"),
    app_commands.Choice(name="No Verdict (just close)", value="none")
])
async def force_close_case_cmd(interaction: discord.Interaction, case_id: str, verdict: str = "none", sentence: str = None, reason: str = "Case force-closed by administrator"):
    """Force close a case regardless of panel status"""
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Only administrators can force close cases.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Force closing case...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        clean_case_id = case_id.strip().upper()
        case_doc = db.collection(COURT_CASES_COLLECTION).document(clean_case_id).get()
        
        if not case_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Case `{clean_case_id}` not found.")
        
        case_data = case_doc.to_dict()
        current_status = case_data.get('status', 'unknown')
        
        # Build update data
        update_data = {
            'closedAt': datetime.now(timezone.utc),
            'closedBy': interaction.user.id,
            'closedByName': str(interaction.user),
            'closeReason': reason,
            'forceClose': True,
            'previousStatus': current_status
        }
        
        # Handle verdict
        verdict_text = ""
        if verdict and verdict != "none":
            update_data['verdict'] = verdict
            update_data['verdictAt'] = datetime.now(timezone.utc)
            update_data['verdictBy'] = interaction.user.id
            verdict_text = f"\n**Verdict:** {verdict}"
            
            if verdict == "Guilty":
                update_data['status'] = 'sentenced'
                if sentence:
                    update_data['sentence'] = sentence
                    verdict_text += f"\n**Sentence:** {sentence}"
            elif verdict == "Not Guilty":
                update_data['status'] = 'closed'
            elif verdict == "Dismissed":
                update_data['status'] = 'dismissed'
        else:
            update_data['status'] = 'closed'
        
        case_doc.reference.update(update_data)
        
        # Try to lock/archive the thread
        thread_id = case_data.get('courtroomThreadId')
        thread_status = ""
        if thread_id:
            try:
                thread = interaction.guild.get_thread(thread_id)
                if not thread:
                    thread = await interaction.guild.fetch_channel(thread_id)
                if thread:
                    # Post closure notice
                    verdict_display = f"\n**Verdict:** {verdict}" if verdict != "none" else ""
                    sentence_display = f"\n**Sentence:** {sentence}" if sentence else ""
                    close_embed = discord.Embed(
                        title="üîí CASE FORCE-CLOSED" + (" - " + verdict if verdict != "none" else ""),
                        description=f"**Case:** {clean_case_id}\n**Closed by:** {interaction.user.mention}{verdict_display}{sentence_display}\n**Reason:** {reason}",
                        color=0xFF0000 if verdict == "Guilty" else (0x00FF00 if verdict == "Not Guilty" else 0x2F3136)
                    )
                    close_embed.set_footer(text=f"Closed {datetime.now(EST).strftime('%b %d, %Y at %I:%M %p EST')}")
                    await thread.send(embed=close_embed)
                    
                    # Lock and archive
                    await thread.edit(locked=True, archived=True)
                    thread_status = "\nüîí Thread locked and archived."
            except Exception as thread_err:
                thread_status = f"\n‚ö†Ô∏è Could not update thread: {thread_err}"
        
        await interaction.edit_original_response(
            content=f"‚úÖ **Case Force-Closed**\n\n"
                    f"**Case ID:** `{clean_case_id}`\n"
                    f"**Previous Status:** {current_status}{verdict_text}\n"
                    f"**Reason:** {reason}{thread_status}"
        )
        
        print(f"[OK] Admin {interaction.user} force-closed case {clean_case_id} (was: {current_status})")
        
    except Exception as e:
        print(f"[ERR] Force close failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to force close: {str(e)}")

@court_group.command(name="search", description="üîç Search for court cases by IGN, case ID, or status")
@app_commands.describe(
    ign="Search by defendant's IGN",
    case_id="Search by exact case ID (e.g., CR-ABC123)",
    status="Search by case status"
)
async def case_search_cmd(
    interaction: discord.Interaction, 
    ign: str = None, 
    case_id: str = None,
    status: str = None
):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Must provide at least one search criterion
    if not ign and not case_id and not status:
        return await interaction.edit_original_response(content=
            "‚ùå Please provide at least one search criterion:\n"
            "‚Ä¢ IGN (defendant's Minecraft name)\n"
            "‚Ä¢ Case ID (e.g., CR-ABC123)\n"
            "‚Ä¢ Status (pending, sentenced, closed)")
    
    try:
        # Build query based on provided criteria
        cases_ref = db.collection(COURT_CASES_COLLECTION)
        
        # If case_id provided, search by exact match (fastest)
        if case_id:
            case_doc = cases_ref.document(case_id.upper()).get()
            if case_doc.exists:
                cases = [case_doc]
            else:
                return await interaction.edit_original_response(content=f"‚ùå No case found with ID: {case_id}")
        else:
            # Build filters
            filters = []
            if ign:
                filters.append(('defendantIgn', '==', ign))
            if status:
                filters.append(('status', '==', status.lower()))
            
            # Query with filters
            query = cases_ref
            for field, op, value in filters:
                query = query.where(filter=FieldFilter(field, op, value))
            
            cases = list(query.stream())
        
        if not cases:
            search_terms = []
            if ign:
                search_terms.append(f"IGN: {ign}")
            if status:
                search_terms.append(f"Status: {status}")
            return await interaction.edit_original_response(content=
                f"‚ùå No cases found matching: {', '.join(search_terms)}")
        
        # Build results embed
        case_list = []
        for case_doc in cases[:20]:  # Limit to 20 results
            case_data = case_doc.to_dict()
            case_id_str = case_data.get('caseId', 'Unknown')
            case_type = case_data.get('caseType', 'Unknown')
            defendant = case_data.get('defendantIgn', 'Unknown')
            charges = case_data.get('charges', 'No charges listed')
            case_status = case_data.get('status', 'unknown').title()
            verdict = case_data.get('verdict', 'Pending')
            
            case_type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
            status_emoji = {"pending": "‚è≥", "sentenced": "‚öñÔ∏è", "closed": "‚úÖ"}.get(case_status.lower(), "üìã")
            
            case_summary = (
                f"{case_type_emoji} **{case_id_str}** ({case_type})\n"
                f"**Defendant:** {defendant}\n"
                f"**Charges:** {charges[:50]}{'...' if len(charges) > 50 else ''}\n"
                f"**Status:** {status_emoji} {case_status}"
            )
            if verdict and verdict != 'Pending':
                case_summary += f" | **Verdict:** {verdict}"
            
            case_list.append(case_summary)
        
        # Build search query description
        search_desc = []
        if ign:
            search_desc.append(f"IGN: `{ign}`")
        if case_id:
            search_desc.append(f"Case ID: `{case_id}`")
        if status:
            search_desc.append(f"Status: `{status}`")
        
        embed = discord.Embed(
            title=f"üîç Case Search Results ({len(cases)})",
            description=f"**Search:** {' | '.join(search_desc)}\n\n" + "\n\n".join(case_list),
            color=0x008b8b
        )
        
        if len(cases) > 20:
            embed.set_footer(text=f"Showing 20 of {len(cases)} results | Refine search for fewer results")
        else:
            embed.set_footer(text="‚öñÔ∏è Justice System Search")
        
        await interaction.edit_original_response(embed=embed)
    except Exception as e:
        print(f"[ERR] Case search failed: {e}")
        await interaction.edit_original_response(content="‚ùå Search failed. Please try again.")

@court_group.command(name="issue_verdict", description="‚öñÔ∏è Issue verdict for a case (Magistrates only)")
@app_commands.describe(
    case_id="Case ID (e.g., CR-ABC123 or CV-XYZ789)"
)
async def issue_verdict_cmd(interaction: discord.Interaction, case_id: str):
    """Manual verdict command for cases where buttons don't work"""
    
    # Check if user has magistrate role
    if not has_magistrate_role(interaction):
        return await interaction.response.send_message("‚ùå Only Magistrates can issue verdicts.", ephemeral=True)
    
    if not db:
        return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
    
    try:
        # Find the case
        case_ref = db.collection(COURT_CASES_COLLECTION).document(case_id.upper())
        case_doc = case_ref.get()
        
        if not case_doc.exists:
            return await interaction.response.send_message(
                f"‚ùå Case not found: `{case_id}`\n\nUse `/court search` to find the correct case ID.",
                ephemeral=True
            )
        
        case_data = case_doc.to_dict()
        requires_panel = case_data.get('requiresJudgePanel', False)
        
        # Show case info and open appropriate verdict modal
        if requires_panel:
            # Serious case: Use 3-judge panel
            await interaction.response.send_modal(IssueVerdictModal(case_id.upper(), case_type=case_data.get("caseType", "Criminal")))
        else:
            # Normal case: Single judge verdict
            await interaction.response.send_modal(SingleJudgeVerdictModal(case_id.upper(), case_type=case_data.get('caseType', 'Criminal')))
        
        print(f"[COURT] Magistrate {interaction.user} manually opening verdict modal for case {case_id}")
        
    except Exception as e:
        print(f"[ERR] Failed to issue verdict via command: {e}")
        import traceback
        traceback.print_exc()
        return await interaction.response.send_message(
            f"‚ùå Failed to load case data. Please try again or contact an administrator.",
            ephemeral=True
        )

# Referendum system removed per user request

@bot.tree.command(name="refresh_panels", description="[ADMIN] Refresh all interactive panels with latest dropdown views")
async def refresh_panels_cmd(interaction: discord.Interaction):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Only administrators can use this command.", ephemeral=True)
    
    # RESPOND IMMEDIATELY to avoid timeout
    await interaction.response.send_message("üîÑ Clearing panel cache...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Delete stored panel references to force recreation
        panel_names = ['court_panel', 'betting_panel', 'market_panel', 'bank_panel', 'economy_panel', 'warrant_panel', 'citizen_panel']
        for panel_name in panel_names:
            try:
                db.collection(PORTAL_PANELS_COLLECTION).document(panel_name).delete()
            except:
                pass  # Panel might not exist
        
        await interaction.edit_original_response(
            content="‚úÖ **ALL Panel Caches Cleared!**\n\n"
            "**Now re-run these commands to post fresh panels:**\n\n"
            "**Core Panels:**\n"
            "‚Ä¢ `/setup` - Legislative bill creation panel\n"
            "‚Ä¢ `/citizen_panel` - Citizen registration panel\n"
            "‚Ä¢ `/court_panel` - Court filing panel\n\n"
            "**Economy Panels:**\n"
            "‚Ä¢ `/bank_panel` - Florab√≠s State Bank panel\n"
            "‚Ä¢ `/economy_panel` - State Economy Dashboard\n"
            "‚Ä¢ `/market_panel` - Stock market panel\n"
            "‚Ä¢ `/betting_panel` - Tom Brady's betting exchange\n\n"
            "**Security Panels:**\n"
            "‚Ä¢ `/warrant post_panel` - Warrant/POS display panel\n\n"
            "The old panel messages will be automatically deleted when you re-post them."
        )
    except Exception as e:
        print(f"[ERR] Panel refresh failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to refresh panels: {str(e)}")


@bot.tree.command(name="add_citizen", description="[ADMIN] Manually add a citizen (bypasses snitch verification)")
async def add_citizen_cmd(interaction: discord.Interaction, user: discord.Member, ign: str, citizenship_type: str):
    """Admin command to manually add citizens without snitch verification"""
    # Defer IMMEDIATELY to prevent timeout (must respond within 3 seconds)
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can use this command.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Validate citizenship type
    if citizenship_type.lower() not in ['primary', 'secondary']:
        return await interaction.edit_original_response(content="‚ùå Citizenship type must be 'primary' or 'secondary'.")
    
    citizenship_type = citizenship_type.lower()
    
    # Check if already registered
    if is_citizen(user.id):
        return await interaction.edit_original_response(content=f"‚ùå {user.mention} is already registered as a citizen.")
    
    try:
        # Add to database
        db.collection(CITIZENS_COLLECTION).add({
            'userId': user.id,
            'ign': ign,
            'citizenshipType': citizenship_type,
            'registeredAt': datetime.now(timezone.utc),
            'addedBy': 'admin',
            'adminId': interaction.user.id
        })
        
        # Assign appropriate roles (citizenship-specific + universal)
        role_id = SECONDARY_CITIZEN_ROLE_ID if citizenship_type == "secondary" else CITIZEN_ROLE_ID
        if role_id and interaction.guild:
            role = interaction.guild.get_role(role_id)
            universal_role = interaction.guild.get_role(UNIVERSAL_CITIZEN_ROLE_ID) if UNIVERSAL_CITIZEN_ROLE_ID else None
            if role:
                try:
                    await user.add_roles(role)
                    # Also assign universal citizen role
                    if universal_role:
                        await user.add_roles(universal_role)
                except Exception as e:
                    print(f"[WARN] Failed to assign role: {e}")
        
        # Send success message
        type_emoji = "üåê" if citizenship_type == "secondary" else "üèõÔ∏è"
        await interaction.edit_original_response(content=
            f"‚úÖ **Citizen Added Successfully**\n\n"
            f"{type_emoji} **User:** {user.mention}\n"
            f"**IGN:** {ign}\n"
            f"**Type:** {citizenship_type.title()} Citizen\n"
            f"**Added by:** {interaction.user.mention}\n\n"
            f"*Note: This citizen was added manually without snitch verification.*")
        
        print(f"[OK] Admin {interaction.user} manually added citizen: {user} ({ign}) as {citizenship_type}")
        
    except Exception as e:
        print(f"[ERR] Failed to add citizen: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to add citizen: {str(e)}")

@bot.tree.command(name="citizen_lookup", description="Look up detailed information about a specific citizen")
@app_commands.describe(
    search="Search by IGN or mention a Discord user"
)
async def citizen_lookup_cmd(interaction: discord.Interaction, search: str):
    """Look up detailed information about a citizen by IGN or Discord user"""
    # CRITICAL: Defer IMMEDIATELY to prevent timeout
    try:
        await interaction.response.defer(ephemeral=True)
    except Exception as defer_err:
        print(f"[ERR] Failed to defer citizen lookup interaction: {defer_err}")
        # Try to recreate HTTP connection for next time
        try:
            pass  # Discord.py handles reconnections automatically
            print(f"[OK] Recreated HTTP connection after defer failure")
        except Exception as recreate_err:
            print(f"[WARN] HTTP recreate failed: {recreate_err}")
        return
    
    if not db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    # RETRY LOOP: Handle intermittent Firestore failures
    max_retries = 2
    for attempt in range(max_retries + 1):
        try:
            # CRITICAL: Ensure Firestore connection is alive before queries
            current_db = await ensure_firestore()
            
            # Extract user ID if they mentioned someone (format: <@123456789>)
            user_id = None
            if search.startswith("<@") and search.endswith(">"):
                user_id = int(search.strip("<@!>"))
            
            # Search by Discord user ID first
            citizen_doc = None
            if user_id:
                # CRITICAL: Wrap blocking .stream() in thread pool
                citizens = await asyncio.to_thread(
                    lambda: list(current_db.collection(CITIZENS_COLLECTION).where(
                        filter=FieldFilter('userId', '==', user_id)
                    ).limit(1).stream())
                )
                if citizens:
                    citizen_doc = citizens[0]
            
            # If not found, search by IGN
            if not citizen_doc:
                # CRITICAL: Wrap blocking .stream() in thread pool
                citizens = await asyncio.to_thread(
                    lambda: list(current_db.collection(CITIZENS_COLLECTION).stream())
                )
                for doc in citizens:
                    data = doc.to_dict()
                    if data.get('ign', '').lower() == search.lower():
                        citizen_doc = doc
                        break
            
            # If we got here, the queries succeeded - break out of retry loop
            break
            
        except OSError as e:
            # [Errno 5] Input/output error - connection is dead
            if attempt < max_retries:
                print(f"[WARN] Citizen lookup failed with [Errno 5], retrying {attempt+1}/{max_retries}...")
                await asyncio.sleep(1)
                continue
            else:
                # Final attempt failed
                print(f"[ERR] Citizen lookup failed after {max_retries+1} attempts: {e}")
                return await interaction.followup.send(
                    f"‚ùå **Database Connection Issue**\n\n"
                    f"Unable to reach the database after multiple attempts. Please try again in a moment.\n\n"
                    f"*The network connection may be temporarily unstable.*",
                    ephemeral=True
                )
    
    try:
        
        if not citizen_doc:
            return await interaction.followup.send(f"‚ùå No citizen found matching: **{search}**", ephemeral=True)
        
        # Get citizen data
        citizen_data = citizen_doc.to_dict()
        ign = citizen_data.get('ign', 'Unknown')
        user_id = citizen_data.get('userId')
        citizenship_type = citizen_data.get('citizenshipType', 'primary')
        registered_at = citizen_data.get('registeredAt')
        added_by = citizen_data.get('addedBy', 'snitch_verification')
        
        # Format registration date
        if registered_at:
            reg_date_est = registered_at.astimezone(EST)
            reg_date_str = reg_date_est.strftime('%b %d, %Y at %I:%M %p EST')
        else:
            reg_date_str = "Unknown"
        
        # Build embed
        type_emoji = "üåê" if citizenship_type == "secondary" else "üèõÔ∏è"
        embed = discord.Embed(
            title=f"{type_emoji} Citizen Profile: {ign}",
            color=discord.Color.from_str("#1f5123")
        )
        
        # Get residency info
        current_city = citizen_data.get('currentCity', None)
        current_region = citizen_data.get('currentRegion', None)
        residency_str = f"**Residence:** {current_city}, {current_region}\n" if current_city else ""
        
        # Basic Info
        embed.add_field(
            name="üìã Basic Information",
            value=(
                f"**IGN:** {ign}\n"
                f"**Discord:** <@{user_id}>\n"
                f"**Citizenship:** {citizenship_type.title()}\n"
                f"{residency_str}"
                f"**Registered:** {reg_date_str}\n"
                f"**Method:** {added_by.replace('_', ' ').title()}"
            ),
            inline=False
        )
        
        # Check for criminal records (manual records + state court convictions)
        current_db = await ensure_firestore()
        now = datetime.now(timezone.utc)
        
        # Get manual criminal records (SERVING or ACTIVE, not EXPIRED)
        all_records = await asyncio.to_thread(lambda: list(current_db.collection(CRIMINAL_RECORDS_COLLECTION).where(
            filter=FieldFilter('citizenId', '==', str(user_id))
        ).stream()))
        
        # Get state court case convictions (automatic from Florab√≠s court)
        court_cases = await asyncio.to_thread(lambda: list(current_db.collection(COURT_CASES_COLLECTION).where(
            filter=FieldFilter('defendantIGN', '==', ign)
        ).stream()))
        
        # Check for active warrants
        warrants = await asyncio.to_thread(lambda: list(current_db.collection(WARRANTS_COLLECTION).where(
            filter=FieldFilter('ign', '==', ign)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream()))
        
        # Filter active manual records (not expired)
        active_records = []
        for rec_doc in all_records:
            r = rec_doc.to_dict()
            status = r.get('status', '')
            if status == 'SERVING':
                active_records.append(r)
            elif status == 'ACTIVE':
                expires_at = r.get('expiresAt')
                if expires_at:
                    # Normalize timestamp
                    if hasattr(expires_at, 'replace') and expires_at.tzinfo is None:
                        expires_at = expires_at.replace(tzinfo=timezone.utc)
                    elif hasattr(expires_at, 'timestamp'):
                        expires_at = datetime.fromtimestamp(expires_at.timestamp(), tz=timezone.utc)
                    if expires_at > now:
                        r['_expiresAt'] = expires_at
                        active_records.append(r)
        
        # Get state convictions from court cases
        state_convictions = []
        for case_doc in court_cases:
            c = case_doc.to_dict()
            verdict = c.get('verdict', '').lower()
            if 'guilty' in verdict and 'not guilty' not in verdict:
                charge = c.get('charges', c.get('charge', 'Unknown charge'))
                case_id = case_doc.id
                state_convictions.append({'charge': charge, 'caseId': case_id})
        
        # Separate manual records by jurisdiction
        federal_records = [r for r in active_records if r.get('jurisdiction') == 'FEDERAL']
        state_manual_records = [r for r in active_records if r.get('jurisdiction') == 'STATE']
        
        # Group warrants by jurisdiction
        state_warrants = []
        federal_warrants = []
        for warrant_doc in warrants:
            w = warrant_doc.to_dict()
            jurisdiction = w.get('jurisdiction', 'STATE')
            charge = w.get('charge', 'Wanted')
            if jurisdiction == 'FEDERAL':
                federal_warrants.append(charge)
            else:
                state_warrants.append(charge)
        
        has_criminal_history = len(active_records) > 0 or len(state_convictions) > 0 or len(warrants) > 0
        
        if has_criminal_history:
            status_parts = []
            
            # Federal manual records (from /citizen_record_add)
            for r in federal_records[:2]:
                status = r.get('status')
                if status == 'SERVING':
                    status_parts.append(f"üåê **Federal** - {r.get('charge')} (Serving)")
                else:
                    expires_at = r.get('_expiresAt')
                    days_left = (expires_at - now).days if expires_at else 0
                    status_parts.append(f"üåê **Federal** - {r.get('charge')} ({days_left}d left on record)")
            
            # State convictions from court cases (automatic)
            if state_convictions:
                status_parts.append(f"üèõÔ∏è **State Convictions** ({len(state_convictions)})")
                for c in state_convictions[:2]:
                    status_parts.append(f"  ‚Ä¢ {c['charge']} ({c['caseId']})")
            
            # State manual records
            for r in state_manual_records[:2]:
                status = r.get('status')
                if status == 'SERVING':
                    status_parts.append(f"üèõÔ∏è **State** - {r.get('charge')} (Serving)")
                else:
                    expires_at = r.get('_expiresAt')
                    days_left = (expires_at - now).days if expires_at else 0
                    status_parts.append(f"üèõÔ∏è **State** - {r.get('charge')} ({days_left}d left)")
            
            # Active warrants
            if federal_warrants:
                status_parts.append(f"üö® **Federal Warrant** - {', '.join(federal_warrants[:2])}")
            if state_warrants:
                status_parts.append(f"üö® **State Warrant** - {', '.join(state_warrants[:2])}")
            
            embed.add_field(
                name="‚öñÔ∏è Criminal Status",
                value="\n".join(status_parts) if status_parts else "Unknown",
                inline=False
            )
        else:
            embed.add_field(name="‚öñÔ∏è Criminal Status", value="‚úÖ Clean record", inline=False)
        
        # Check for pearl status - wrap blocking .stream() call
        current_db = await ensure_firestore()
        pearls = await asyncio.to_thread(
            lambda: list(current_db.collection(PEARLS_COLLECTION).where(
                filter=FieldFilter('ign', '==', ign)
            ).where(
                filter=FieldFilter('status', '==', 'active')
            ).stream())
        )
        
        if pearls:
            pearl = pearls[0].to_dict()
            duration = pearl.get('pearlDuration', 0)
            release_date = pearl.get('expectedReleaseDate')
            if release_date:
                days_left = max((release_date - datetime.now(timezone.utc)).days, 0)
                pearl_start = pearl.get('pearlStartDate')
                
                # NEW ESSENCE SYSTEM: Read from database if available, otherwise calculate fallback
                essence_capacity = pearl.get('essenceCapacity')
                essence_remaining = pearl.get('essenceRemaining')
                
                # Fallback for old pearls without new fields
                if essence_capacity is None or essence_remaining is None:
                    if pearl_start:
                        days_held_so_far = (datetime.now(timezone.utc) - pearl_start).days
                        essence_remaining = sum(calculate_pearl_essence_cost(days_held_so_far + day + 1) for day in range(days_left))
                        essence_capacity = 336.0  # FIXED capacity for all pearls
                    else:
                        essence_remaining = days_left * 3.0
                        essence_capacity = 336.0  # FIXED capacity for all pearls
                
                # Use helper function for consistent PERMA display
                duration_text, release_text, fuel_text = format_pearl_display(
                    duration, release_date, pearl_start, essence_remaining, essence_capacity, days_left
                )
                
                if duration >= 256:
                    pearl_status = f"‚è≥ **PERMANENTLY PEARLED** ({duration_text})"
                else:
                    pearl_status = f"<:pearl:1428919990194536458> **PEARLED** - {days_left} days remaining (Release: {release_text})"
            else:
                pearl_status = "<:pearl:1428919990194536458> **PEARLED** - Awaiting sentencing"
            
            embed.add_field(
                name="‚õìÔ∏è Pearl Status",
                value=pearl_status,
                inline=False
            )
        
        # Check for court cases - wrap blocking .stream() call
        current_db = await ensure_firestore()
        court_cases = await asyncio.to_thread(lambda: list(current_db.collection(COURT_CASES_COLLECTION).where(
            filter=FieldFilter('defendantIgn', '==', ign)
        ).stream()))
        
        if court_cases:
            case_statuses = {}
            for case_doc in court_cases:
                case = case_doc.to_dict()
                status = case.get('status', 'unknown')
                case_statuses[status] = case_statuses.get(status, 0) + 1
            
            status_str = " ‚Ä¢ ".join([f"{status.title()}: {count}" for status, count in case_statuses.items()])
            embed.add_field(
                name=f"‚öñÔ∏è Court Cases ({len(court_cases)} total)",
                value=status_str,
                inline=False
            )
        
        # Check if they're a lawyer - wrap blocking .stream() call
        lawyer_docs = await asyncio.to_thread(lambda: list(db.collection(LAWYERS_COLLECTION).where(
            filter=FieldFilter('userId', '==', user_id)
        ).limit(1).stream()))
        
        if lawyer_docs:
            lawyer = lawyer_docs[0].to_dict()
            lawyer_type = lawyer.get('lawyerType', 'unknown')
            bar_number = lawyer.get('barNumber', 'N/A')
            wins = lawyer.get('wins', 0)
            losses = lawyer.get('losses', 0)
            
            embed.add_field(
                name="‚öñÔ∏è Legal Profession",
                value=(
                    f"**Role:** {lawyer_type.replace('_', ' ').title()}\n"
                    f"**Bar #:** {bar_number}\n"
                    f"**Record:** {wins}W - {losses}L"
                ),
                inline=False
            )
        
        embed.set_footer(text=f"Citizen ID: {citizen_doc.id}")
        await interaction.followup.send(embed=embed, ephemeral=True)
        
    except Exception as e:
        print(f"[ERR] Citizen lookup failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error looking up citizen: {str(e)}", ephemeral=True)

@bot.tree.command(name="citizen_remove", description="[ADMIN] Remove a citizen or resident from the registry")
@app_commands.describe(user="Discord user to remove from registry")
async def citizen_remove_cmd(interaction: discord.Interaction, user: discord.Member):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Admin only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Removing from registry...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        citizen_query = await asyncio.to_thread(lambda: list(db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', user.id)).limit(1).stream()))
        
        if not citizen_query:
            return await interaction.edit_original_response(content=f"‚ùå {user.mention} is not registered.")
        
        citizen_doc = citizen_query[0]
        citizen_data = citizen_doc.to_dict()
        ign = citizen_data.get('ign', 'Unknown')
        citizenship_type = citizen_data.get('citizenshipType', 'unknown')
        
        await asyncio.to_thread(lambda: citizen_doc.reference.delete())
        
        roles_to_remove = []
        if CITIZEN_ROLE_ID:
            r = interaction.guild.get_role(CITIZEN_ROLE_ID)
            if r: roles_to_remove.append(r)
        if UNIVERSAL_CITIZEN_ROLE_ID:
            r = interaction.guild.get_role(UNIVERSAL_CITIZEN_ROLE_ID)
            if r: roles_to_remove.append(r)
        if SECONDARY_CITIZEN_ROLE_ID:
            r = interaction.guild.get_role(SECONDARY_CITIZEN_ROLE_ID)
            if r: roles_to_remove.append(r)
        if RESIDENT_ROLE_ID:
            r = interaction.guild.get_role(RESIDENT_ROLE_ID)
            if r: roles_to_remove.append(r)
        
        if roles_to_remove:
            try:
                await user.remove_roles(*roles_to_remove, reason=f"Removed from registry by {interaction.user}")
            except discord.Forbidden:
                pass
        
        await interaction.edit_original_response(content=f"‚úÖ Removed **{ign}** ({user.mention}) from registry.\nType was: {citizenship_type.title()}")
        print(f"[OK] {interaction.user} removed {ign} ({user}) from registry")
        
    except Exception as e:
        print(f"[ERR] Citizen remove failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@bot.tree.command(name="citizen_promote", description="[ADMIN] Promote a resident to citizen status")
@app_commands.describe(user="Resident to promote", citizenship_type="New citizenship type")
@app_commands.choices(citizenship_type=[
    app_commands.Choice(name="Primary Citizen", value="primary"),
    app_commands.Choice(name="Secondary Citizen", value="secondary")
])
async def citizen_promote_cmd(interaction: discord.Interaction, user: discord.Member, citizenship_type: str):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Admin only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Promoting to citizen...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        citizen_query = await asyncio.to_thread(lambda: list(db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', user.id)).limit(1).stream()))
        
        if not citizen_query:
            return await interaction.edit_original_response(content=f"‚ùå {user.mention} is not registered.")
        
        citizen_doc = citizen_query[0]
        citizen_data = citizen_doc.to_dict()
        current_type = citizen_data.get('citizenshipType', 'unknown')
        ign = citizen_data.get('ign', 'Unknown')
        
        if current_type != 'resident':
            return await interaction.edit_original_response(content=f"‚ùå {user.mention} is already a citizen ({current_type}).")
        
        await asyncio.to_thread(lambda: citizen_doc.reference.update({
            'citizenshipType': citizenship_type,
            'promotedAt': datetime.now(timezone.utc),
            'promotedBy': str(interaction.user)
        }))
        
        roles_to_add = []
        roles_to_remove = []
        
        if UNIVERSAL_CITIZEN_ROLE_ID:
            r = interaction.guild.get_role(UNIVERSAL_CITIZEN_ROLE_ID)
            if r: roles_to_add.append(r)
        if citizenship_type == 'secondary' and SECONDARY_CITIZEN_ROLE_ID:
            r = interaction.guild.get_role(SECONDARY_CITIZEN_ROLE_ID)
            if r: roles_to_add.append(r)
        if RESIDENT_ROLE_ID:
            r = interaction.guild.get_role(RESIDENT_ROLE_ID)
            if r: roles_to_remove.append(r)
        
        try:
            if roles_to_add:
                await user.add_roles(*roles_to_add, reason=f"Promoted to citizen by {interaction.user}")
            if roles_to_remove:
                await user.remove_roles(*roles_to_remove, reason=f"Promoted from resident")
        except discord.Forbidden:
            pass
        
        type_label = "Primary Citizen" if citizenship_type == "primary" else "Secondary Citizen"
        await interaction.edit_original_response(content=f"‚úÖ Promoted **{ign}** ({user.mention}) from Resident to **{type_label}**!")
        print(f"[OK] {interaction.user} promoted {ign} to {citizenship_type}")
        
    except Exception as e:
        print(f"[ERR] Citizen promote failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@bot.tree.command(name="citizen_stats", description="View citizen statistics dashboard with growth data")
async def citizen_stats_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    try:
        all_citizens = await asyncio.to_thread(lambda: list(db.collection(CITIZENS_COLLECTION).stream()))
        
        primary = []
        secondary = []
        residents = []
        newest_members = []
        
        for doc in all_citizens:
            data = doc.to_dict()
            citizenship_type = data.get('citizenshipType', 'primary')
            ign = data.get('ign', 'Unknown')
            registered_at = data.get('registeredAt')
            
            entry = {'ign': ign, 'registered_at': registered_at, 'type': citizenship_type}
            
            if citizenship_type == 'primary':
                primary.append(entry)
            elif citizenship_type == 'secondary':
                secondary.append(entry)
            elif citizenship_type == 'resident':
                residents.append(entry)
            
            if registered_at:
                newest_members.append(entry)
        
        newest_members.sort(key=lambda x: x['registered_at'] if x['registered_at'] else datetime.min.replace(tzinfo=timezone.utc), reverse=True)
        newest_5 = newest_members[:5]
        
        total_snitch_triggers = 0
        top_active = []
        try:
            snitch_docs = await asyncio.to_thread(lambda: list(db.collection(SNITCH_LOGS_COLLECTION).stream()))
            snitch_counts = {}
            for doc in snitch_docs:
                player = doc.to_dict().get('player', '')
                if player:
                    snitch_counts[player] = snitch_counts.get(player, 0) + 1
                    total_snitch_triggers += 1
            
            sorted_players = sorted(snitch_counts.items(), key=lambda x: x[1], reverse=True)[:5]
            top_active = sorted_players
        except:
            pass
        
        now = datetime.now(timezone.utc)
        last_7_days = sum(1 for m in newest_members if m['registered_at'] and (now - m['registered_at']).days <= 7)
        last_30_days = sum(1 for m in newest_members if m['registered_at'] and (now - m['registered_at']).days <= 30)
        
        senators = calculate_senators(len(primary))
        
        embed = discord.Embed(
            title="üìä Citizen Statistics Dashboard",
            color=discord.Color.from_str("#1f5123")
        )
        
        embed.add_field(
            name="üìà Population",
            value=f"üèõÔ∏è Primary Citizens: **{len(primary)}**\nüåê Secondary Citizens: **{len(secondary)}**\nüè† Residents: **{len(residents)}**\nüìä Total: **{len(all_citizens)}**",
            inline=True
        )
        
        embed.add_field(
            name="üèõÔ∏è Government",
            value=f"Senate Seats: **{senators}**\nVoting Citizens: **{len(primary) + len(secondary)}**",
            inline=True
        )
        
        embed.add_field(
            name="üìÖ Growth",
            value=f"Last 7 days: **+{last_7_days}**\nLast 30 days: **+{last_30_days}**",
            inline=True
        )
        
        if newest_5:
            newest_str = "\n".join([f"‚Ä¢ **{m['ign']}** ({m['type'].title()}) - {m['registered_at'].astimezone(EST).strftime('%b %d') if m['registered_at'] else 'Unknown'}" for m in newest_5])
            embed.add_field(name="üÜï Newest Members", value=newest_str, inline=False)
        
        if top_active:
            active_str = "\n".join([f"‚Ä¢ **{p[0]}**: {p[1]} triggers" for p in top_active])
            embed.add_field(name="üéØ Most Active (Snitch Triggers)", value=active_str, inline=False)
        
        embed.add_field(name="üì° Total Snitch Activity", value=f"{total_snitch_triggers} recorded triggers", inline=False)
        
        embed.set_footer(text=f"‚ö†Ô∏è Residents are not citizens and have limited rights. | Generated {datetime.now(EST).strftime('%I:%M %p EST')}")
        
        await interaction.followup.send(embed=embed, ephemeral=True)
        
    except Exception as e:
        print(f"[ERR] Citizen stats failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)



        
    except Exception as e:
        print(f"[ERR] Federal flag failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")




# ============== CITIZEN RESIDENCY/CITY SYSTEM ==============

@bot.tree.command(name="set_city", description="Set your current city/district of residence")
async def set_city_cmd(interaction: discord.Interaction):
    """Citizens can set their own city of residence"""
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database unavailable.")
    
    # Check if user is a citizen
    citizen_docs = await asyncio.to_thread(
        lambda: list(db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', interaction.user.id)).limit(1).stream())
    )
    
    if not citizen_docs:
        return await interaction.edit_original_response(content="‚ùå You must be a registered citizen to set your city.")
    
    citizen_ref = citizen_docs[0].reference
    citizen_data = citizen_docs[0].to_dict()
    
    # Show region selection view
    view = RegionSelectView(citizen_ref, citizen_data, interaction.user)
    await interaction.edit_original_response(content="üèòÔ∏è **Select your region:**", view=view)


class RegionSelectView(ui.View):
    def __init__(self, citizen_ref, citizen_data, user):
        super().__init__(timeout=120)
        self.citizen_ref = citizen_ref
        self.citizen_data = citizen_data
        self.user = user
        
        # Add region dropdown
        options = [discord.SelectOption(label=region, value=region) for region in FLORABIS_REGIONS.keys()]
        self.add_item(RegionSelect(options, citizen_ref, citizen_data, user))


class RegionSelect(ui.Select):
    def __init__(self, options, citizen_ref, citizen_data, user):
        super().__init__(placeholder="Select a region...", options=options)
        self.citizen_ref = citizen_ref
        self.citizen_data = citizen_data
        self.user = user
    
    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("‚ùå This is not your selection.", ephemeral=True)
        
        region = self.values[0]
        cities = FLORABIS_REGIONS[region]
        
        # Show city selection
        view = CitySelectView(self.citizen_ref, self.citizen_data, self.user, region, cities)
        await interaction.response.edit_message(content=f"üèòÔ∏è **Select your city/district in {region}:**", view=view)


class CitySelectView(ui.View):
    def __init__(self, citizen_ref, citizen_data, user, region, cities):
        super().__init__(timeout=120)
        self.citizen_ref = citizen_ref
        self.citizen_data = citizen_data
        self.user = user
        self.region = region
        
        # Add city dropdown
        options = []
        for city_name, alt_name in cities:
            label = f"{city_name}" + (f" ({alt_name})" if alt_name else "")
            options.append(discord.SelectOption(label=label, value=city_name))
        self.add_item(CitySelect(options, citizen_ref, citizen_data, user, region))


class CitySelect(ui.Select):
    def __init__(self, options, citizen_ref, citizen_data, user, region):
        super().__init__(placeholder="Select a city/district...", options=options)
        self.citizen_ref = citizen_ref
        self.citizen_data = citizen_data
        self.user = user
        self.region = region
    
    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("‚ùå This is not your selection.", ephemeral=True)
        
        await interaction.response.defer()
        
        city = self.values[0]
        now = datetime.now(timezone.utc)
        
        # Get current residency history
        residency_history = self.citizen_data.get('residencyHistory', [])
        current_city = self.citizen_data.get('currentCity')
        current_region = self.citizen_data.get('currentRegion')
        
        # If there's a current city, move it to history
        if current_city and current_city != city:
            moved_in = self.citizen_data.get('movedInAt')
            residency_history.append({
                'city': current_city,
                'region': current_region,
                'movedIn': moved_in,
                'movedOut': now
            })
        
        # Update current city
        update_data = {
            'currentCity': city,
            'currentRegion': self.region,
            'movedInAt': now,
            'residencyHistory': residency_history
        }
        
        await asyncio.to_thread(lambda: self.citizen_ref.update(update_data))
        
        await interaction.edit_original_response(
            content=f"‚úÖ You are now a resident of **{city}** in **{self.region}**!",
            view=None
        )


@bot.tree.command(name="admin_set_city", description="[ADMIN] Set a citizen's city of residence")
@app_commands.describe(
    user="The citizen to update",
    region="The region",
    city="The city/district within the region"
)
@app_commands.choices(region=[
    app_commands.Choice(name="Flora Region", value="Flora Region"),
    app_commands.Choice(name="San Alejandro Region", value="San Alejandro Region"),
    app_commands.Choice(name="Wizard Region", value="Wizard Region"),
])
async def admin_set_city_cmd(interaction: discord.Interaction, user: discord.Member, region: str, city: str):
    """Admins, Alcalde Mayor, and Councilors can set city for any citizen"""
    # Check permissions (admin, councilor, or Alcalde Mayor)
    user_role_ids = [r.id for r in interaction.user.roles]
    is_councilor = ROYAL_COUNCILOR_ROLE_ID in user_role_ids
    is_alcalde = ALCALDE_MAYOR_ROLE_ID in user_role_ids
    has_permission = has_admin_role(interaction) or is_councilor or is_alcalde
    
    if not has_permission:
        return await interaction.response.send_message("‚ùå You need Admin, Councilor, or Alcalde Mayor permissions.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database unavailable.")
    
    # Find citizen
    citizen_docs = await asyncio.to_thread(
        lambda: list(db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', user.id)).limit(1).stream())
    )
    
    if not citizen_docs:
        return await interaction.edit_original_response(content=f"‚ùå {user.mention} is not a registered citizen.")
    
    citizen_ref = citizen_docs[0].reference
    citizen_data = citizen_docs[0].to_dict()
    
    # Validate city exists in region
    valid_cities = [c[0] for c in FLORABIS_REGIONS.get(region, [])]
    if city not in valid_cities:
        city_list = ", ".join(valid_cities)
        return await interaction.edit_original_response(content=f"‚ùå Invalid city. Valid cities in {region}: {city_list}")
    
    now = datetime.now(timezone.utc)
    
    # Get current residency history
    residency_history = citizen_data.get('residencyHistory', [])
    current_city = citizen_data.get('currentCity')
    current_region = citizen_data.get('currentRegion')
    
    # If there's a current city, move it to history
    if current_city and current_city != city:
        moved_in = citizen_data.get('movedInAt')
        residency_history.append({
            'city': current_city,
            'region': current_region,
            'movedIn': moved_in,
            'movedOut': now
        })
    
    # Update current city
    update_data = {
        'currentCity': city,
        'currentRegion': region,
        'movedInAt': now,
        'residencyHistory': residency_history,
        'citySetBy': interaction.user.id
    }
    
    await asyncio.to_thread(lambda: citizen_ref.update(update_data))
    
    await interaction.edit_original_response(
        content=f"‚úÖ Set {user.mention}'s residence to **{city}** in **{region}**."
    )


@bot.tree.command(name="residency_history", description="View your residency history in Florab√≠s")
async def residency_history_cmd(interaction: discord.Interaction):
    """View residency history for a citizen"""
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database unavailable.")
    
    # Find citizen
    citizen_docs = await asyncio.to_thread(
        lambda: list(db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', interaction.user.id)).limit(1).stream())
    )
    
    if not citizen_docs:
        return await interaction.edit_original_response(content="‚ùå You are not a registered citizen.")
    
    citizen_data = citizen_docs[0].to_dict()
    current_city = citizen_data.get('currentCity')
    current_region = citizen_data.get('currentRegion')
    moved_in_at = citizen_data.get('movedInAt')
    history = citizen_data.get('residencyHistory', [])
    
    if not current_city and not history:
        return await interaction.edit_original_response(content="üìç You haven't set your city yet. Use `/set_city` to set your residence.")
    
    embed = discord.Embed(
        title=f"üèòÔ∏è Residency History for {interaction.user.display_name}",
        color=discord.Color.blue()
    )
    
    # Current residence
    if current_city:
        moved_in_str = moved_in_at.strftime("%B %d, %Y") if moved_in_at else "Unknown"
        embed.add_field(
            name="üìç Current Residence",
            value=f"**{current_city}**\n{current_region}\nSince: {moved_in_str}",
            inline=False
        )
    
    # Previous residences
    if history:
        prev_text = ""
        for i, h in enumerate(reversed(history[-5:])):  # Last 5 residences
            city = h.get('city', 'Unknown')
            region = h.get('region', 'Unknown')
            moved_in = h.get('movedIn')
            moved_out = h.get('movedOut')
            in_str = moved_in.strftime("%b %Y") if moved_in else "?"
            out_str = moved_out.strftime("%b %Y") if moved_out else "?"
            prev_text += f"‚Ä¢ **{city}** ({region}) - {in_str} to {out_str}\n"
        
        embed.add_field(name="üìú Previous Residences", value=prev_text or "None", inline=False)
    
    await interaction.edit_original_response(embed=embed)


# ============== CRIMINAL RECORDS SYSTEM ==============


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CITY INFO & LORDS COMMANDS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@bot.tree.command(name="cities", description="View all cities/districts with citizen counts and lords")
async def cities_cmd(interaction: discord.Interaction):
    """Display official Florab√≠s residency registry"""
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    try:
        current_db = await ensure_firestore()
        
        # Get all citizens with their current city
        citizens = await asyncio.to_thread(
            lambda: list(current_db.collection(CITIZENS_COLLECTION).stream())
        )
        
        # Count citizens per city
        city_counts = {}
        for doc in citizens:
            data = doc.to_dict()
            city = data.get('currentCity')
            if city:
                city_counts[city] = city_counts.get(city, 0) + 1
        
        # Calculate totals
        total_citizens = len(citizens)
        citizens_with_city = sum(city_counts.values())
        citizens_no_city = total_citizens - citizens_with_city
        
        # Region styling with unique Florab√≠s identity
        region_styles = {
            "Flora Region": {"emoji": "‚ùÑÔ∏è", "title": "Reino de Flora", "subtitle": "Winter Crown Lands"},
            "San Alejandro Region": {"emoji": "üèõÔ∏è", "title": "San Alejandro", "subtitle": "Seat of Government"},
            "Wizard Region": {"emoji": "‚ú®", "title": "Reino M√°gico", "subtitle": "Arcane Sanctum"},
        }
        
        # Build official census embed
        embed = discord.Embed(
            title="üìú Registro Real de Distritos",
            description=(
                f"*Custodiado por el Consejo Real*\n\n"
                f"**Poblaci√≥n Total:** {total_citizens} ciudadanos\n"
                f"**Registrados:** {citizens_with_city} | **Sin Registrar:** {citizens_no_city}"
            ),
            color=discord.Color.from_str("#1f5123")
        )
        
        for region, cities in FLORABIS_REGIONS.items():
            style = region_styles.get(region, {"emoji": "üèõÔ∏è", "title": region, "subtitle": ""})
            
            # Calculate region total
            region_total = sum(city_counts.get(c[0], 0) for c in cities)
            
            district_lines = []
            for city_name, alt_name in cities:
                count = city_counts.get(city_name, 0)
                alt_display = f" *({alt_name})*" if alt_name else ""
                district_lines.append(f"‚öúÔ∏è **{city_name}**{alt_display} ‚Äî üßæ {count}")
            
            embed.add_field(
                name=f"{style['emoji']} {style['title']} ‚Äî {region_total} ciudadanos",
                value="\n".join(district_lines) if district_lines else "*Sin distritos*",
                inline=False
            )
        
        # Official timestamp footer
        now_est = datetime.now(EST).strftime("%d %b %Y, %I:%M %p EST")
        embed.set_footer(text=f"Confidencial ‚Ä¢ Actualizado: {now_est}")
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Cities command error: {e}")
        await interaction.followup.send(f"‚ùå Error loading cities: {e}", ephemeral=True)




@bot.tree.command(name="citizen_record_add", description="[ADMIN] Add a criminal record for a citizen")
@app_commands.describe(
    user="Discord user with the criminal record",
    jurisdiction="State (Florab√≠s) or Federal (IF) crime",
    charge="The crime they were convicted of",
    record_duration="Days the record stays visible after sentence served (default: 60)"
)
@app_commands.choices(jurisdiction=[
    app_commands.Choice(name="State (Florab√≠s Court)", value="STATE"),
    app_commands.Choice(name="Federal (IF Court)", value="FEDERAL")
])
async def citizen_record_add_cmd(interaction: discord.Interaction, user: discord.Member, jurisdiction: str, charge: str, record_duration: int = 60):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Admin only.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        citizen_query = await asyncio.to_thread(lambda: list(db.collection(CITIZENS_COLLECTION).where(filter=FieldFilter('userId', '==', user.id)).limit(1).stream()))
        
        if not citizen_query:
            return await interaction.followup.send(f"‚ùå {user.mention} is not registered.")
        
        citizen_data = citizen_query[0].to_dict()
        ign = citizen_data.get('ign', 'Unknown')
        
        # Create criminal record
        record_id = f"REC-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}"
        await asyncio.to_thread(lambda: db.collection(CRIMINAL_RECORDS_COLLECTION).document(record_id).set({
            'recordId': record_id,
            'citizenId': str(user.id),
            'ign': ign,
            'jurisdiction': jurisdiction,
            'charge': charge,
            'status': 'SERVING',  # SERVING -> ACTIVE (on release) -> EXPIRED
            'createdAt': datetime.now(timezone.utc),
            'createdBy': str(interaction.user),
            'sentenceCompletedAt': None,
            'expiresAt': None,
            'expiryDays': record_duration
        }))
        
        await interaction.followup.send(
            f"üìú **Criminal Record Created**\n\n"
            f"**Record ID:** `{record_id}`\n"
            f"**Citizen:** {ign}\n"
            f"**Jurisdiction:** {jurisdiction}\n"
            f"**Charge:** {charge}\n"
            f"**Status:** Serving sentence\n"
            f"**Record Duration:** {record_duration} days after release\n\n"
            f"Use `/citizen_record_release` when they complete their sentence."
        )
        print(f"[OK] {interaction.user} added criminal record {record_id} for {ign}: {charge}")
        
    except Exception as e:
        print(f"[ERR] Record add failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")


@bot.tree.command(name="citizen_record_release", description="[ADMIN] Mark a sentence as served - starts record expiry countdown")
@app_commands.describe(
    record_id="The record ID (e.g., REC-20241226123456)",
    release_date="Optional: Past release date (YYYY-MM-DD). Defaults to today."
)
async def citizen_record_release_cmd(interaction: discord.Interaction, record_id: str, release_date: str = None):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Admin only.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        record_ref = db.collection(CRIMINAL_RECORDS_COLLECTION).document(record_id)
        record_doc = await asyncio.to_thread(lambda: record_ref.get())
        
        if not record_doc.exists:
            return await interaction.followup.send(f"‚ùå Record `{record_id}` not found.")
        
        record = record_doc.to_dict()
        
        # Parse release date or use now
        if release_date:
            try:
                release_dt = datetime.strptime(release_date, "%Y-%m-%d").replace(tzinfo=timezone.utc)
            except ValueError:
                return await interaction.followup.send("‚ùå Invalid date format. Use YYYY-MM-DD.")
        else:
            release_dt = datetime.now(timezone.utc)
        
        # Calculate expiry
        expiry_days = record.get('expiryDays', 60)
        expires_at = release_dt + timedelta(days=expiry_days)
        
        await asyncio.to_thread(lambda: record_ref.update({
            'status': 'ACTIVE',
            'sentenceCompletedAt': release_dt,
            'expiresAt': expires_at,
            'releasedBy': str(interaction.user),
            'releasedAt': datetime.now(timezone.utc)
        }))
        
        ign = record.get('ign', 'Unknown')
        await interaction.followup.send(
            f"‚úÖ **Sentence Completed - Record Active**\n\n"
            f"**Record ID:** `{record_id}`\n"
            f"**Citizen:** {ign}\n"
            f"**Charge:** {record.get('charge')}\n"
            f"**Released:** {release_dt.strftime('%Y-%m-%d')}\n"
            f"**Record Expires:** {expires_at.strftime('%Y-%m-%d')} ({expiry_days} days)\n\n"
            f"Record will auto-expire and clear from `/citizen_lookup`."
        )
        print(f"[OK] {interaction.user} released {ign} - record {record_id} expires {expires_at}")
        
    except Exception as e:
        print(f"[ERR] Record release failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")


@bot.tree.command(name="citizen_record_list", description="[ADMIN] View all criminal records for a citizen")
@app_commands.describe(user="Discord user to check")
async def citizen_record_list_cmd(interaction: discord.Interaction, user: discord.Member):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Admin only.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        records = await asyncio.to_thread(lambda: list(db.collection(CRIMINAL_RECORDS_COLLECTION).where(
            filter=FieldFilter('citizenId', '==', str(user.id))
        ).stream()))
        
        if not records:
            return await interaction.followup.send(f"‚úÖ {user.mention} has no criminal records.")
        
        embed = discord.Embed(
            title=f"üìú Criminal Records for {user.display_name}",
            color=discord.Color.red()
        )
        
        for rec_doc in records:
            r = rec_doc.to_dict()
            status = r.get('status', 'UNKNOWN')
            expires_at = r.get('expiresAt')
            
            if status == 'SERVING':
                status_text = "‚è≥ Serving Sentence"
            elif status == 'ACTIVE' and expires_at:
                days_left = (expires_at - datetime.now(timezone.utc)).days
                status_text = f"üî¥ Active ({days_left}d remaining)" if days_left > 0 else "‚è∞ Expiring soon"
            elif status == 'EXPIRED':
                status_text = "‚úÖ Expired"
            else:
                status_text = status
            
            embed.add_field(
                name=f"{r.get('jurisdiction', 'STATE')} - {r.get('charge', 'Unknown')}",
                value=f"**ID:** `{rec_doc.id}`\n**Status:** {status_text}",
                inline=False
            )
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Record list failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")


@bot.tree.command(name="citizen_record_remove", description="[ADMIN] Manually expire/remove a criminal record")
@app_commands.describe(record_id="The record ID to expire")
async def citizen_record_remove_cmd(interaction: discord.Interaction, record_id: str):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Admin only.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        record_ref = db.collection(CRIMINAL_RECORDS_COLLECTION).document(record_id)
        record_doc = await asyncio.to_thread(lambda: record_ref.get())
        
        if not record_doc.exists:
            return await interaction.followup.send(f"‚ùå Record `{record_id}` not found.")
        
        await asyncio.to_thread(lambda: record_ref.update({
            'status': 'EXPIRED',
            'expiredBy': str(interaction.user),
            'expiredAt': datetime.now(timezone.utc),
            'manualExpiry': True
        }))
        
        await interaction.followup.send(f"‚úÖ Record `{record_id}` has been expired and will no longer show in lookups.")
        print(f"[OK] {interaction.user} manually expired record {record_id}")
        
    except Exception as e:
        print(f"[ERR] Record remove failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")



@bot.tree.command(name="court_create_thread", description="[ADMIN] Manually create a private thread for an existing court case")
@app_commands.describe(case_id="The case ID (e.g., CV-0FC3A or CR-ABC123)")
async def court_create_thread_cmd(interaction: discord.Interaction, case_id: str):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Admin only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Creating courtroom thread...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get case from database - try both document ID and caseId field
        case_doc = None
        case_ref = None
        
        # First try by document ID
        case_ref = db.collection(COURT_CASES_COLLECTION).document(case_id)
        doc = await asyncio.to_thread(lambda: case_ref.get())
        if doc.exists:
            case_doc = doc
        else:
            # Search by caseId field (case-insensitive)
            cases = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(
                filter=FieldFilter('caseId', '==', case_id)
            ).limit(1).stream()))
            if not cases:
                # Try uppercase
                cases = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(
                    filter=FieldFilter('caseId', '==', case_id.upper())
                ).limit(1).stream()))
            if cases:
                case_doc = cases[0]
                case_ref = case_doc.reference
        
        if not case_doc or not case_doc.exists:
            # List available cases for debugging
            all_cases = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).order_by('filedAt', direction=firestore.Query.DESCENDING).limit(5).stream()))
            case_list = [f"`{c.to_dict().get('caseId', c.id)}`" for c in all_cases]
            return await interaction.edit_original_response(content=f"‚ùå Case `{case_id}` not found.\n\n**Recent cases:** {', '.join(case_list) if case_list else 'None'}")
        
        case_data = case_doc.to_dict()
        case_type = case_data.get('caseType', 'Criminal')
        
        # Determine channel
        channel_id = CRIMINAL_CASES_CHANNEL_ID if case_type == "Criminal" else CIVIL_CASES_CHANNEL_ID
        court_channel = interaction.guild.get_channel(channel_id)
        
        if not court_channel:
            return await interaction.edit_original_response(content=f"‚ùå Court channel not found (ID: {channel_id}).")
        
        # Create private thread
        case_type_emoji = "‚öîÔ∏è" if case_type == "Criminal" else "üìú"
        thread = await court_channel.create_thread(
            name=f"‚öñÔ∏è Courtroom: {case_id}",
            type=discord.ChannelType.private_thread,
            invitable=True,
            auto_archive_duration=10080  # 7 days
        )
        
        # Save thread ID to database
        await asyncio.to_thread(lambda: case_ref.update({
            'courtroomThreadId': thread.id
        }))
        
        # Add plaintiff to thread
        plaintiff_id = case_data.get('plaintiffId')
        if plaintiff_id:
            try:
                plaintiff = await interaction.guild.fetch_member(plaintiff_id)
                await thread.add_user(plaintiff)
            except:
                pass
        
        # Add magistrates
        if MAGISTRATE_ROLE_ID:
            magistrate_role = interaction.guild.get_role(MAGISTRATE_ROLE_ID)
            if magistrate_role:
                for member in magistrate_role.members:
                    try:
                        await thread.add_user(member)
                    except:
                        pass
        
        # Get filed time
        filed_at = case_data.get('filedAt')
        if filed_at:
            if hasattr(filed_at, 'replace') and filed_at.tzinfo is None:
                filed_at = filed_at.replace(tzinfo=timezone.utc)
            filed_time = filed_at.astimezone(EST).strftime('%b %d, %Y at %I:%M %p EST')
        else:
            filed_time = "Unknown"
        
        # Post case information
        case_embed = discord.Embed(
            title=f"{case_type_emoji} CASE: {case_type.upper()} #{case_id}",
            description=(
                f"**Case ID:** {case_id}\n"
                f"**Type:** {case_type}\n"
                f"**Status:** {case_data.get('status', 'pending').title()}\n"
                f"**Filed:** {filed_time}\n\n"
                f"**Plaintiff:** <@{plaintiff_id}>\n"
                f"**Defendant IGN:** {case_data.get('defendantIgn')}\n\n"
                f"**Charges/Claims:**\n{case_data.get('charges', 'N/A')}\n\n"
                f"**Evidence:**\n{case_data.get('evidence', 'N/A')}"
            ),
            color=0x1e3a5f
        )
        case_embed.set_footer(text=f"‚öñÔ∏è Florab√≠s State Judiciary | Private Courtroom | Thread manually created")
        
        await thread.send(embed=case_embed)
        
        # Ping magistrates
        if MAGISTRATE_ROLE_ID:
            await thread.send(f"<@&{MAGISTRATE_ROLE_ID}> - Case thread manually created by {interaction.user.mention}")
        
        await interaction.edit_original_response(content=f"‚úÖ **Private courtroom thread created for case {case_id}**\n\nThread: {thread.mention}")
        print(f"[OK] {interaction.user} manually created thread for case {case_id}")
        
    except Exception as e:
        print(f"[ERR] Failed to create court thread: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@court_group.command(name="remove_case", description="[ADMIN/JUDGE] Permanently delete a court case from database")
async def remove_case_cmd(interaction: discord.Interaction, case_id: str):
    """Admin/Judge command to permanently delete a case from the database"""
    # Defer IMMEDIATELY to prevent timeout (must respond within 3 seconds)
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not has_magistrate_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators and magistrates can use this command.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Strip the # prefix if user included it
        clean_case_id = case_id.lstrip('#')
        
        # Find the case - wrap blocking .get() call
        case_ref = db.collection(COURT_CASES_COLLECTION).document(clean_case_id)
        case_doc = await asyncio.to_thread(lambda: case_ref.get())
        
        if not case_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} not found in database.")
        
        case_data = case_doc.to_dict()
        case_type = case_data.get('caseType', 'Unknown')
        defendant = case_data.get('defendantIgn', 'Unknown')
        
        # Delete the case
        case_ref.delete()
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Case Permanently Deleted**\n\n"
            f"**Case ID:** #{clean_case_id}\n"
            f"**Type:** {case_type}\n"
            f"**Defendant:** {defendant}\n"
            f"**Deleted by:** {interaction.user.mention}\n\n"
            f"*This case has been permanently removed from the database.*")
        
        print(f"[OK] Admin {interaction.user} deleted case #{clean_case_id} ({case_type} - {defendant})")
        
    except Exception as e:
        print(f"[ERR] Failed to remove case: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to delete case: {str(e)}")

@court_group.command(name="dismiss", description="[ADMIN/JUDGE] Dismiss a specific case by ID")
@app_commands.describe(
    case_id="Case ID to dismiss (e.g., CR-11CFD7)",
    reason="Reason for dismissal"
)
async def dismiss_case_cmd(interaction: discord.Interaction, case_id: str, reason: str = "Case dismissed by court"):
    """Admin/Judge command to dismiss a specific case"""
    await interaction.response.defer(ephemeral=True)
    await interaction.followup.send("‚è≥ Dismissing case...", ephemeral=True)
    
    if not has_magistrate_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators and magistrates can dismiss cases.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        clean_case_id = case_id.upper().replace("#", "").strip()
        
        case_ref = db.collection(COURT_CASES_COLLECTION).document(clean_case_id)
        case_doc = await asyncio.to_thread(lambda: case_ref.get())
        
        if not case_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} not found in database.")
        
        case_data = case_doc.to_dict()
        case_type = case_data.get('caseType', 'Unknown')
        defendant = case_data.get('defendantIgn', 'Unknown')
        current_status = case_data.get('status', 'Unknown')
        
        # Update the case to dismissed status
        await asyncio.to_thread(lambda: case_ref.update({
            'status': 'dismissed',
            'verdict': 'Case Dismissed',
            'dismissalReason': reason,
            'dismissedAt': datetime.now(timezone.utc),
            'dismissedBy': str(interaction.user)
        }))
        
        # Lock and archive the courtroom thread if it exists
        thread_status = ""
        thread_id = case_data.get('courtroomThreadId')
        if thread_id:
            try:
                thread = await interaction.guild.fetch_channel(int(thread_id))
                if isinstance(thread, discord.Thread):
                    # Send dismissal notice to thread
                    dismissal_embed = discord.Embed(
                        title=f"üîí CASE DISMISSED: #{clean_case_id}",
                        description=f"This case has been dismissed by {interaction.user.mention}.",
                        color=discord.Color.dark_grey()
                    )
                    dismissal_embed.add_field(name="Reason", value=reason, inline=False)
                    dismissal_embed.add_field(name="Defendant", value=defendant, inline=True)
                    dismissal_embed.add_field(name="Case Type", value=case_type, inline=True)
                    dismissal_embed.set_footer(text=f"Case dismissed at {datetime.now(EST).strftime('%Y-%m-%d %I:%M %p EST')}")
                    await thread.send(embed=dismissal_embed)
                    
                    # Lock and archive the thread
                    await thread.edit(locked=True, archived=True)
                    thread_status = "\nüîí **Thread:** Locked and archived"
                    print(f"[OK] Locked and archived thread {thread_id} for case #{clean_case_id}")
            except Exception as thread_err:
                thread_status = f"\n‚ö†Ô∏è **Thread:** Could not lock (may be already archived)"
                print(f"[WARN] Could not lock thread for case #{clean_case_id}: {thread_err}")
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Case Dismissed**\n\n"
            f"**Case ID:** #{clean_case_id}\n"
            f"**Type:** {case_type}\n"
            f"**Defendant:** {defendant}\n"
            f"**Previous Status:** {current_status}\n"
            f"**Reason:** {reason}\n"
            f"**Dismissed by:** {interaction.user.mention}{thread_status}\n\n"
            f"*This case has been closed without a verdict.*")
        
        print(f"[OK] {interaction.user} dismissed case #{clean_case_id} - Reason: {reason}")
        
    except Exception as e:
        print(f"[ERR] Failed to dismiss case: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to dismiss case: {str(e)}")

@court_group.command(name="bulk_close_pending", description="[ADMIN/JUDGE] Close all pending cases (mark as resolved)")
async def bulk_close_pending_cmd(interaction: discord.Interaction):
    """Admin/Judge command to bulk close all pending cases that can't be interacted with"""
    # Defer IMMEDIATELY to prevent timeout (must respond within 3 seconds)
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not has_magistrate_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators and magistrates can use this command.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Find all pending cases - wrap blocking .stream() call
        pending_cases = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(
            filter=FieldFilter('status', '==', 'pending')
        ).stream()))
        
        if not pending_cases:
            return await interaction.edit_original_response(content="üìã No pending cases found in the database.")
        
        # Update all to "closed" status
        closed_count = 0
        for case_doc in pending_cases:
            case_id = case_doc.id
            db.collection(COURT_CASES_COLLECTION).document(case_id).update({
                'status': 'closed',
                'verdict': 'Case closed administratively',
                'closedAt': datetime.now(timezone.utc),
                'closedBy': str(interaction.user)
            })
            closed_count += 1
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Bulk Case Closure Complete**\n\n"
            f"**Cases Closed:** {closed_count}\n"
            f"**Status:** All pending cases marked as resolved\n"
            f"**Closed by:** {interaction.user.mention}\n\n"
            f"*All pending cases have been administratively closed and marked as resolved.*")
        
        print(f"[OK] Admin {interaction.user} bulk-closed {closed_count} pending cases")
        
    except Exception as e:
        print(f"[ERR] Failed to bulk close cases: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to bulk close cases: {str(e)}")

@court_group.command(name="fix_thread", description="[ADMIN] Link an existing thread to a case missing courtroomThreadId")
@app_commands.describe(
    case_id="Case ID (e.g., CR-11CFD7)",
    thread_id="Thread ID to link (right-click thread ‚Üí Copy ID)"
)
async def fix_case_thread_cmd(interaction: discord.Interaction, case_id: str, thread_id: str):
    """Admin command to manually add courtroomThreadId to a case"""
    await interaction.response.send_message("‚è≥ Linking thread to case...", ephemeral=True)
    
    if not has_magistrate_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators and magistrates can use this command.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        clean_case_id = case_id.upper().replace("#", "").strip()
        
        case_ref = db.collection(COURT_CASES_COLLECTION).document(clean_case_id)
        case_doc = case_ref.get()
        
        if not case_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} not found.")
        
        try:
            thread = await interaction.guild.fetch_channel(int(thread_id))
            if not isinstance(thread, discord.Thread):
                return await interaction.edit_original_response(content=f"‚ùå Channel ID {thread_id} is not a thread.")
        except:
            return await interaction.edit_original_response(content=f"‚ùå Could not find thread with ID {thread_id}. Make sure you copied the Thread ID correctly.")
        
        await asyncio.to_thread(lambda: case_ref.update({'courtroomThreadId': thread.id}))
        
        case_data = case_doc.to_dict()
        case_type = case_data.get('caseType', 'Criminal')
        
        action_embed = discord.Embed(
            title="‚öñÔ∏è COURTROOM ACTION PANEL",
            description=f"**Case #{clean_case_id}** - {case_type}\n\nUse the buttons below to claim roles or take actions.",
            color=0x1e3a5f
        )
        action_embed.set_footer(text=f"‚öñÔ∏è Case #{clean_case_id} | Florab√≠s State Judiciary")
        
        courtroom_view = CourtroomActionPanel(clean_case_id, case_type)
        action_message = await thread.send(embed=action_embed, view=courtroom_view)
        
        await asyncio.to_thread(lambda: case_ref.update({'actionPanelMessageId': action_message.id}))
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Thread Linked Successfully**\n\n"
            f"**Case ID:** #{clean_case_id}\n"
            f"**Thread:** {thread.mention}\n"
            f"**Thread ID:** `{thread.id}`\n\n"
            f"The courtroom thread has been linked to the case and the action panel has been posted!")
        
        print(f"[OK] Admin {interaction.user} linked thread {thread.id} to case {clean_case_id}")
        
    except Exception as e:
        print(f"[ERR] Failed to fix thread: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to link thread: {str(e)}")

@court_group.command(name="fix_panel", description="[ADMIN] Re-post action panel for a case missing buttons")
@app_commands.describe(case_id="Case ID (e.g., CR-11CFD7)")
async def fix_case_panel_cmd(interaction: discord.Interaction, case_id: str):
    """Admin command to manually repost the action panel for a broken case"""
    await interaction.response.send_message("‚è≥ Fixing case panel...", ephemeral=True)
    
    if not has_magistrate_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators and magistrates can use this command.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Clean up case ID
        clean_case_id = case_id.upper().replace("#", "").strip()
        
        # Get case from database
        case_ref = db.collection(COURT_CASES_COLLECTION).document(clean_case_id)
        case_doc = case_ref.get()
        
        if not case_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} not found.")
        
        case_data = case_doc.to_dict()
        courtroom_thread_id = case_data.get('courtroomThreadId')
        case_type = case_data.get('caseType', 'Criminal')
        
        if not courtroom_thread_id:
            return await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} has no courtroom thread.")
        
        # Fetch the courtroom thread
        try:
            thread = await interaction.guild.fetch_channel(courtroom_thread_id)
        except:
            return await interaction.edit_original_response(content=f"‚ùå Could not find courtroom thread for case #{clean_case_id}.")
        
        # Build and post action panel
        action_embed = discord.Embed(
            title="‚öñÔ∏è COURTROOM ACTION PANEL",
            description=f"**Case #{clean_case_id}** - {case_type}\n\nUse the buttons below to claim roles or take actions.",
            color=0x1e3a5f
        )
        action_embed.set_footer(text=f"‚öñÔ∏è Case #{clean_case_id} | Florab√≠s State Judiciary")
        
        courtroom_view = CourtroomActionPanel(clean_case_id, case_type)
        action_message = await thread.send(embed=action_embed, view=courtroom_view)
        
        # Update database with new action panel message ID
        await asyncio.to_thread(lambda: case_ref.update({'actionPanelMessageId': action_message.id}))
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Action Panel Fixed**\n\n"
            f"**Case ID:** #{clean_case_id}\n"
            f"**Thread:** {thread.mention}\n\n"
            f"The action panel with buttons has been posted to the courtroom thread.")
        
        print(f"[OK] Admin {interaction.user} fixed action panel for case {clean_case_id}")
        
    except Exception as e:
        print(f"[ERR] Failed to fix case panel: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to fix panel: {str(e)}")

@court_group.command(name="lawyers", description="‚öñÔ∏è View all registered attorneys, prosecutors, and defenders")
async def lawyers_directory_cmd(interaction: discord.Interaction):
    """Display complete directory of all registered legal professionals"""
    await interaction.response.send_message("‚è≥ Loading lawyer directory...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all lawyers from database
        all_lawyers = list(db.collection(LAWYERS_COLLECTION).stream())
        
        if not all_lawyers:
            return await interaction.edit_original_response(content="üìã No lawyers registered yet.\n\nüí° Use the Court Panel to register as a lawyer!")
        
        # Categorize lawyers by type
        attorneys = []
        defenders = []
        prosecutors = []
        
        for doc in all_lawyers:
            lawyer = doc.to_dict()
            lawyer_type = lawyer.get('lawyerType', 'attorney')
            
            # Build lawyer entry with clean formatting
            discord_id = lawyer.get('discordId')
            mention = f"<@{discord_id}>" if discord_id else lawyer.get('discordUsername', 'Unknown')
            ign = lawyer.get('ign', 'N/A')
            bar_num = lawyer.get('barNumber', 'N/A')
            wins = lawyer.get('wins', 0)
            losses = lawyer.get('losses', 0)
            total = wins + losses
            
            # Win rate calculation
            win_rate = f"{(wins/total*100):.0f}%" if total > 0 else "N/A"
            
            lawyer_entry = {
                'mention': mention,
                'ign': ign,
                'bar': bar_num,
                'record': f"{wins}W-{losses}L" if total > 0 else "No cases yet",
                'win_rate': win_rate
            }
            
            # Sort into categories
            if lawyer_type == 'public_defender':
                defenders.append(lawyer_entry)
            elif lawyer_type == 'prosecutor':
                prosecutors.append(lawyer_entry)
            else:
                attorneys.append(lawyer_entry)
        
        # Build the epic directory embed
        embed = discord.Embed(
            title="üèõÔ∏è FLORAB√çS BAR ASSOCIATION",
            description=(
                "**OFFICIAL DIRECTORY OF LEGAL PROFESSIONALS**\n"
                "\n"
                "*All licensed attorneys, defenders, and prosecutors of the Florab√≠s State Judiciary*"
            ),
            color=0x1a237e  # Courthouse dark blue
        )
        
        # Add attorneys section
        if attorneys:
            attorney_list = []
            for i, lawyer in enumerate(attorneys, 1):
                attorney_list.append(
                    f"**{i}.** {lawyer['mention']}\n"
                    f"    IGN: `{lawyer['ign']}` ‚Ä¢ Bar: `{lawyer['bar']}`\n"
                    f"    Record: {lawyer['record']} ({lawyer['win_rate']} win rate)"
                )
            
            embed.add_field(
                name=f"‚öñÔ∏è PRIVATE ATTORNEYS ({len(attorneys)})",
                value="\n\n".join(attorney_list) if attorney_list else "*None registered*",
                inline=False
            )
        
        # Add public defenders section
        if defenders:
            defender_list = []
            for i, lawyer in enumerate(defenders, 1):
                defender_list.append(
                    f"**{i}.** {lawyer['mention']}\n"
                    f"    IGN: `{lawyer['ign']}` ‚Ä¢ Bar: `{lawyer['bar']}`\n"
                    f"    Record: {lawyer['record']} ({lawyer['win_rate']} win rate)"
                )
            
            embed.add_field(
                name=f"üõ°Ô∏è PUBLIC DEFENDERS ({len(defenders)})",
                value="\n\n".join(defender_list) if defender_list else "*None registered*",
                inline=False
            )
        
        # Add prosecutors section
        if prosecutors:
            prosecutor_list = []
            for i, lawyer in enumerate(prosecutors, 1):
                prosecutor_list.append(
                    f"**{i}.** {lawyer['mention']}\n"
                    f"    IGN: `{lawyer['ign']}` ‚Ä¢ Bar: `{lawyer['bar']}`\n"
                    f"    Record: {lawyer['record']} ({lawyer['win_rate']} win rate)"
                )
            
            embed.add_field(
                name=f"‚öîÔ∏è STATE PROSECUTORS ({len(prosecutors)})",
                value="\n\n".join(prosecutor_list) if prosecutor_list else "*None registered*",
                inline=False
            )
        
        # Summary footer
        total_lawyers = len(all_lawyers)
        total_wins = sum(l.get('wins', 0) for l in [doc.to_dict() for doc in all_lawyers])
        total_cases = sum(l.get('totalCases', 0) for l in [doc.to_dict() for doc in all_lawyers])
        
        embed.set_footer(
            text=f"‚öñÔ∏è {total_lawyers} Active Legal Professionals ‚Ä¢ {total_cases} Total Cases Handled ‚Ä¢ {total_wins} Victories"
        )
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Failed to load lawyer directory: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to load directory: {str(e)}")

@court_group.command(name="disbar", description="[ADMIN] Remove a lawyer from the bar")
@app_commands.describe(user="The lawyer to disbar")
async def disbar_lawyer_cmd(interaction: discord.Interaction, user: discord.Member):
    """Admin command to remove a lawyer from the bar registry"""
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Processing disbarment...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        lawyer_data = get_lawyer_data(user.id)
        if not lawyer_data:
            return await interaction.edit_original_response(content=f"‚ùå {user.mention} is not registered as a lawyer.")
        
        lawyer_type = lawyer_data.get('lawyerType', 'unknown')
        bar_number = lawyer_data.get('barNumber', 'N/A')
        lawyer_id = lawyer_data.get('id')
        
        await asyncio.to_thread(lambda: db.collection(LAWYERS_COLLECTION).document(lawyer_id).delete())
        
        role_id = None
        if lawyer_type == 'attorney' and ATTORNEY_ROLE_ID:
            role_id = ATTORNEY_ROLE_ID
        elif lawyer_type == 'public_defender' and PUBLIC_DEFENDER_ROLE_ID:
            role_id = PUBLIC_DEFENDER_ROLE_ID
        elif lawyer_type == 'prosecutor' and STATE_PROSECUTOR_ROLE_ID:
            role_id = STATE_PROSECUTOR_ROLE_ID
        
        if role_id and interaction.guild:
            role = interaction.guild.get_role(role_id)
            if role and role in user.roles:
                try:
                    await user.remove_roles(role)
                except Exception as e:
                    print(f"[WARN] Failed to remove lawyer role: {e}")
        
        type_display = {'attorney': 'Attorney', 'public_defender': 'Public Defender', 'prosecutor': 'State Prosecutor'}.get(lawyer_type, lawyer_type)
        await interaction.edit_original_response(
            content=f"‚úÖ **Disbarred:** {user.mention}\n"
                    f"**Type:** {type_display}\n"
                    f"**Bar Number:** {bar_number}\n\n"
                    f"Their license has been revoked and role removed."
        )
        print(f"[COURT] Admin {interaction.user} disbarred {user} (Bar #{bar_number})")
        
    except Exception as e:
        print(f"[ERR] Disbar failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to disbar: {str(e)}")



@court_group.command(name="reassign", description="[ADMIN] Reassign magistrate, prosecutor, or defense on a case")
@app_commands.describe(
    case_id="The case ID",
    role="What role to reassign",
    new_person="The new person to assign"
)
@app_commands.choices(role=[
    app_commands.Choice(name="Magistrate", value="magistrate"),
    app_commands.Choice(name="Prosecutor", value="prosecutor"),
    app_commands.Choice(name="Defense Attorney", value="defense")
])
async def court_reassign(interaction: discord.Interaction, case_id: str, role: str, new_person: discord.Member):
    await interaction.response.defer(ephemeral=True)
    
    # Check permissions - magistrates or admins
    magistrate_role = interaction.guild.get_role(MAGISTRATE_ROLE_ID) if MAGISTRATE_ROLE_ID else None
    admin_role = interaction.guild.get_role(ADMIN_ROLE_ID) if ADMIN_ROLE_ID else None
    is_magistrate = magistrate_role and magistrate_role in interaction.user.roles
    is_admin = admin_role and admin_role in interaction.user.roles
    
    if not is_magistrate and not is_admin:
        return await interaction.followup.send("‚ùå Only Magistrates or Admins can reassign case roles.")
    
    if not db:
        return await interaction.followup.send("‚ùå Database unavailable.")
    
    try:
        clean_case_id = case_id.strip().upper()
        case_doc = await asyncio.to_thread(lambda: db.collection(COURT_CASES_COLLECTION).document(clean_case_id).get())
        
        if not case_doc.exists:
            return await interaction.followup.send(f"‚ùå Case **{clean_case_id}** not found.")
        
        case_data = case_doc.to_dict()
        thread_id = case_data.get('courtroomThreadId')
        old_person = None
        role_display = ""
        update_data = {}
        bar_num = ""
        
        if role == "magistrate":
            if magistrate_role and magistrate_role not in new_person.roles:
                return await interaction.followup.send(f"‚ùå {new_person.mention} is not a Magistrate.")
            old_person = case_data.get('magistrateName', 'None')
            role_display = "‚öñÔ∏è Magistrate"
            update_data = {
                'magistrateId': new_person.id,
                'magistrateName': str(new_person),
                'reassignedAt': datetime.now(timezone.utc),
                'reassignedBy': str(interaction.user),
                'reassignedById': interaction.user.id
            }
        elif role == "prosecutor":
            lawyer_data = get_lawyer_data(new_person.id)
            if not lawyer_data:
                return await interaction.followup.send(f"‚ùå {new_person.mention} is not a registered lawyer.")
            old_person = case_data.get('prosecutorName') or case_data.get('prosecutor', 'None')
            role_display = "‚öîÔ∏è Prosecutor"
            bar_num = lawyer_data.get('barNumber', 'N/A')
            update_data = {
                'prosecutorId': new_person.id,
                'prosecutorName': str(new_person),
                'prosecutor': str(new_person),
                'prosecutorBarNumber': bar_num,
                'prosecutorReassignedAt': datetime.now(timezone.utc),
                'prosecutorReassignedBy': str(interaction.user)
            }
        else:  # defense
            lawyer_data = get_lawyer_data(new_person.id)
            if not lawyer_data:
                return await interaction.followup.send(f"‚ùå {new_person.mention} is not a registered lawyer.")
            old_person = case_data.get('defenseAttorneyName') or case_data.get('defenseAttorney', 'None')
            role_display = "üõ°Ô∏è Defense Attorney"
            bar_num = lawyer_data.get('barNumber', 'N/A')
            update_data = {
                'defenseAttorneyId': new_person.id,
                'defenseAttorneyName': str(new_person),
                'defenseAttorney': str(new_person),
                'defenseBarNumber': bar_num,
                'defenseReassignedAt': datetime.now(timezone.utc),
                'defenseReassignedBy': str(interaction.user)
            }
        
        await asyncio.to_thread(lambda: case_doc.reference.update(update_data))
        
        # Update thread
        if thread_id:
            try:
                thread = interaction.guild.get_thread(thread_id)
                if not thread:
                    thread = await interaction.guild.fetch_channel(thread_id)
                if thread:
                    if thread.archived:
                        await thread.edit(archived=False)
                    await thread.add_user(new_person)
                    bar_info = f" (Bar #{bar_num})" if bar_num else ""
                    await thread.send(f"üîÑ **{role_display} Reassigned**\n\n**Previous:** {old_person}\n**New:** {new_person.mention}{bar_info}\n*Changed by {interaction.user.mention}*")
            except Exception as e:
                print(f"[WARN] Could not update thread: {e}")
        
        await interaction.followup.send(
            f"‚úÖ **{role_display} Reassigned**\n\n"
            f"**Case:** {clean_case_id}\n"
            f"**Previous:** {old_person}\n"
            f"**New:** {new_person.mention}"
        )
        print(f"[COURT] {role_display} on case {clean_case_id} reassigned from {old_person} to {new_person} by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Reassign failed: {e}")
        await interaction.followup.send(f"‚ùå Failed to reassign: {str(e)}")


@court_group.command(name="add_observer", description="[MAGISTRATE] Add a reporter/observer to a court thread (view-only)")
@app_commands.describe(
    case_id="The case ID",
    observer="The user to add as observer (typically a reporter)"
)
async def court_add_observer(interaction: discord.Interaction, case_id: str, observer: discord.Member):
    await interaction.response.defer(ephemeral=True)
    
    # Check if user is a magistrate or admin
    magistrate_role = interaction.guild.get_role(MAGISTRATE_ROLE_ID) if MAGISTRATE_ROLE_ID else None
    admin_role = interaction.guild.get_role(ADMIN_ROLE_ID) if ADMIN_ROLE_ID else None
    
    is_magistrate = magistrate_role and magistrate_role in interaction.user.roles
    is_admin = admin_role and admin_role in interaction.user.roles
    
    if not is_magistrate and not is_admin:
        return await interaction.followup.send("‚ùå Only Magistrates or Admins can add observers to court threads.")
    
    if not db:
        return await interaction.followup.send("‚ùå Database unavailable.")
    
    try:
        clean_case_id = case_id.strip().upper()
        case_doc = await asyncio.to_thread(lambda: db.collection(COURT_CASES_COLLECTION).document(clean_case_id).get())
        
        if not case_doc.exists:
            return await interaction.followup.send(f"‚ùå Case **{clean_case_id}** not found.")
        
        case_data = case_doc.to_dict()
        thread_id = case_data.get('courtroomThreadId')
        
        if not thread_id:
            return await interaction.followup.send(f"‚ùå Case **{clean_case_id}** has no courtroom thread.")
        
        # Get the thread
        try:
            thread = interaction.guild.get_thread(thread_id)
            if not thread:
                thread = await interaction.guild.fetch_channel(thread_id)
        except:
            return await interaction.followup.send(f"‚ùå Could not find thread for case **{clean_case_id}**.")
        
        # Unarchive if needed
        if thread.archived:
            await thread.edit(archived=False)
        
        # Add the observer
        await thread.add_user(observer)
        
        # Post observer notice
        observer_embed = discord.Embed(
            title="üì∞ Observer Added",
            description=(
                f"**{observer.mention}** has been added to this courtroom as an **OBSERVER**.\n\n"
                f"‚ö†Ô∏è **OBSERVER RULES:**\n"
                f"‚Ä¢ Observers may **READ** proceedings only\n"
                f"‚Ä¢ **DO NOT** type or participate in proceedings\n"
                f"‚Ä¢ Violation may result in removal and sanctions\n\n"
                f"*Added by {interaction.user.mention}*"
            ),
            color=0x3498DB
        )
        await thread.send(embed=observer_embed)
        
        await interaction.followup.send(
            f"‚úÖ Added **{observer.display_name}** as observer to case **{clean_case_id}**\n\n"
            f"*Note: Discord threads don't support true view-only mode. An observer notice has been posted.*"
        )
        print(f"[COURT] Observer {observer} added to case {clean_case_id} by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Add observer failed: {e}")
        await interaction.followup.send(f"‚ùå Failed to add observer: {str(e)}")


@court_group.command(name="add_user", description="[ADMIN] Add a user to a case's private courtroom thread")
@app_commands.describe(
    case_id="The case ID (e.g. CV-02FC3A or CR-FCC2A8)",
    user="The Discord user to add to the thread"
)
async def court_add_user_cmd(
    interaction: discord.Interaction,
    case_id: str,
    user: discord.Member
):
    """Add a user to a court case's private thread"""
    # Check admin/magistrate permission first (fast, no await)
    if not any(role.id in [ADMIN_ROLE_ID, MAGISTRATE_ROLE_ID] for role in interaction.user.roles):
        await interaction.response.send_message("‚ùå Only Admins and Magistrates can add users to threads.", ephemeral=True)
        return
    
    # Send immediate response to avoid timeout
    await interaction.response.send_message("‚è≥ Adding user to thread...", ephemeral=True)
    
    try:
        clean_case_id = case_id.strip().upper()
        
        # Find the case (run in background)
        db = await ensure_firestore()
        case_doc = await asyncio.to_thread(lambda: db.collection('florabi_court_cases').document(clean_case_id).get())
        
        if not case_doc.exists:
            await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} not found.")
            return
        
        case_data = case_doc.to_dict()
        thread_id = case_data.get('courtroomThreadId')
        
        if not thread_id:
            await interaction.edit_original_response(
                content=f"‚ùå Case #{clean_case_id} has no courtroom thread.\nUse `/court create_thread case_id:{clean_case_id}` first."
            )
            return
        
        # Get the thread
        thread = interaction.guild.get_thread(thread_id)
        if not thread:
            try:
                thread = await interaction.guild.fetch_channel(thread_id)
            except:
                await interaction.edit_original_response(content=f"‚ùå Could not find thread {thread_id}. It may have been deleted.")
                return
        
        # Bot must join thread first (private threads require membership)
        try:
            await thread.join()
        except discord.HTTPException:
            pass  # Already a member or can't join
        
        # Add the user
        await thread.add_user(user)
        
        await interaction.edit_original_response(
            content=f"‚úÖ Added {user.mention} to the courtroom thread for case #{clean_case_id}"
        )
        print(f"[COURT] Admin {interaction.user} added {user} to thread for case #{clean_case_id}")
        
    except Exception as e:
        print(f"[ERR] Add user to thread failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to add user: {str(e)}")


@court_group.command(name="appeals", description="üì¢ View all pending appeals awaiting review")
async def view_appeals_cmd(interaction: discord.Interaction):
    """View all pending appeals"""
    await interaction.response.send_message("‚è≥ Loading appeals...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        appeals = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(
            filter=FieldFilter('appealStatus', 'in', ['pending', 'assigned', 'voting'])
        ).stream()))
        
        if not appeals:
            return await interaction.edit_original_response(content="‚úÖ No pending appeals at this time.")
        
        embed = discord.Embed(
            title="üì¢ APPEALS COURT - PENDING CASES",
            description=f"*{len(appeals)} appeal(s) awaiting review*",
            color=0xffa500
        )
        
        for appeal_doc in appeals[:10]:
            appeal_data = appeal_doc.to_dict()
            case_id = appeal_data.get('caseId', 'Unknown')
            defendant = appeal_data.get('defendantIgn', 'Unknown')
            original_verdict = appeal_data.get('verdict', 'Unknown')
            appeal_status = appeal_data.get('appealStatus', 'pending').upper()
            appeal_reason = appeal_data.get('appealReason', 'No reason provided')[:100]
            
            appealed_at = appeal_data.get('appealedAt')
            if appealed_at:
                appealed_est = appealed_at.astimezone(EST)
                date_str = appealed_est.strftime('%b %d, %Y')
            else:
                date_str = 'Unknown'
            
            appeal_judges = appeal_data.get('appealJudgeIds', [])
            judges_str = f"{len(appeal_judges)}/3 judges assigned" if appeal_judges else "No judges assigned"
            
            status_emoji = {"PENDING": "üü°", "ASSIGNED": "üîµ", "VOTING": "üü¢"}.get(appeal_status, "‚ö™")
            
            embed.add_field(
                name=f"{status_emoji} Case #{case_id} - {defendant}",
                value=(
                    f"**Original Verdict:** {original_verdict}\n"
                    f"**Status:** {appeal_status}\n"
                    f"**Filed:** {date_str}\n"
                    f"**Judges:** {judges_str}\n"
                    f"**Reason:** {appeal_reason}..."
                ),
                inline=False
            )
        
        if len(appeals) > 10:
            embed.set_footer(text=f"Showing 10 of {len(appeals)} appeals")
        else:
            embed.set_footer(text="‚öñÔ∏è Florab√≠s Appeals Court")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Failed to load appeals: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to load appeals: {str(e)}")

@court_group.command(name="assign_appeal", description="[ADMIN/JUDGE] Assign judges to review an appeal")
@app_commands.describe(
    case_id="The case ID with a pending appeal (e.g., CR-001)",
    judge1="First appeal judge",
    judge2="Second appeal judge", 
    judge3="Third appeal judge"
)
async def assign_appeal_cmd(
    interaction: discord.Interaction, 
    case_id: str, 
    judge1: discord.Member,
    judge2: discord.Member,
    judge3: discord.Member
):
    """Assign three judges to review an appeal (must be different from original judge)"""
    if not has_admin_role(interaction) and not has_magistrate_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins and Magistrates only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Assigning appeal judges...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        clean_case_id = case_id.upper().strip().replace("#", "")
        case_docs = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(
            filter=FieldFilter('caseId', '==', clean_case_id)
        ).limit(1).stream()))
        
        if not case_docs:
            return await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} not found.")
        
        case_ref = db.collection(COURT_CASES_COLLECTION).document(case_docs[0].id)
        case_data = case_docs[0].to_dict()
        
        if not case_data.get('appealStatus'):
            return await interaction.edit_original_response(content=f"‚ùå Case #{clean_case_id} has no pending appeal.")
        
        if case_data.get('appealStatus') not in ['pending', 'assigned']:
            return await interaction.edit_original_response(content=f"‚ùå Appeal is already in '{case_data.get('appealStatus')}' status.")
        
        original_judge_id = case_data.get('sentencedById')
        judge_ids = [judge1.id, judge2.id, judge3.id]
        
        if original_judge_id and original_judge_id in judge_ids:
            return await interaction.edit_original_response(
                content="‚ùå Appeal judges cannot include the original judge who issued the verdict."
            )
        
        if len(set(judge_ids)) != 3:
            return await interaction.edit_original_response(content="‚ùå All three judges must be different people.")
        
        await asyncio.to_thread(lambda: case_ref.update({
            'appealStatus': 'voting',
            'appealJudgeIds': judge_ids,
            'appealJudgeNames': [str(judge1), str(judge2), str(judge3)],
            'appealAssignedAt': datetime.now(timezone.utc),
            'appealAssignedBy': str(interaction.user),
            'appealVotes': {}
        }))
        
        courtroom_thread_id = case_data.get('courtroomThreadId')
        if courtroom_thread_id and interaction.guild:
            try:
                thread = interaction.guild.get_thread(courtroom_thread_id)
                if thread:
                    appeal_panel = AppealReviewPanel(clean_case_id, judge_ids)
                    
                    appeal_embed = discord.Embed(
                        title="üì¢ APPEAL REVIEW PANEL",
                        description=(
                            f"**Case #{clean_case_id}** is now under appeal review.\n\n"
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Original Verdict:** {case_data.get('verdict')}\n"
                            f"**Appeal Reason:** {case_data.get('appealReason', 'Not provided')}\n\n"
                            f"**Appeal Judges:**\n"
                            f"‚Ä¢ {judge1.mention}\n"
                            f"‚Ä¢ {judge2.mention}\n"
                            f"‚Ä¢ {judge3.mention}\n\n"
                            f"*Judges: Please review the case and cast your vote below.*"
                        ),
                        color=0xffa500
                    )
                    appeal_embed.set_footer(text="‚öñÔ∏è Florab√≠s Appeals Court | 2/3 majority required")
                    
                    await thread.send(
                        content=f"üì¢ **APPEAL HEARING** - {judge1.mention} {judge2.mention} {judge3.mention}",
                        embed=appeal_embed,
                        view=appeal_panel
                    )
            except Exception as thread_err:
                print(f"[WARN] Could not post to thread: {thread_err}")
        
        if COURT_STATUS_CHANNEL_ID and interaction.guild:
            try:
                status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                if status_channel:
                    status_embed = discord.Embed(
                        title=f"üì¢ Appeal Assigned: Case #{clean_case_id}",
                        description=(
                            f"**Defendant:** {case_data.get('defendantIgn')}\n"
                            f"**Appeal Judges:** {judge1.mention}, {judge2.mention}, {judge3.mention}\n"
                            f"**Status:** Voting in progress"
                        ),
                        color=0xffa500
                    )
                    await status_channel.send(embed=status_embed)
            except Exception as status_err:
                print(f"[WARN] Could not post to status channel: {status_err}")
        
        await interaction.edit_original_response(
            content=f"‚úÖ **Appeal Judges Assigned!**\n"
                    f"**Case:** #{clean_case_id}\n"
                    f"**Judges:** {judge1.mention}, {judge2.mention}, {judge3.mention}\n\n"
                    f"Voting panel has been posted to the courtroom thread."
        )
        print(f"[COURT] Appeal judges assigned to case #{clean_case_id}: {judge1}, {judge2}, {judge3}")
        
    except Exception as e:
        print(f"[ERR] Assign appeal failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to assign appeal: {str(e)}")

class AppealReviewPanel(ui.View):
    """Panel for appeal judges to vote on upholding or overturning a verdict"""
    def __init__(self, case_id: str, judge_ids: list):
        super().__init__(timeout=None)
        self.case_id = case_id
        self.judge_ids = judge_ids
    
    @ui.button(label="‚¨ÜÔ∏è Uphold Verdict", style=discord.ButtonStyle.red, custom_id="appeal_uphold")
    async def uphold_verdict(self, interaction: discord.Interaction, button: ui.Button):
        await self._cast_vote(interaction, "uphold")
    
    @ui.button(label="‚Ü©Ô∏è Overturn Verdict", style=discord.ButtonStyle.green, custom_id="appeal_overturn")
    async def overturn_verdict(self, interaction: discord.Interaction, button: ui.Button):
        await self._cast_vote(interaction, "overturn")
    
    async def _cast_vote(self, interaction: discord.Interaction, vote: str):
        await interaction.response.send_message("‚è≥ Recording vote...", ephemeral=True)
        
        if interaction.user.id not in self.judge_ids:
            return await interaction.edit_original_response(content="‚ùå Only assigned appeal judges can vote.")
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            case_docs = await asyncio.to_thread(lambda: list(db.collection(COURT_CASES_COLLECTION).where(
                filter=FieldFilter('caseId', '==', self.case_id)
            ).limit(1).stream()))
            
            if not case_docs:
                return await interaction.edit_original_response(content="‚ùå Case not found.")
            
            case_ref = db.collection(COURT_CASES_COLLECTION).document(case_docs[0].id)
            case_data = case_docs[0].to_dict()
            
            if case_data.get('appealStatus') != 'voting':
                return await interaction.edit_original_response(content="‚ùå This appeal is no longer accepting votes.")
            
            appeal_votes = case_data.get('appealVotes', {})
            user_id_str = str(interaction.user.id)
            
            if user_id_str in appeal_votes:
                return await interaction.edit_original_response(content="‚ùå You have already voted on this appeal.")
            
            appeal_votes[user_id_str] = {
                'vote': vote,
                'judge': str(interaction.user),
                'votedAt': datetime.now(timezone.utc)
            }
            
            await asyncio.to_thread(lambda: case_ref.update({'appealVotes': appeal_votes}))
            
            uphold_count = sum(1 for v in appeal_votes.values() if v['vote'] == 'uphold')
            overturn_count = sum(1 for v in appeal_votes.values() if v['vote'] == 'overturn')
            total_votes = len(appeal_votes)
            
            vote_emoji = "‚¨ÜÔ∏è" if vote == "uphold" else "‚Ü©Ô∏è"
            vote_text = "UPHOLD" if vote == "uphold" else "OVERTURN"
            
            await interaction.channel.send(
                f"{vote_emoji} **Appeal Vote Cast:** {interaction.user.mention} voted to **{vote_text}** the verdict.\n"
                f"*Current tally: {uphold_count} uphold, {overturn_count} overturn ({total_votes}/3 votes)*"
            )
            
            if uphold_count >= 2:
                await self._finalize_appeal(interaction, case_ref, case_data, "upheld", uphold_count, overturn_count)
            elif overturn_count >= 2:
                await self._finalize_appeal(interaction, case_ref, case_data, "overturned", uphold_count, overturn_count)
            
            await interaction.edit_original_response(content=f"‚úÖ Vote recorded: **{vote_text}**")
            
        except Exception as e:
            print(f"[ERR] Appeal vote failed: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to record vote: {str(e)}")
    
    async def _finalize_appeal(self, interaction, case_ref, case_data, outcome: str, uphold: int, overturn: int):
        """Finalize the appeal with the given outcome"""
        try:
            if outcome == "upheld":
                await asyncio.to_thread(lambda: case_ref.update({
                    'appealStatus': 'closed',
                    'appealOutcome': 'upheld',
                    'appealFinalizedAt': datetime.now(timezone.utc)
                }))
                
                result_embed = discord.Embed(
                    title=f"‚öñÔ∏è APPEAL DECISION: Case #{self.case_id}",
                    description=(
                        f"**Outcome:** ‚¨ÜÔ∏è VERDICT UPHELD\n\n"
                        f"**Vote:** {uphold}-{overturn}\n"
                        f"**Original Verdict:** {case_data.get('verdict')}\n"
                        f"**Defendant:** {case_data.get('defendantIgn')}\n\n"
                        f"*The original verdict stands. The sentence remains in effect.*"
                    ),
                    color=discord.Color.red()
                )
            else:
                await asyncio.to_thread(lambda: case_ref.update({
                    'appealStatus': 'closed',
                    'appealOutcome': 'overturned',
                    'verdict': 'Overturned on Appeal',
                    'originalVerdict': case_data.get('verdict'),
                    'status': 'appeal_overturned',
                    'appealFinalizedAt': datetime.now(timezone.utc)
                }))
                
                result_embed = discord.Embed(
                    title=f"‚öñÔ∏è APPEAL DECISION: Case #{self.case_id}",
                    description=(
                        f"**Outcome:** ‚Ü©Ô∏è VERDICT OVERTURNED\n\n"
                        f"**Vote:** {uphold}-{overturn}\n"
                        f"**Original Verdict:** {case_data.get('verdict')} ‚Üí **VACATED**\n"
                        f"**Defendant:** {case_data.get('defendantIgn')}\n\n"
                        f"*The original verdict has been overturned. The defendant is cleared of charges.*"
                    ),
                    color=discord.Color.green()
                )
            
            now_est = datetime.now(timezone.utc).astimezone(EST)
            result_embed.set_footer(text=f"Decided {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
            
            await interaction.channel.send(embed=result_embed)
            
            for item in self.children:
                item.disabled = True
            await interaction.message.edit(view=self)
            
            if COURT_STATUS_CHANNEL_ID and interaction.guild:
                try:
                    status_channel = interaction.guild.get_channel(COURT_STATUS_CHANNEL_ID)
                    if status_channel:
                        await status_channel.send(embed=result_embed)
                except Exception as status_err:
                    print(f"[WARN] Could not post to status channel: {status_err}")
            
            print(f"[COURT] Appeal for case #{self.case_id} finalized: {outcome} ({uphold}-{overturn})")
            
        except Exception as e:
            print(f"[ERR] Failed to finalize appeal: {e}")
            import traceback
            traceback.print_exc()

@bot.tree.command(name="switch_lawyer_role", description="‚öñÔ∏è Switch your lawyer role type (Attorney ‚Üî Prosecutor ‚Üî Public Defender)")
async def switch_lawyer_role_cmd(interaction: discord.Interaction):
    """Allow lawyers to switch their role type"""
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Check if user is a lawyer
        lawyer_data = get_lawyer_data(interaction.user.id)
        if not lawyer_data:
            return await interaction.edit_original_response(content="‚ùå You are not registered as a lawyer. Use the court panel to register first.")
        
        current_type = lawyer_data.get('lawyerType', 'unknown')
        
        # Create dropdown for role selection
        class LawyerRoleSwitchSelect(ui.Select):
            def __init__(self):
                options = [
                    discord.SelectOption(label="Attorney (Private)", value="attorney", description="Represent clients as private attorney", emoji="‚öñÔ∏è"),
                    discord.SelectOption(label="Public Defender", value="public_defender", description="Defend citizens who can't afford representation", emoji="üõ°Ô∏è"),
                    discord.SelectOption(label="State Prosecutor", value="prosecutor", description="Prosecute crimes on behalf of the state", emoji="‚öîÔ∏è")
                ]
                super().__init__(placeholder="Select your new lawyer role...", options=options)
            
            async def callback(self, select_interaction: discord.Interaction):
                await select_interaction.response.send_message("‚è≥ Switching role...", ephemeral=True)
                
                new_type = self.values[0]
                
                if new_type == current_type:
                    return await select_interaction.edit_original_response(content=f"‚ùå You are already registered as {current_type}.")
                
                # Update database
                lawyer_id = lawyer_data.get('id')
                db.collection(LAWYERS_COLLECTION).document(lawyer_id).update({
                    'lawyerType': new_type
                })
                
                # Update Discord roles if in guild
                if select_interaction.guild:
                    # Remove old role
                    old_role_id = None
                    if current_type == 'attorney' and ATTORNEY_ROLE_ID:
                        old_role_id = ATTORNEY_ROLE_ID
                    elif current_type == 'public_defender' and PUBLIC_DEFENDER_ROLE_ID:
                        old_role_id = PUBLIC_DEFENDER_ROLE_ID
                    elif current_type == 'prosecutor' and STATE_PROSECUTOR_ROLE_ID:
                        old_role_id = STATE_PROSECUTOR_ROLE_ID
                    
                    if old_role_id:
                        old_role = select_interaction.guild.get_role(old_role_id)
                        if old_role and old_role in select_interaction.user.roles:
                            try:
                                await select_interaction.user.remove_roles(old_role)
                            except Exception as e:
                                print(f"[WARN] Failed to remove old role: {e}")
                    
                    # Add new role
                    new_role_id = None
                    new_role_name = ""
                    if new_type == 'attorney' and ATTORNEY_ROLE_ID:
                        new_role_id = ATTORNEY_ROLE_ID
                        new_role_name = "Attorney"
                    elif new_type == 'public_defender' and PUBLIC_DEFENDER_ROLE_ID:
                        new_role_id = PUBLIC_DEFENDER_ROLE_ID
                        new_role_name = "Public Defender"
                    elif new_type == 'prosecutor' and STATE_PROSECUTOR_ROLE_ID:
                        new_role_id = STATE_PROSECUTOR_ROLE_ID
                        new_role_name = "State Prosecutor"
                    
                    if new_role_id:
                        new_role = select_interaction.guild.get_role(new_role_id)
                        if new_role:
                            try:
                                await select_interaction.user.add_roles(new_role)
                            except Exception as e:
                                print(f"[WARN] Failed to assign new role: {e}")
                
                role_display = {
                    'attorney': '‚öñÔ∏è **Attorney (Private)**',
                    'public_defender': 'üõ°Ô∏è **Public Defender**',
                    'prosecutor': '‚öîÔ∏è **State Prosecutor**'
                }
                
                await select_interaction.edit_original_response(content=
                    f"‚úÖ **Lawyer Role Updated**\n\n"
                    f"**Previous Role:** {role_display.get(current_type, current_type)}\n"
                    f"**New Role:** {role_display.get(new_type, new_type)}\n\n"
                    f"Your Discord role has been updated accordingly.")
                
                print(f"[OK] {select_interaction.user} switched lawyer role: {current_type} ‚Üí {new_type}")
        
        view = ui.View(timeout=300)
        view.add_item(LawyerRoleSwitchSelect())
        
        role_display = {
            'attorney': '‚öñÔ∏è Attorney (Private)',
            'public_defender': 'üõ°Ô∏è Public Defender',
            'prosecutor': '‚öîÔ∏è State Prosecutor'
        }
        
        await interaction.edit_original_response(
            content=f"**Current Role:** {role_display.get(current_type, current_type)}\n\nSelect your new lawyer role:",
            view=view
        )
        
    except Exception as e:
        print(f"[ERR] Failed to switch lawyer role: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to switch role: {str(e)}")

# ========================================
# TREASURY TRACKER SYSTEM
# ========================================

TREASURY_COLLECTION = 'florabi_treasury'
TREASURY_LOG_COLLECTION = 'florabi_treasury_logs'

# Common CivMC resources
TREASURY_RESOURCES = {
    DIAMOND_EMOJI: 'Diamonds',
    IRON_EMOJI: 'Iron',
    'üíö': 'Emeralds',
    '‚ú®': 'XP (bottles)',
    'üß±': 'Bastions',
    'üè∫': 'Acid Blocks',
    '‚öîÔ∏è': 'Prot Sets',
    'üß™': 'Potions (stacks)',
    'ü™ô': 'Other Valuables'
}

class RefreshTreasuryButton(ui.Button):
    def __init__(self):
        super().__init__(label="üîÑ Refresh", style=discord.ButtonStyle.secondary)
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("‚è≥ Refreshing treasury...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            # Get all treasury items from database
            treasury_items = db.collection(TREASURY_COLLECTION).stream()
            
            # Store amounts in dict
            treasury_data = {}
            for doc in treasury_items:
                data = doc.to_dict()
                resource = doc.id  # Use document ID as resource name
                amount = data.get('amount', 0)
                treasury_data[resource] = amount
            
            # Define all commodities to display (always show all 5)
            all_commodities = [
                ('Diamonds', DIAMOND_EMOJI, 'Diamonds'),
                ('Essence', ESSENCE_EMOJI, 'Essence'),
                ('Iron', IRON_EMOJI, 'Iron'),
                ('Gold', GOLD_EMOJI, 'Gold'),
                ('Emeralds', EMERALD_EMOJI, 'Emeralds')
            ]
            
            items_list = []
            total_value_diamonds = 0
            liquid_diamonds = 0
            
            # Display all commodities (even if 0)
            for commodity_name, emoji, display_suffix in all_commodities:
                amount = treasury_data.get(commodity_name, 0)
                
                # Add to display
                items_list.append(f"**{emoji} {display_suffix}:** {amount:,}")
                
                # Calculate value
                if commodity_name == 'Diamonds':
                    total_value_diamonds += amount
                    liquid_diamonds = amount
                elif commodity_name == 'Essence':
                    essence_price = get_commodity_price('essence')
                    total_value_diamonds += amount * essence_price
                elif commodity_name == 'Iron':
                    iron_price = get_commodity_price('iron')
                    total_value_diamonds += amount * iron_price
                elif commodity_name == 'Gold':
                    gold_price = get_commodity_price('gold')
                    total_value_diamonds += amount * gold_price
                elif commodity_name == 'Emeralds':
                    total_value_diamonds += amount // 10
            
            STATE_USER_ID = 0
            state_holdings = list(db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', STATE_USER_ID)).stream())
            
            portfolio_value = 0
            portfolio_list = []
            
            for holding in state_holdings:
                data = holding.to_dict()
                business_name = data.get('businessName', 'Unknown')
                shares = data.get('shares', 0)
                
                ipo = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).limit(1).stream())
                price = ipo[0].to_dict()['pricePerShare'] if ipo else 10.0
                value = shares * price
                portfolio_value += value
                
                portfolio_list.append(f"**{business_name}**: {shares:,} shares (~{value:,.0f}d)")
            
            total_value_diamonds += portfolio_value
            
            if not items_list and not portfolio_list:
                embed = discord.Embed(
                    title="üí∞ State Treasury - REFRESHED",
                    description="The treasury is currently empty.",
                    color=discord.Color.gold()
                )
            else:
                desc = ""
                
                if items_list:
                    desc += "**üíµ Liquid Assets:**\n" + "\n".join(items_list)
                
                if portfolio_list:
                    if desc:
                        desc += "\n\n"
                    desc += "**üìà State Investment Portfolio:**\n" + "\n".join(portfolio_list)
                    desc += f"\n\n*Portfolio Value: {portfolio_value:,.0f} diamonds*"
                
                embed = discord.Embed(
                    title="üí∞ State Treasury of Florab√≠s - REFRESHED",
                    description=desc,
                    color=discord.Color.gold()
                )
                
                if portfolio_list:
                    embed.set_footer(text=f"{DIAMOND_EMOJI} Liquid: {liquid_diamonds:,}d | üìà Invested: {portfolio_value:,.0f}d | üí∞ Total: ~{total_value_diamonds:,.0f}d | üîÑ Live data")
                elif total_value_diamonds > 0:
                    embed.set_footer(text=f"Estimated value: ~{total_value_diamonds:,} diamonds | üîÑ Live data")
            
            now_est = datetime.now(timezone.utc).astimezone(EST)
            embed.timestamp = now_est
            
            await interaction.edit_original_response(embed=embed)
        except Exception as e:
            print(f"[ERR] Refresh treasury failed: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to refresh: {str(e)}")

class TreasuryView(ui.View):
    def __init__(self):
        super().__init__(timeout=300)  # 5 minute timeout
        self.add_item(RefreshTreasuryButton())

@economy_group.command(name="treasury", description="üí∞ View national treasury balance")
async def treasury_view_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all treasury items from database
        treasury_items = db.collection(TREASURY_COLLECTION).stream()
        
        # Store amounts in dict
        treasury_data = {}
        for doc in treasury_items:
            data = doc.to_dict()
            resource = doc.id  # Use document ID as resource name
            amount = data.get('amount', 0)
            treasury_data[resource] = amount
        
        # Define all commodities to display (always show all 5)
        all_commodities = [
            ('Diamonds', DIAMOND_EMOJI, 'Diamonds'),
            ('Essence', ESSENCE_EMOJI, 'Essence'),
            ('Iron', IRON_EMOJI, 'Iron'),
            ('Gold', GOLD_EMOJI, 'Gold'),
            ('Emeralds', EMERALD_EMOJI, 'Emeralds')
        ]
        
        items_list = []
        total_value_diamonds = 0
        liquid_diamonds = 0
        
        # Display all commodities (even if 0)
        for commodity_name, emoji, display_suffix in all_commodities:
            amount = treasury_data.get(commodity_name, 0)
            
            # Add to display
            items_list.append(f"**{emoji} {display_suffix}:** {amount:,}")
            
            # Calculate value
            if commodity_name == 'Diamonds':
                total_value_diamonds += amount
                liquid_diamonds = amount
            elif commodity_name == 'Essence':
                essence_price = get_market_price('essence')
                total_value_diamonds += amount * essence_price
            elif commodity_name == 'Iron':
                iron_price = get_market_price('iron')
                total_value_diamonds += amount * iron_price
            elif commodity_name == 'Gold':
                gold_price = get_market_price('gold')
                total_value_diamonds += amount * gold_price
            elif commodity_name == 'Emeralds':
                total_value_diamonds += amount // 10
        
        # Get state-owned stock portfolio
        STATE_USER_ID = 0
        state_holdings = list(db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', STATE_USER_ID)).stream())
        
        portfolio_value = 0
        portfolio_list = []
        
        for holding in state_holdings:
            data = holding.to_dict()
            business_name = data.get('businessName', 'Unknown')
            shares = data.get('shares', 0)
            
            # Get current IPO price
            ipo = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).limit(1).stream())
            price = ipo[0].to_dict()['pricePerShare'] if ipo else 10.0
            value = shares * price
            portfolio_value += value
            
            portfolio_list.append(f"**{business_name}**: {shares:,} shares (~{value:,.0f}d)")
        
        # Total value = liquid + investments
        total_value_diamonds += portfolio_value
        
        if not items_list and not portfolio_list:
            embed = discord.Embed(
                title="üí∞ State Treasury",
                description="The treasury is currently empty.",
                color=discord.Color.gold()
            )
        else:
            desc = ""
            
            # Liquid assets
            if items_list:
                desc += "**üíµ Liquid Assets:**\n" + "\n".join(items_list)
            
            # State portfolio
            if portfolio_list:
                if desc:
                    desc += "\n\n"
                desc += "**üìà State Investment Portfolio:**\n" + "\n".join(portfolio_list)
                desc += f"\n\n*Portfolio Value: {portfolio_value:,.0f} diamonds*"
            
            embed = discord.Embed(
                title="üí∞ State Treasury of Florab√≠s",
                description=desc,
                color=discord.Color.gold()
            )
            
            # Summary footer
            if portfolio_list:
                embed.set_footer(text=f"{DIAMOND_EMOJI} Liquid: {liquid_diamonds:,}d | üìà Invested: {portfolio_value:,.0f}d | üí∞ Total Value: ~{total_value_diamonds:,.0f}d | üîÑ Click refresh to update")
            elif total_value_diamonds > 0:
                embed.set_footer(text=f"Estimated value: ~{total_value_diamonds:,} diamonds | üîÑ Click refresh to update")
        
        now_est = datetime.now(timezone.utc).astimezone(EST)
        embed.timestamp = now_est
        
        # Add refresh button view
        view = TreasuryView()
        await interaction.edit_original_response(embed=embed, view=view)
        
    except Exception as e:
        print(f"[ERR] Treasury view failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view treasury: {str(e)}")

@economy_group.command(name="treasury_add", description="üí∞ [ADMIN] Add commodities to the state treasury")
@app_commands.describe(
    commodity="Commodity to add (Diamonds, Essence, Iron, Gold, Emeralds)",
    amount="Amount to add"
)
@app_commands.choices(commodity=[
    app_commands.Choice(name="Diamonds", value="Diamonds"),
    app_commands.Choice(name="Essence", value="Essence"),
    app_commands.Choice(name="Iron", value="Iron"),
    app_commands.Choice(name="Gold", value="Gold"),
    app_commands.Choice(name="Emeralds", value="Emeralds")
])
async def treasury_add_cmd(interaction: discord.Interaction, commodity: str, amount: float):
    """Admin command to add commodities to state treasury"""
    await interaction.response.send_message("‚è≥ Adding to treasury...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can add to the state treasury.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if amount <= 0:
        return await interaction.edit_original_response(content="‚ùå Amount must be positive.")
    
    try:
        # Get or create treasury document for this commodity
        treasury_ref = db.collection(TREASURY_COLLECTION).document(commodity)
        treasury_doc = treasury_ref.get()
        
        if treasury_doc.exists:
            current_amount = treasury_doc.to_dict().get('amount', 0)
            new_amount = current_amount + amount
        else:
            current_amount = 0
            new_amount = amount
        
        # Update treasury
        treasury_ref.set({
            'amount': new_amount,
            'lastUpdated': datetime.now(timezone.utc),
            'updatedBy': interaction.user.id
        })
        
        # Get emoji for commodity
        commodity_emoji = {
            'Diamonds': DIAMOND_EMOJI,
            'Essence': ESSENCE_EMOJI,
            'Iron': IRON_EMOJI,
            'Gold': GOLD_EMOJI,
            'Emeralds': EMERALD_EMOJI
        }.get(commodity, 'üì¶')
        
        # Determine unit
        if commodity == 'Diamonds':
            unit = 'd'
        elif commodity == 'Essence':
            unit = 'ess'
        elif commodity in ['Iron', 'Gold']:
            unit = 'ingots'
        else:
            unit = ''
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Treasury Updated!**\n\n"
            f"{commodity_emoji} **{commodity}** added to state treasury\n\n"
            f"**Added:** {amount:,.1f} {unit}\n"
            f"**Previous Balance:** {current_amount:,.1f} {unit}\n"
            f"**New Balance:** {new_amount:,.1f} {unit}\n\n"
            f"*Authorized by {interaction.user.mention}*"
        )
        
        print(f"[TREASURY] {interaction.user} added {amount} {commodity} to treasury (new total: {new_amount})")
        
    except Exception as e:
        print(f"[ERR] Treasury add failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to add to treasury: {str(e)}")

@economy_group.command(name="treasury_remove", description="üí∏ [ADMIN] Remove commodities from the state treasury")
@app_commands.describe(
    commodity="Commodity to remove (Diamonds, Essence, Iron, Gold, Emeralds)",
    amount="Amount to remove"
)
@app_commands.choices(commodity=[
    app_commands.Choice(name="Diamonds", value="Diamonds"),
    app_commands.Choice(name="Essence", value="Essence"),
    app_commands.Choice(name="Iron", value="Iron"),
    app_commands.Choice(name="Gold", value="Gold"),
    app_commands.Choice(name="Emeralds", value="Emeralds")
])
async def treasury_remove_cmd(interaction: discord.Interaction, commodity: str, amount: float):
    """Admin command to remove commodities from state treasury"""
    await interaction.response.send_message("‚è≥ Removing from treasury...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can remove from the state treasury.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if amount <= 0:
        return await interaction.edit_original_response(content="‚ùå Amount must be positive.")
    
    try:
        # Get treasury document
        treasury_ref = db.collection(TREASURY_COLLECTION).document(commodity)
        treasury_doc = treasury_ref.get()
        
        if not treasury_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå No {commodity} in treasury to remove.")
        
        current_amount = treasury_doc.to_dict().get('amount', 0)
        
        if amount > current_amount:
            return await interaction.edit_original_response(content=
                f"‚ùå Insufficient {commodity} in treasury!\n\n"
                f"**Available:** {current_amount:,.1f}\n"
                f"**Requested:** {amount:,.1f}"
            )
        
        new_amount = current_amount - amount
        
        # Update treasury
        treasury_ref.set({
            'amount': new_amount,
            'lastUpdated': datetime.now(timezone.utc),
            'updatedBy': interaction.user.id
        })
        
        # Get emoji for commodity
        commodity_emoji = {
            'Diamonds': DIAMOND_EMOJI,
            'Essence': ESSENCE_EMOJI,
            'Iron': IRON_EMOJI,
            'Gold': GOLD_EMOJI,
            'Emeralds': EMERALD_EMOJI
        }.get(commodity, 'üì¶')
        
        # Determine unit
        if commodity == 'Diamonds':
            unit = 'd'
        elif commodity == 'Essence':
            unit = 'ess'
        elif commodity in ['Iron', 'Gold']:
            unit = 'ingots'
        else:
            unit = ''
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Treasury Updated!**\n\n"
            f"{commodity_emoji} **{commodity}** removed from state treasury\n\n"
            f"**Removed:** {amount:,.1f} {unit}\n"
            f"**Previous Balance:** {current_amount:,.1f} {unit}\n"
            f"**New Balance:** {new_amount:,.1f} {unit}\n\n"
            f"*Authorized by {interaction.user.mention}*"
        )
        
        print(f"[TREASURY] {interaction.user} removed {amount} {commodity} from treasury (new total: {new_amount})")
        
    except Exception as e:
        print(f"[ERR] Treasury remove failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to remove from treasury: {str(e)}")

@economy_group.command(name="state_invest", description="üìà [ADMIN] Invest state treasury funds in stocks")
@app_commands.describe(
    business_name="Business to invest in",
    shares="Number of shares to buy"
)
async def treasury_invest_cmd(interaction: discord.Interaction, business_name: str, shares: int):
    """Admin command for state to buy shares with treasury funds"""
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can manage state investments.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if shares < 1:
        return await interaction.edit_original_response(content="‚ùå Must buy at least 1 share.")
    
    try:
        # Check for active IPO
        active_ipos = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).where(filter=FieldFilter('status', '==', 'active')).limit(1).stream())
        
        if not active_ipos:
            return await interaction.edit_original_response(content=f"‚ùå No active IPO for **{business_name}**.")
        
        ipo_data = active_ipos[0].to_dict()
        price_per_share = ipo_data['pricePerShare']
        shares_remaining = ipo_data['sharesRemaining']
        
        if shares > shares_remaining:
            return await interaction.edit_original_response(content=
                f"‚ùå Not enough shares available!\n**Available:** {shares_remaining:,}\n**Requested:** {shares:,}")
        
        total_cost = shares * price_per_share
        
        # Use atomic transaction for treasury deduction
        treasury_ref = db.collection(TREASURY_COLLECTION).document('Diamonds')
        
        @firestore.transactional
        def deduct_treasury(transaction):
            treasury_snapshot = treasury_ref.get(transaction=transaction)
            
            if not treasury_snapshot.exists:
                return False, 0, 0
            
            current_diamonds = treasury_snapshot.to_dict().get('amount', 0)
            
            if current_diamonds < total_cost:
                return False, current_diamonds, total_cost
            
            # Atomically update treasury
            transaction.update(treasury_ref, {
                'amount': current_diamonds - total_cost,
                'lastUpdated': datetime.now(timezone.utc),
                'lastUpdatedBy': interaction.user.id
            })
            
            return True, current_diamonds, total_cost
        
        # Execute atomic transaction
        transaction = db.transaction()
        success, current_diamonds, cost = deduct_treasury(transaction)
        
        if not success:
            return await interaction.edit_original_response(content=
                f"‚ùå Insufficient treasury funds!\n**Required:** {cost:,.0f}d\n**Available:** {current_diamonds:,.0f}d")
        
        # Log treasury withdrawal
        db.collection(TREASURY_LOG_COLLECTION).add({
            'resource': 'Diamonds',
            'action': 'investment',
            'amount': total_cost,
            'previousBalance': current_diamonds,
            'newBalance': current_diamonds - total_cost,
            'userId': interaction.user.id,
            'userTag': interaction.user.mention,
            'notes': f"State investment: {shares} shares of {business_name}",
            'timestamp': datetime.now(timezone.utc)
        })
        
        # Update IPO
        db.collection(IPOS_COLLECTION).document(active_ipos[0].id).update({
            'sharesRemaining': shares_remaining - shares,
            'totalRaised': ipo_data.get('totalRaised', 0) + total_cost
        })
        
        # Give shares to state (use special user ID for state)
        STATE_USER_ID = 0  # Special ID for state-owned shares
        existing_shares = list(db.collection(SHARES_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).where(filter=FieldFilter('ownerId', '==', STATE_USER_ID)).limit(1).stream())
        
        if existing_shares:
            # Add to existing holdings
            share_doc = existing_shares[0]
            current_shares = share_doc.to_dict()['shares']
            db.collection(SHARES_COLLECTION).document(share_doc.id).update({
                'shares': current_shares + shares
            })
        else:
            # Create new holding
            db.collection(SHARES_COLLECTION).add({
                'businessName': business_name,
                'ownerId': STATE_USER_ID,
                'ownerName': 'State of Florab√≠s',
                'shares': shares,
                'acquiredAt': datetime.now(timezone.utc)
            })
        
        embed = discord.Embed(
            title="üìà State Investment Made!",
            description=f"Florab√≠s has invested in **{business_name}**",
            color=discord.Color.blue()
        )
        embed.add_field(name="Shares Purchased", value=f"{shares:,}", inline=True)
        embed.add_field(name="Price Per Share", value=f"{price_per_share:,.1f}d", inline=True)
        embed.add_field(name="Total Cost", value=f"{total_cost:,.0f}d", inline=True)
        embed.add_field(name="üí∞ Treasury Balance", value=f"{current_diamonds - total_cost:,.0f}d remaining", inline=False)
        embed.set_footer(text=f"Authorized by {interaction.user.name} | State now owns shares in this business")
        
        await interaction.edit_original_response(embed=embed)
        print(f"[TREASURY] State invested {total_cost}d in {business_name} ({shares} shares)")
        
    except Exception as e:
        print(f"[ERR] State investment failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to invest: {str(e)}")

@economy_group.command(name="state_divest", description="üí∏ [ADMIN] Sell state-owned shares")
@app_commands.describe(
    business_name="Business to sell shares from",
    shares="Number of shares to sell"
)
async def treasury_divest_cmd(interaction: discord.Interaction, business_name: str, shares: int):
    """Admin command for state to sell shares"""
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can manage state investments.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if shares < 1:
        return await interaction.edit_original_response(content="‚ùå Must sell at least 1 share.")
    
    try:
        STATE_USER_ID = 0  # Special ID for state-owned shares
        
        # Get state holdings
        state_holdings = list(db.collection(SHARES_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).where(filter=FieldFilter('ownerId', '==', STATE_USER_ID)).limit(1).stream())
        
        if not state_holdings:
            return await interaction.edit_original_response(content=f"‚ùå State doesn't own any shares of **{business_name}**.")
        
        holding_doc = state_holdings[0]
        current_shares = holding_doc.to_dict()['shares']
        
        if shares > current_shares:
            return await interaction.edit_original_response(content=
                f"‚ùå Not enough shares to sell!\n**Owned:** {current_shares:,}\n**Trying to sell:** {shares:,}")
        
        # Get current market price
        ipo = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).limit(1).stream())
        price_per_share = ipo[0].to_dict()['pricePerShare'] if ipo else 10.0  # Default price if no IPO
        
        sale_proceeds = shares * price_per_share
        
        # Update state holdings
        if shares == current_shares:
            # Sold all shares, delete holding
            db.collection(SHARES_COLLECTION).document(holding_doc.id).delete()
        else:
            # Reduce share count
            db.collection(SHARES_COLLECTION).document(holding_doc.id).update({
                'shares': current_shares - shares
            })
        
        # Add proceeds to treasury
        treasury_ref = db.collection(TREASURY_COLLECTION).document('Diamonds')
        treasury_doc = treasury_ref.get()
        current_balance = treasury_doc.to_dict()['amount'] if treasury_doc.exists else 0
        
        treasury_ref.update({
            'amount': current_balance + sale_proceeds,
            'lastUpdated': datetime.now(timezone.utc),
            'lastUpdatedBy': interaction.user.id
        })
        
        # Log treasury deposit
        db.collection(TREASURY_LOG_COLLECTION).add({
            'resource': 'Diamonds',
            'action': 'divestment',
            'amount': sale_proceeds,
            'previousBalance': current_balance,
            'newBalance': current_balance + sale_proceeds,
            'userId': interaction.user.id,
            'userTag': interaction.user.mention,
            'notes': f"State sold {shares} shares of {business_name}",
            'timestamp': datetime.now(timezone.utc)
        })
        
        embed = discord.Embed(
            title="üí∏ State Divestment Complete!",
            description=f"Florab√≠s sold shares in **{business_name}**",
            color=discord.Color.green()
        )
        embed.add_field(name="Shares Sold", value=f"{shares:,}", inline=True)
        embed.add_field(name="Price Per Share", value=f"{price_per_share:,.1f}d", inline=True)
        embed.add_field(name="Sale Proceeds", value=f"{sale_proceeds:,.0f}d", inline=True)
        embed.add_field(name="üí∞ New Treasury Balance", value=f"{current_balance + sale_proceeds:,.0f}d", inline=False)
        embed.add_field(name="Remaining Shares", value=f"{current_shares - shares:,} shares" if shares < current_shares else "No shares remaining", inline=False)
        embed.set_footer(text=f"Authorized by {interaction.user.name} | Proceeds added to state treasury")
        
        await interaction.edit_original_response(embed=embed)
        print(f"[TREASURY] State sold {shares} shares of {business_name} for {sale_proceeds}d")
        
    except Exception as e:
        print(f"[ERR] State divestment failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to sell shares: {str(e)}")

# ========================================
# BUSINESS & STOCK MARKET SYSTEM
# ========================================

BUSINESSES_COLLECTION = 'florabi_businesses'
SHARES_COLLECTION = 'florabi_shares'
STOCK_TRANSACTIONS_COLLECTION = 'florabi_stock_transactions'
IPOS_COLLECTION = 'florabi_ipos'
DIVIDENDS_COLLECTION = 'florabi_dividends'

BUSINESS_SECTORS = [
    'üèóÔ∏è Infrastructure',
    '‚õèÔ∏è Mining',
    'üåæ Agriculture',
    'üè≠ Manufacturing',
    '‚öîÔ∏è Defense',
    'üèõÔ∏è Services',
    f'{DIAMOND_EMOJI} Trading',
    'üî¨ Technology',
    'üé® Other'
]

@market_group.command(name="register_business", description="üè¢ Register a new business")
@app_commands.describe(
    name="Business name (e.g., 'Florab√≠s Mining Co.')",
    description="What does your business do?",
    sector="Business sector/industry",
    total_shares="Total shares to create (e.g., 1000)"
)
@app_commands.choices(sector=[
    app_commands.Choice(name=s, value=s) for s in BUSINESS_SECTORS
])
async def business_register_cmd(interaction: discord.Interaction, name: str, description: str, sector: app_commands.Choice[str], total_shares: int):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if total_shares < 100 or total_shares > 100000:
        return await interaction.edit_original_response(content="‚ùå Total shares must be between 100 and 100,000.")
    
    try:
        # Check if business name already exists
        existing = db.collection(BUSINESSES_COLLECTION).where(filter=FieldFilter('name', '==', name)).limit(1).stream()
        if len(list(existing)) > 0:
            return await interaction.edit_original_response(content=f"‚ùå Business name '{name}' is already taken!")
        
        now_utc = datetime.now(timezone.utc)
        
        # Create business
        _, business_ref = db.collection(BUSINESSES_COLLECTION).add({
            'name': name,
            'description': description,
            'sector': sector.value,
            'ownerId': interaction.user.id,
            'ownerTag': interaction.user.mention,
            'totalShares': total_shares,
            'outstandingShares': total_shares,
            'sharePrice': 1.0,
            'marketCap': total_shares * 1.0,
            'status': 'private',
            'founded': now_utc,
            'lastDividend': None
        })
        
        business_id = business_ref.id
        
        # Give owner all initial shares
        db.collection(SHARES_COLLECTION).add({
            'businessId': business_id,
            'businessName': name,
            'ownerId': interaction.user.id,
            'ownerTag': interaction.user.mention,
            'shares': total_shares,
            'acquiredDate': now_utc
        })
        
        embed = discord.Embed(
            title="üè¢ Business Registered!",
            description=f"**{name}** has been successfully registered",
            color=discord.Color.blue()
        )
        embed.add_field(name="üìã Description", value=description, inline=False)
        embed.add_field(name="üè≠ Sector", value=sector.value, inline=True)
        embed.add_field(name="üìä Total Shares", value=f"{total_shares:,}", inline=True)
        embed.add_field(name="üë§ Owner", value=interaction.user.mention, inline=True)
        embed.add_field(name="üí° Next Steps", value=f"Use `/ipo_launch` to go public and raise capital!", inline=False)
        embed.set_footer(text=f"Business ID: {business_id[:8]}")
        
        await interaction.edit_original_response(embed=embed)
        print(f"[BUSINESS] {interaction.user} registered business: {name}")
        
    except Exception as e:
        print(f"[ERR] Business registration failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to register business: {str(e)}")

@market_group.command(name="launch_ipo", description="üìà Launch IPO - go public and sell shares")
@app_commands.describe(
    business_name="Your business name",
    shares_offered="Number of shares to sell (from your holdings)",
    price_per_share="Price per share in diamonds"
)
async def ipo_launch_cmd(interaction: discord.Interaction, business_name: str, shares_offered: int, price_per_share: float):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if shares_offered <= 0 or price_per_share <= 0:
        return await interaction.edit_original_response(content="‚ùå Shares and price must be positive.")
    
    try:
        # Find business
        businesses = db.collection(BUSINESSES_COLLECTION).where(filter=FieldFilter('name', '==', business_name)).limit(1).stream()
        business_list = list(businesses)
        
        if not business_list:
            return await interaction.edit_original_response(content=f"‚ùå Business '{business_name}' not found.")
        
        business_doc = business_list[0]
        business_data = business_doc.to_dict()
        business_id = business_doc.id
        
        # Verify ownership
        if business_data['ownerId'] != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå Only the business owner can launch an IPO.")
        
        # Check if already has active IPO
        active_ipos = db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessId', '==', business_id)).where(filter=FieldFilter('status', '==', 'active')).limit(1).stream()
        if len(list(active_ipos)) > 0:
            return await interaction.edit_original_response(content="‚ùå This business already has an active IPO.")
        
        # Check owner has enough shares
        owner_shares_query = db.collection(SHARES_COLLECTION).where(filter=FieldFilter('businessId', '==', business_id)).where(filter=FieldFilter('ownerId', '==', interaction.user.id)).limit(1).stream()
        owner_shares_list = list(owner_shares_query)
        
        if not owner_shares_list:
            return await interaction.edit_original_response(content="‚ùå You don't own any shares of this business.")
        
        owner_shares_doc = owner_shares_list[0]
        owner_shares_data = owner_shares_doc.to_dict()
        
        if owner_shares_data['shares'] < shares_offered:
            return await interaction.edit_original_response(content=f"‚ùå You only have {owner_shares_data['shares']:,} shares available.")
        
        now_utc = datetime.now(timezone.utc)
        
        # Create IPO
        _, ipo_ref = db.collection(IPOS_COLLECTION).add({
            'businessId': business_id,
            'businessName': business_name,
            'sharesOffered': shares_offered,
            'sharesRemaining': shares_offered,
            'pricePerShare': price_per_share,
            'totalRaised': 0.0,
            'jurisdiction': jurisdiction,
            'status': 'active',
            'launchedBy': interaction.user.id,
            'launchedAt': now_utc
        })
        
        # Update business status
        db.collection(BUSINESSES_COLLECTION).document(business_id).update({
            'status': 'public',
            'sharePrice': price_per_share
        })
        
        # Deduct shares from owner
        db.collection(SHARES_COLLECTION).document(owner_shares_doc.id).update({
            'shares': owner_shares_data['shares'] - shares_offered
        })
        
        embed = discord.Embed(
            title="üìà IPO LAUNCHED!",
            description=f"**{business_name}** is now publicly traded!",
            color=discord.Color.green()
        )
        embed.add_field(name="üìä Shares Available", value=f"{shares_offered:,}", inline=True)
        embed.add_field(name=f"{DIAMOND_EMOJI} Price Per Share", value=f"{price_per_share:.2f} diamonds", inline=True)
        embed.add_field(name="üí∞ Market Cap", value=f"{shares_offered * price_per_share:,.2f} diamonds", inline=True)
        embed.add_field(name="üì¢ How to Buy", value=f"Citizens can now buy shares using `/stock_buy {business_name}`", inline=False)
        
        await interaction.edit_original_response(embed=embed)
        print(f"[IPO] {interaction.user} launched IPO for {business_name}: {shares_offered} shares @ {price_per_share}d")
        
    except Exception as e:
        print(f"[ERR] IPO launch failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to launch IPO: {str(e)}")

@market_group.command(name="buy_stock", description="üí∞ Place stock purchase order (requires payment)")
@app_commands.describe(
    business_name="Business name",
    shares="Number of shares to buy",
    payment_method="How you will pay"
)
@app_commands.choices(payment_method=[
    app_commands.Choice(name="üè¶ Florab√≠s State Bank (instant)", value="bank"),
    app_commands.Choice(name=f"{DIAMOND_EMOJI} Direct in-game payment", value="direct"),
    app_commands.Choice(name="üè¶ Bank transfer to Sort Code HS-9503", value="bank_hs9503")
])
async def stock_buy_cmd(interaction: discord.Interaction, business_name: str, shares: int, payment_method: app_commands.Choice[str]):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if shares <= 0:
        return await interaction.edit_original_response(content="‚ùå Must buy at least 1 share.")
    
    try:
        # Find active IPO
        active_ipos = db.collection(IPOS_COLLECTION).where(
            filter=FieldFilter('businessName', '==', business_name)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).limit(1).stream()
        ipo_list = list(active_ipos)
        
        # If not found, try case-insensitive search
        if not ipo_list:
            all_active = db.collection(IPOS_COLLECTION).where(
                filter=FieldFilter('status', '==', 'active')
            ).stream()
            ipo_list = [ipo for ipo in all_active if ipo.to_dict().get('businessName', '').lower() == business_name.lower()]
        
        if not ipo_list:
            return await interaction.edit_original_response(content=f"‚ùå {business_name} has no active IPO.")
        
        ipo_doc = ipo_list[0]
        ipo_data = ipo_doc.to_dict()
        business_name = ipo_data.get('businessName', business_name)
        
        # Get business ID
        business_id = ipo_data.get('businessId')
        if not business_id:
            businesses = db.collection(BUSINESSES_COLLECTION).where(
                filter=FieldFilter('name', '==', business_name)
            ).limit(1).stream()
            business_list = list(businesses)
            if business_list:
                business_id = business_list[0].id
            else:
                business_id = f"panel_{ipo_doc.id}"
        
        if ipo_data['sharesRemaining'] < shares:
            return await interaction.edit_original_response(content=f"‚ùå Only {ipo_data['sharesRemaining']:,} shares available.")
        
        total_cost = shares * ipo_data['pricePerShare']
        now_utc = datetime.now(timezone.utc)
        
        # BANK PAYMENT - Instant processing
        if payment_method.value == "bank":
            # Banking is now open to foreigners (non-citizens) for international trade
            
            # Use atomic bank deduction (prevents race conditions and negative balances)
            deduction_success = deduct_from_bank(
                user_id=interaction.user.id,
                amount=total_cost,
                transaction_type='stock_purchase',
                memo=f"Purchased {shares} shares of {business_name}"
            )
            
            if not deduction_success:
                # Check current balance for error message
                balance = get_bank_balance(interaction.user.id)
                return await interaction.edit_original_response(content=
                    f"‚ùå Insufficient bank balance.\n"
                    f"üí∞ Your balance: **{balance:,.2f}d**\n"
                    f"üí∏ Cost: **{total_cost:,.2f}d**\n"
                    f"‚ö†Ô∏è Need: **{total_cost - balance:,.2f}d** more"
                )
            
            # Get new balance after deduction for display
            new_balance = get_bank_balance(interaction.user.id)
            
            # Grant shares immediately
            existing_shares = db.collection(SHARES_COLLECTION).where(
                filter=FieldFilter('businessId', '==', business_id)
            ).where(
                filter=FieldFilter('ownerId', '==', interaction.user.id)
            ).limit(1).stream()
            existing_list = list(existing_shares)
            
            if existing_list:
                # Update existing holding
                existing_doc = existing_list[0]
                existing_data = existing_doc.to_dict()
                db.collection(SHARES_COLLECTION).document(existing_doc.id).update({
                    'shares': existing_data['shares'] + shares
                })
            else:
                # Create new holding
                _, share_ref = db.collection(SHARES_COLLECTION).add({
                    'businessId': business_id,
                    'businessName': business_name,
                    'ownerId': interaction.user.id,
                    'ownerTag': interaction.user.mention,
                    'shares': shares,
                    'acquiredDate': now_utc
                })
            
            # Update IPO
            ipo_doc_ref = db.collection(IPOS_COLLECTION).document(ipo_doc.id)
            ipo_data_updated = ipo_doc_ref.get().to_dict()
            new_shares_remaining = ipo_data_updated['sharesRemaining'] - shares
            new_total_raised = ipo_data_updated['totalRaised'] + total_cost
            current_price = ipo_data_updated['pricePerShare']
            new_price = current_price * 1.03  # 3% price increase
            
            ipo_doc_ref.update({
                'sharesRemaining': new_shares_remaining,
                'totalRaised': new_total_raised,
                'pricePerShare': new_price
            })
            
            # Success message
            embed = discord.Embed(
                title="‚úÖ PURCHASE COMPLETE",
                description=f"Shares purchased instantly via Florab√≠s State Bank!",
                color=discord.Color.green()
            )
            embed.add_field(name="üìä Purchase Details", value=f"**{shares:,} shares** of **{business_name}**", inline=False)
            embed.add_field(name=f"{DIAMOND_EMOJI} Total Cost", value=f"**{total_cost:,.1f}d**", inline=True)
            embed.add_field(name="üè¶ New Balance", value=f"**{new_balance:,.2f}d**", inline=True)
            embed.add_field(name="üìà New Share Price", value=f"**{new_price:.1f}d** (+3%)", inline=True)
            if new_shares_remaining > 0:
                embed.add_field(name="üìä IPO Status", value=f"**{new_shares_remaining:,} shares remaining**", inline=False)
            else:
                embed.add_field(name="üéâ IPO STATUS", value="**SOLD OUT!**", inline=False)
            
            await interaction.edit_original_response(embed=embed)
            print(f"[BANK] {interaction.user} bought {shares} shares of {business_name} for {total_cost:.2f}d (bank payment)")
            return
        
        # NON-BANK PAYMENTS - Create pending order
        _, order_ref = db.collection(STOCK_ORDERS_COLLECTION).add({
            'businessId': business_id,
            'businessName': business_name,
            'buyerId': interaction.user.id,
            'buyerTag': interaction.user.mention,
            'buyerName': interaction.user.name,
            'shares': shares,
            'pricePerShare': ipo_data['pricePerShare'],
            'totalCost': total_cost,
            'ipoId': ipo_doc.id,
            'paymentMethod': payment_method.value,
            'paymentStatus': 'unpaid',
            'orderStatus': 'pending',
            'createdAt': now_utc
        })
        
        order_id = order_ref.id
        
        # Payment instructions based on method
        if payment_method.value == "direct":
            payment_instructions = f"{DIAMOND_EMOJI} **Pay in-game directly to an admin**"
        else:
            payment_instructions = "üè¶ **Transfer to Sort Code: HS-9503** (In-game bank)"
        
        embed = discord.Embed(
            title="üìã STOCK ORDER PLACED",
            description=f"Your order for **{business_name}** is pending payment confirmation.",
            color=discord.Color.orange()
        )
        embed.add_field(name="üìä Order Details", value=f"**{shares:,} shares** @ **{ipo_data['pricePerShare']:.1f}d** each", inline=False)
        embed.add_field(name=f"{DIAMOND_EMOJI} Total Cost", value=f"**{total_cost:.1f} diamonds**", inline=True)
        embed.add_field(name="üí∞ Payment Method", value=payment_instructions, inline=False)
        embed.add_field(
            name="üìå Order ID",
            value=f"`{order_id}`\nAdmins will use this to confirm your payment",
            inline=False
        )
        embed.set_footer(text="Shares will be granted once admin confirms payment | Order ID: " + order_id)
        
        await interaction.edit_original_response(embed=embed)
        print(f"[STOCK] {interaction.user} created order {order_id}: {shares} shares of {business_name} @ {ipo_data['pricePerShare']}d ({payment_method.value})")
        
    except Exception as e:
        print(f"[ERR] Stock order failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to create order: {str(e)}")

@market_group.command(name="confirm_payment", description=f"{DIAMOND_EMOJI} Confirm stock purchase payment (Admin only)")
@app_commands.describe(
    order_id="Stock order ID from buyer's confirmation"
)
async def stock_confirm_payment_cmd(interaction: discord.Interaction, order_id: str):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can confirm payments.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Clean order ID (remove backticks if user copied them)
        order_id = order_id.strip().strip('`')
        
        # Get order
        order_doc = db.collection(STOCK_ORDERS_COLLECTION).document(order_id).get()
        if not order_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Order ID `{order_id}` not found.")
        
        order_data = order_doc.to_dict()
        
        # Check if this is a sell order (wrong command)
        if order_data.get('orderType') == 'sell':
            return await interaction.edit_original_response(content=f"‚ùå This is a SELL order. Use `/market confirm_sell_payment` instead.")
        
        if order_data.get('paymentStatus') == 'paid':
            return await interaction.edit_original_response(content=f"‚úÖ This order is already completed.")
        
        # Mark as paid and process order
        now_utc = datetime.now(timezone.utc)
        db.collection(STOCK_ORDERS_COLLECTION).document(order_id).update({
            'paymentStatus': 'paid',
            'orderStatus': 'completed',
            'confirmedBy': interaction.user.id,
            'confirmedAt': now_utc
        })
        
        # Grant shares to buyer
        business_id = order_data.get('businessId')
        if not business_id:
            return await interaction.edit_original_response(content=f"‚ùå Order missing businessId. Please contact a developer.")
        buyer_id = order_data['buyerId']
        shares = order_data['shares']
        business_name = order_data['businessName']
        
        existing_shares = db.collection(SHARES_COLLECTION).where(
            filter=FieldFilter('businessId', '==', business_id)
        ).where(
            filter=FieldFilter('ownerId', '==', buyer_id)
        ).limit(1).stream()
        existing_list = list(existing_shares)
        
        if existing_list:
            # Update existing holding
            existing_doc = existing_list[0]
            existing_data = existing_doc.to_dict()
            db.collection(SHARES_COLLECTION).document(existing_doc.id).update({
                'shares': existing_data['shares'] + shares
            })
        else:
            # Create new holding
            db.collection(SHARES_COLLECTION).add({
                'businessId': business_id,
                'businessName': business_name,
                'ownerId': buyer_id,
                'ownerTag': order_data['buyerTag'],
                'shares': shares,
                'acquiredDate': now_utc
            })
        
        # Update IPO
        ipo_doc = db.collection(IPOS_COLLECTION).document(order_data['ipoId']).get()
        if ipo_doc.exists:
            ipo_data = ipo_doc.to_dict()
            new_shares_remaining = ipo_data['sharesRemaining'] - shares
            new_total_raised = ipo_data['totalRaised'] + order_data['totalCost']
            
            # DEMAND-BASED PRICING: Increase price by 3% after each purchase
            current_price = ipo_data['pricePerShare']
            new_price = current_price * 1.03  # 3% increase
            
            update_data = {
                'sharesRemaining': new_shares_remaining,
                'totalRaised': new_total_raised,
                'pricePerShare': new_price  # Dynamic pricing
            }
            
            # Close IPO if sold out and distribute proceeds
            if new_shares_remaining == 0:
                update_data['status'] = 'completed'
                
                # IPO PROCEEDS DISTRIBUTION: 90% to business owner, 10% to exchange
                total_raised = new_total_raised
                owner_proceeds = total_raised * 0.90
                exchange_fee = total_raised * 0.10
                
                # Get business owner
                business_doc = db.collection(BUSINESSES_COLLECTION).document(business_id).get()
                if business_doc.exists:
                    business_data = business_doc.to_dict()
                    owner_id = business_data.get('ownerId')
                    
                    # Record payment distribution
                    db.collection('ipo_payouts').add({
                        'ipoId': order_data['ipoId'],
                        'businessId': business_id,
                        'businessName': business_name,
                        'totalRaised': total_raised,
                        'ownerProceeds': owner_proceeds,
                        'exchangeFee': exchange_fee,
                        'ownerId': owner_id,
                        'paidAt': datetime.now(timezone.utc),
                        'status': 'completed'
                    })
                    
                    print(f"[IPO] Completed! {business_name} raised {total_raised:.1f}d (Owner: {owner_proceeds:.1f}d | Exchange: {exchange_fee:.1f}d)")
            
            db.collection(IPOS_COLLECTION).document(order_data['ipoId']).update(update_data)
            
            # Update business share price to match new IPO price
            db.collection(BUSINESSES_COLLECTION).document(business_id).update({
                'sharePrice': new_price
            })
        
        # Log transaction
        db.collection(STOCK_TRANSACTIONS_COLLECTION).add({
            'businessId': business_id,
            'businessName': business_name,
            'buyerId': buyer_id,
            'buyerTag': order_data['buyerTag'],
            'sellerId': 0,  # IPO / business owner
            'shares': shares,
            'pricePerShare': order_data['pricePerShare'],
            'totalAmount': order_data['totalCost'],
            'type': 'ipo_purchase',
            'paymentMethod': order_data.get('paymentMethod', 'unknown'),
            'timestamp': now_utc
        })
        
        # Payment method display
        payment_method_display = f"{DIAMOND_EMOJI} Direct payment" if order_data.get('paymentMethod') == 'direct' else "üè¶ Bank transfer (HS-9503)"
        
        # Get updated price info
        price_info = ""
        if ipo_doc.exists:
            ipo_data_updated = db.collection(IPOS_COLLECTION).document(order_data['ipoId']).get().to_dict()
            if ipo_data_updated:
                old_price = ipo_data['pricePerShare']
                new_price_val = ipo_data_updated['pricePerShare']
                shares_left = ipo_data_updated.get('sharesRemaining', 0)
                price_info = f"\nüìà **Market Update**: Price increased {old_price:.1f}d ‚Üí {new_price_val:.1f}d (+3%)"
                if shares_left > 0:
                    price_info += f"\nüìä **{shares_left:,} shares remaining** at new price"
                else:
                    price_info += f"\nüéâ **IPO SOLD OUT!** All shares purchased."
        
        await interaction.edit_original_response(content=
            f"‚úÖ Payment confirmed for Order ID `{order_id}`\n"
            f"**Buyer**: {order_data.get('buyerTag')}\n"
            f"**Business**: {business_name}\n"
            f"**Shares**: {shares:,}\n"
            f"**Cost**: {order_data['totalCost']:.1f} diamonds\n"
            f"**Payment**: {payment_method_display}\n\n"
            f"Shares have been granted to the buyer!{price_info}")
        
        print(f"[STOCK] Payment confirmed for order {order_id} by {interaction.user} ({payment_method_display})")
        
    except Exception as e:
        print(f"[ERR] Stock payment confirmation failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to confirm payment: {str(e)}")

@market_group.command(name="confirm_sell_payment", description="üí∏ Confirm citizen's sell order and mark as paid (Admin only)")
@app_commands.describe(
    order_id="Sell order ID from /market sell_stock"
)
async def confirm_sell_payment_cmd(interaction: discord.Interaction, order_id: str):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can confirm sell payments.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Clean order ID (remove backticks if user copied them)
        order_id = order_id.strip().strip('`')
        
        # Get sell order
        order_doc = db.collection(STOCK_ORDERS_COLLECTION).document(order_id).get()
        
        if not order_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Sell order ID `{order_id}` not found.")
        
        order_data = order_doc.to_dict()
        
        # Check if it's a sell order
        if order_data.get('orderType') != 'sell':
            return await interaction.edit_original_response(content=f"‚ùå This is not a sell order. Use /market confirm_payment for buy orders.")
        
        if order_data.get('paymentStatus') == 'paid':
            return await interaction.edit_original_response(content=f"‚úÖ This sell order is already completed.")
        
        # Get order details
        seller_id = order_data.get('sellerId')
        seller_tag = order_data.get('sellerTag')
        business_name = order_data.get('businessName')
        shares = order_data.get('shares')
        total_value = order_data.get('totalValue')
        holding_id = order_data.get('holdingId')
        
        # Reduce or delete user's shares
        holding_doc = db.collection(SHARES_COLLECTION).document(holding_id).get()
        
        if not holding_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Share holding not found. Shares may have already been sold.")
        
        holding_data = holding_doc.to_dict()
        current_shares = holding_data.get('shares', 0)
        
        if current_shares < shares:
            return await interaction.edit_original_response(content=
                f"‚ùå Seller only has {current_shares:,} shares, cannot sell {shares:,}.")
        
        # Update or delete holding
        new_share_count = current_shares - shares
        
        if new_share_count == 0:
            # Delete holding
            db.collection(SHARES_COLLECTION).document(holding_id).delete()
        else:
            # Update holding
            db.collection(SHARES_COLLECTION).document(holding_id).update({
                'shares': new_share_count
            })
        
        # Mark order as completed
        db.collection(STOCK_ORDERS_COLLECTION).document(order_id).update({
            'paymentStatus': 'paid',
            'orderStatus': 'completed',
            'confirmedBy': interaction.user.id,
            'confirmedAt': datetime.now(timezone.utc)
        })
        
        # Log transaction
        db.collection(STOCK_TRANSACTIONS_COLLECTION).add({
            'businessName': business_name,
            'sellerId': seller_id,
            'sellerTag': seller_tag,
            'buyerId': 0,  # Bought back or removed from market
            'shares': shares,
            'pricePerShare': order_data.get('pricePerShare'),
            'totalAmount': total_value,
            'type': 'share_sale',
            'timestamp': datetime.now(timezone.utc)
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ Sell order confirmed for Order ID `{order_id}`\n"
            f"**Seller**: {seller_tag}\n"
            f"**Business**: {business_name}\n"
            f"**Shares Sold**: {shares:,}\n"
            f"**Diamonds to Pay**: {total_value:.1f}d\n\n"
            f"{DIAMOND_EMOJI} **PAY {total_value:.1f} diamonds in-game to the seller!**\n"
            f"Shares have been deducted from seller's portfolio.")
        
        print(f"[STOCK] Sell order confirmed: {order_id} - {seller_tag} sold {shares} shares of {business_name} for {total_value:.1f}d")
        
    except Exception as e:
        print(f"[ERR] Confirm sell payment failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to confirm sell payment: {str(e)}")

@market_group.command(name="payment_pending", description="üìã View all unpaid stock orders (Admin only)")
async def stock_payment_pending_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can view pending payments.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all unpaid orders
        unpaid_orders = list(db.collection(STOCK_ORDERS_COLLECTION).where(
            filter=FieldFilter('paymentStatus', '==', 'unpaid')
        ).stream())
        
        if not unpaid_orders:
            return await interaction.edit_original_response(content="‚úÖ No pending stock payments! All orders are paid.")
        
        # Separate buy and sell orders
        buy_orders = [o for o in unpaid_orders if o.to_dict().get('orderType') != 'sell']
        sell_orders = [o for o in unpaid_orders if o.to_dict().get('orderType') == 'sell']
        
        embed = discord.Embed(
            title=f"{DIAMOND_EMOJI} PENDING STOCK PAYMENTS",
            description=f"**{len(unpaid_orders)} orders awaiting confirmation** ({len(buy_orders)} buy | {len(sell_orders)} sell)",
            color=discord.Color.orange()
        )
        
        # Show buy orders
        total_to_receive = 0
        if buy_orders:
            for order_doc in buy_orders[:5]:  # Show top 5
                order_data = order_doc.to_dict()
                buyer = order_data.get('buyerName', 'Unknown')
                business = order_data.get('businessName', 'Unknown')
                shares = order_data.get('shares', 0)
                cost = order_data.get('totalCost', 0)
                method = order_data.get('paymentMethod', 'unknown')
                
                method_icon = f"{DIAMOND_EMOJI}" if method == 'direct' else "üè¶"
                method_text = "Direct" if method == 'direct' else "Bank HS-9503"
                total_to_receive += cost
                
                embed.add_field(
                    name=f"üìà BUY: {buyer} ‚Üí {business}",
                    value=f"**{shares:,} shares** @ **{cost:.1f}d** | {method_text}\nOrder ID: `{order_doc.id}`",
                    inline=False
                )
        
        # Show sell orders
        total_to_pay = 0
        if sell_orders:
            for order_doc in sell_orders[:5]:  # Show top 5
                order_data = order_doc.to_dict()
                seller = order_data.get('sellerName', 'Unknown')
                business = order_data.get('businessName', 'Unknown')
                shares = order_data.get('shares', 0)
                value = order_data.get('totalValue', 0)
                total_to_pay += value
                
                embed.add_field(
                    name=f"üí∏ SELL: {seller} ‚Üí {business}",
                    value=f"**{shares:,} shares** @ **{value:.1f}d**\nOrder ID: `{order_doc.id}`",
                    inline=False
                )
        
        # Summary
        if total_to_receive > 0:
            embed.add_field(
                name="üí∞ Diamonds to Receive (from buyers)",
                value=f"**{total_to_receive:,.0f}d**",
                inline=True
            )
        if total_to_pay > 0:
            embed.add_field(
                name="üí∏ Diamonds to Pay (to sellers)",
                value=f"**{total_to_pay:,.0f}d**",
                inline=True
            )
        
        embed.set_footer(text="Use /market confirm_payment for buys | /market confirm_sell_payment for sells")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] View pending stock payments failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view pending payments: {str(e)}")

@market_group.command(name="sell_stock", description="üí∏ Sell your stock shares")
@app_commands.describe(
    business="Business name to sell shares from",
    shares="Number of shares to sell"
)
async def sell_stock_cmd(interaction: discord.Interaction, business: str, shares: int):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if not is_citizen(interaction.user.id):
        return await interaction.edit_original_response(content="‚ùå Only citizens can sell shares.")
    
    if shares <= 0:
        return await interaction.edit_original_response(content="‚ùå Share amount must be positive.")
    
    try:
        # Find user's holding for this business
        holdings_query = db.collection(SHARES_COLLECTION).where(
            filter=FieldFilter('ownerId', '==', interaction.user.id)
        ).where(
            filter=FieldFilter('businessName', '==', business)
        ).limit(1)
        
        holdings = list(holdings_query.stream())
        
        if not holdings:
            return await interaction.edit_original_response(content=f"‚ùå You don't own shares in **{business}**.")
        
        holding_doc = holdings[0]
        
        # Debug: Check if holding_doc is actually a DocumentSnapshot
        if not hasattr(holding_doc, 'id'):
            print(f"[ERR] holding_doc type error: {type(holding_doc)} - {holding_doc}")
            return await interaction.edit_original_response(content=f"‚ùå Database error: Invalid holding data. Please contact an admin.")
        
        holding_data = holding_doc.to_dict()
        owned_shares = holding_data.get('shares', 0)
        
        if owned_shares < shares:
            return await interaction.edit_original_response(content=
                f"‚ùå You only own **{owned_shares:,} shares** of {business}. Cannot sell {shares:,}."
            )
        
        # Get current market price from IPO
        ipos = list(db.collection(IPOS_COLLECTION).where(
            filter=FieldFilter('businessName', '==', business)
        ).limit(1).stream())
        
        if not ipos:
            return await interaction.edit_original_response(content=
                f"‚ùå No active IPO found for **{business}**. Cannot determine market price."
            )
        
        ipo_data = ipos[0].to_dict()
        current_price = ipo_data.get('pricePerShare', 0)
        total_value = shares * current_price
        
        # Create pending sell order
        now_utc = datetime.now(timezone.utc)
        _, sell_order_ref = db.collection(STOCK_ORDERS_COLLECTION).add({
            'businessName': business,
            'sellerId': interaction.user.id,
            'sellerTag': interaction.user.mention,
            'sellerName': interaction.user.name,
            'shares': shares,
            'pricePerShare': current_price,
            'totalValue': total_value,
            'holdingId': holding_doc.id,
            'orderType': 'sell',
            'paymentStatus': 'unpaid',
            'orderStatus': 'pending',
            'createdAt': now_utc
        })
        
        sell_order_id = sell_order_ref.id
        
        embed = discord.Embed(
            title="üí∏ SELL ORDER PLACED",
            description=f"Your sell order for **{business}** is pending admin confirmation.",
            color=discord.Color.orange()
        )
        embed.add_field(name="üìä Sell Details", value=f"**{shares:,} shares** @ **{current_price:.1f}d** each", inline=False)
        embed.add_field(name=f"{DIAMOND_EMOJI} Total Value", value=f"**{total_value:.1f} diamonds**", inline=True)
        embed.add_field(name="üìã Order ID", value=f"`{sell_order_id}`", inline=True)
        embed.add_field(
            name="‚è≥ Next Steps",
            value="An admin will confirm your sell order and pay you diamonds in-game.",
            inline=False
        )
        embed.set_footer(text="Your shares will be deducted after admin confirmation")
        
        await interaction.edit_original_response(embed=embed)
        print(f"[STOCK] Sell order created: {interaction.user.name} selling {shares} shares of {business} for {total_value:.1f}d")
        
    except Exception as e:
        print(f"[ERR] Sell stock failed: {e}")
        traceback.print_exc()  # Print full traceback to find exact line
        await interaction.edit_original_response(content=f"‚ùå Failed to sell stock: {str(e)}")

@market_group.command(name="portfolio", description="üìä View your stock portfolio")
async def portfolio_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get user's holdings
        holdings = db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', interaction.user.id)).stream()
        holdings_list = []
        total_value = 0.0
        
        for holding_doc in holdings:
            holding_data = holding_doc.to_dict()
            shares = holding_data.get('shares', 0)
            
            if shares > 0:
                business_name = holding_data.get('businessName', 'Unknown')
                
                # Get current business price
                businesses = db.collection(BUSINESSES_COLLECTION).where(filter=FieldFilter('name', '==', business_name)).limit(1).stream()
                business_list = list(businesses)
                
                if business_list:
                    business_data = business_list[0].to_dict()
                    price = business_data.get('sharePrice', 0.0)
                    value = shares * price
                    total_value += value
                    
                    holdings_list.append({
                        'name': business_name,
                        'shares': shares,
                        'price': price,
                        'value': value
                    })
        
        if not holdings_list:
            return await interaction.edit_original_response(content="üìä Your portfolio is empty. Buy shares to start investing!")
        
        # Sort by value
        holdings_list.sort(key=lambda x: x['value'], reverse=True)
        
        embed = discord.Embed(
            title=f"üìä {interaction.user.display_name}'s Portfolio",
            description=f"**Total Value:** {total_value:,.2f} diamonds",
            color=discord.Color.blue()
        )
        
        for holding in holdings_list:
            embed.add_field(
                name=f"üìà {holding['name']}",
                value=f"**{holding['shares']:,}** shares @ {holding['price']:.2f}d = **{holding['value']:,.2f}d**",
                inline=False
            )
        
        embed.set_footer(text=f"Holdings: {len(holdings_list)} businesses")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Portfolio view failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view portfolio: {str(e)}")

@market_group.command(name="pay_dividend", description="üíµ Pay dividends to shareholders")
@app_commands.describe(
    business_name="Your business name",
    amount_per_share="Dividend amount per share in diamonds"
)
async def dividend_pay_cmd(interaction: discord.Interaction, business_name: str, amount_per_share: float):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if amount_per_share <= 0:
        return await interaction.edit_original_response(content="‚ùå Dividend amount must be positive.")
    
    try:
        # Find business
        businesses = db.collection(BUSINESSES_COLLECTION).where(filter=FieldFilter('name', '==', business_name)).limit(1).stream()
        business_list = list(businesses)
        
        if not business_list:
            return await interaction.edit_original_response(content=f"‚ùå Business '{business_name}' not found.")
        
        business_doc = business_list[0]
        business_data = business_doc.to_dict()
        business_id = business_doc.id
        
        # Verify ownership
        if business_data['ownerId'] != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå Only the business owner can pay dividends.")
        
        # Get all shareholders
        shareholders = db.collection(SHARES_COLLECTION).where(filter=FieldFilter('businessId', '==', business_id)).stream()
        
        now_utc = datetime.now(timezone.utc)
        now_est = now_utc.astimezone(EST)
        
        total_paid = 0.0
        recipient_count = 0
        payments = []
        
        for shareholder_doc in shareholders:
            shareholder_data = shareholder_doc.to_dict()
            shares = shareholder_data.get('shares', 0)
            
            if shares > 0:
                payout = shares * amount_per_share
                total_paid += payout
                recipient_count += 1
                
                payments.append({
                    'ownerTag': shareholder_data.get('ownerTag', 'Unknown'),
                    'shares': shares,
                    'payout': payout
                })
                
                # Log dividend payment
                db.collection(DIVIDENDS_COLLECTION).add({
                    'businessId': business_id,
                    'businessName': business_name,
                    'recipientId': shareholder_data.get('ownerId'),
                    'recipientTag': shareholder_data.get('ownerTag'),
                    'shares': shares,
                    'amountPerShare': amount_per_share,
                    'totalPayout': payout,
                    'paidBy': interaction.user.id,
                    'paidAt': now_utc
                })
        
        # Update business last dividend date
        db.collection(BUSINESSES_COLLECTION).document(business_id).update({
            'lastDividend': now_utc
        })
        
        embed = discord.Embed(
            title="üíµ Dividends Paid!",
            description=f"**{business_name}** distributed dividends to shareholders",
            color=discord.Color.gold()
        )
        embed.add_field(name="üí∞ Per Share", value=f"{amount_per_share:.2f} diamonds", inline=True)
        embed.add_field(name="üë• Recipients", value=f"{recipient_count} shareholders", inline=True)
        embed.add_field(name=f"{DIAMOND_EMOJI} Total Paid", value=f"{total_paid:,.2f} diamonds", inline=True)
        
        # Show top 5 payments
        payments.sort(key=lambda x: x['payout'], reverse=True)
        top_payments = "\n".join([
            f"{p['ownerTag']}: {p['payout']:,.2f}d ({p['shares']:,} shares)"
            for p in payments[:5]
        ])
        embed.add_field(name="üìä Top Payouts", value=top_payments, inline=False)
        embed.set_footer(text=f"Paid on {now_est.strftime('%m/%d/%y %I:%M %p EST')}")
        
        await interaction.edit_original_response(embed=embed)
        print(f"[DIVIDEND] {interaction.user} paid {amount_per_share}d/share for {business_name} to {recipient_count} shareholders")
        
    except Exception as e:
        print(f"[ERR] Dividend payment failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to pay dividends: {str(e)}")

@market_group.command(name="ipo_earnings", description="üí∞ View your IPO earnings")
async def ipo_earnings_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get IPO payouts for this user
        payouts = list(db.collection('ipo_payouts').where(
            filter=FieldFilter('ownerId', '==', interaction.user.id)
        ).stream())
        
        if not payouts:
            return await interaction.edit_original_response(content="üí∞ You haven't received any IPO earnings yet.")
        
        embed = discord.Embed(
            title="üí∞ Your IPO Earnings",
            description=f"Revenue from completed IPO sales",
            color=discord.Color.green()
        )
        
        total_earned = 0
        total_exchange_fees = 0
        
        for payout_doc in payouts:
            payout_data = payout_doc.to_dict()
            business_name = payout_data.get('businessName', 'Unknown')
            owner_proceeds = payout_data.get('ownerProceeds', 0)
            exchange_fee = payout_data.get('exchangeFee', 0)
            total_raised = payout_data.get('totalRaised', 0)
            
            total_earned += owner_proceeds
            total_exchange_fees += exchange_fee
            
            embed.add_field(
                name=f"üè¢ {business_name}",
                value=f"**Total Raised:** {total_raised:,.0f}d\n**Your Earnings:** {owner_proceeds:,.0f}d (90%)\n**Exchange Fee:** {exchange_fee:,.0f}d (10%)",
                inline=False
            )
        
        embed.add_field(
            name=f"{DIAMOND_EMOJI} Total Lifetime Earnings",
            value=f"**{total_earned:,.0f} diamonds** from {len(payouts)} IPO(s)",
            inline=False
        )
        embed.set_footer(text="IPO proceeds are automatically calculated when all shares sell out")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] IPO earnings view failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view earnings: {str(e)}")

@market_group.command(name="dashboard", description="üìà View stock market dashboard")
async def market_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.followup.send("‚ùå Database not available.", ephemeral=True)
    
    try:
        # Get all active IPOs
        active_ipos = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('status', '==', 'active')).stream())
        
        # Get all registered businesses
        all_businesses = list(db.collection(BUSINESSES_COLLECTION).stream())
        
        if not active_ipos and not all_businesses:
            return await interaction.followup.send("üìà No businesses registered yet. Use `/market register` to get started!", ephemeral=True)
        
        embed = discord.Embed(
            title="üìà Florab√≠s Stock Market Dashboard",
            description=f"*{len(all_businesses)} businesses registered | {len(active_ipos)} active IPOs*",
            color=0x1e3a5f
        )
        
        # Show active IPOs
        if active_ipos:
            ipo_text = ""
            for ipo_doc in active_ipos[:10]:
                data = ipo_doc.to_dict()
                name = data['businessName']
                price = data['pricePerShare']
                shares_left = data.get('sharesRemaining', 0)
                total_shares = data.get('sharesOffered', 0)
                market_cap = total_shares * price
                
                ipo_text += f"**{name}**\n"
                ipo_text += f"‚îî {DIAMOND_EMOJI} {price:.1f}d/share | {shares_left:,}/{total_shares:,} left | Cap: {market_cap:,.0f}d\n\n"
            
            embed.add_field(
                name="üî• Active IPOs - Ready to Buy",
                value=ipo_text.strip(),
                inline=False
            )
        
        # Show all businesses
        if all_businesses:
            biz_text = ""
            for biz_doc in all_businesses[:10]:
                data = biz_doc.to_dict()
                name = data.get('name', 'Unknown')
                sector = data.get('sector', 'General')
                status = data.get('status', 'private')
                
                status_emoji = "üîî" if status == 'public' else "üîí"
                biz_text += f"{status_emoji} **{name}** ({sector})\n"
            
            embed.add_field(
                name="üè¢ All Registered Businesses",
                value=biz_text.strip(),
                inline=False
            )
        
        embed.set_footer(text="üí° Use /market buy_stock to invest | Click Market Dashboard button for graphs")
        
        await interaction.followup.send(embed=embed, ephemeral=True)
        
    except Exception as e:
        print(f"[ERR] Market dashboard failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.followup.send(f"‚ùå Failed to view market: {str(e)}", ephemeral=True)

# ==================================================
# BETTING SYSTEM - Tom Brady's Royal Betting Exchange
# ==================================================

BETTING_MASCOT_NAME = "üèà Tom Brady's Royal Betting Exchange"
BETTING_MASCOT_AVATAR = "https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/25th_Laureus_World_Sports_Awards_-_Red_Carpet_-_Tom_Brady_-_240422_191334_%28cropped%29_%28cropped%29.jpg/250px-25th_Laureus_World_Sports_Awards_-_Red_Carpet_-_Tom_Brady_-_240422_191334_%28cropped%29_%28cropped%29.jpg"  # Tom Brady
BETTING_COLOR = 0xDC143C  # Crimson red (Patriots colors)

# Helper: Get betting leaderboard stats
def get_betting_stats(user_id):
    """Get or create betting stats for a user"""
    if not db:
        return None
    
    stats_docs = list(db.collection(BETTING_LEADERBOARD_COLLECTION).where(filter=FieldFilter('userId', '==', user_id)).limit(1).stream())
    
    if stats_docs:
        return stats_docs[0]
    else:
        # Create new stats
        _, stats_ref = db.collection(BETTING_LEADERBOARD_COLLECTION).add({
            'userId': user_id,
            'totalBets': 0,
            'totalWagered': 0.0,
            'totalWon': 0.0,
            'totalLost': 0.0,
            'netProfit': 0.0,
            'wins': 0,
            'losses': 0,
            'winRate': 0.0,
            'biggestWin': 0.0,
            'biggestLoss': 0.0
        })
        return db.collection(BETTING_LEADERBOARD_COLLECTION).document(stats_ref.id).get()

@betting_group.command(name="create", description="üé∞ Create a betting event (Admin only)")
@app_commands.describe(
    title="Event title (e.g., 'Diamond Market Forecast' or 'Election Outcome')",
    contestants="Comma-separated contestants (e.g., 'Bull Market,Bear Market,Sideways')",
    event_type="Type of event",
    closes_in_minutes="When betting closes (minutes from now)"
)
@app_commands.choices(event_type=[
    app_commands.Choice(name="üìä Market Prediction", value="market"),
    app_commands.Choice(name="‚öîÔ∏è PvP/War Outcome", value="pvp_arena"),
    app_commands.Choice(name="üèõÔ∏è Political Event", value="political"),
    app_commands.Choice(name="üéØ Other Event", value="other")
])
async def bet_event_create_cmd(
    interaction: discord.Interaction,
    title: str,
    contestants: str,
    event_type: app_commands.Choice[str],
    closes_in_minutes: int = 30
):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    # Check admin permission
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can create betting events.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Parse contestants
        contestant_list = [c.strip() for c in contestants.split(',') if c.strip()]
        
        if len(contestant_list) < 2:
            return await interaction.edit_original_response(content="‚ùå You need at least 2 contestants!")
        
        now_utc = datetime.now(timezone.utc)
        closes_at = now_utc + timedelta(minutes=closes_in_minutes)
        
        # Create event
        _, event_ref = db.collection(BETTING_EVENTS_COLLECTION).add({
            'title': title,
            'eventType': event_type.value,
            'contestants': contestant_list,
            'createdBy': interaction.user.id,
            'createdAt': now_utc,
            'closesAt': closes_at,
            'status': 'open',
            'totalPool': 0.0,
            'betsPerContestant': {c: 0.0 for c in contestant_list},
            'winner': None,
            'messageId': None
        })
        
        event_id = event_ref.id
        
        # Create betting panel
        embed = discord.Embed(
            title=f"{BETTING_MASCOT_NAME}",
            description=f"**{title}**\n\n*\"Welcome, citizens! Place your bets and fortune favors the bold!\"*",
            color=BETTING_COLOR
        )
        embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
        
        # Event details
        event_icons = {
            'horse_race': 'üèá',
            'pvp_arena': '‚öîÔ∏è',
            'political': 'üèõÔ∏è',
            'other': 'üéØ'
        }
        icon = event_icons.get(event_type.value, 'üé∞')
        
        embed.add_field(
            name=f"{icon} Event Type",
            value=event_type.name,
            inline=True
        )
        
        # Betting closes
        est_tz = EST
        closes_est = closes_at.astimezone(est_tz)
        embed.add_field(
            name="‚è∞ Betting Closes",
            value=closes_est.strftime('%m/%d/%y %I:%M %p EST'),
            inline=True
        )
        
        # Current odds (all even at start)
        odds_text = "\n".join([f"**{c}**: Pending (No bets yet)" for c in contestant_list])
        embed.add_field(
            name="üìä Live Odds",
            value=odds_text,
            inline=False
        )
        
        embed.add_field(
            name="üí∞ Total Pool",
            value="0 diamonds",
            inline=True
        )
        
        embed.add_field(
            name="üìà Total Bets",
            value="0 bets placed",
            inline=True
        )
        
        embed.set_footer(text=f"Event ID: {event_id} | Click 'Place Bet' to participate!")
        
        # Create button
        view = discord.ui.View(timeout=None)
        bet_button = discord.ui.Button(
            label="Place Bet",
            style=discord.ButtonStyle.success,
            custom_id=f"bet_place_{event_id}",
            emoji="üí∞"
        )
        view.add_item(bet_button)
        
        # Post to channel
        channel = interaction.channel
        message = await channel.send(embed=embed, view=view)
        
        # Save message ID
        db.collection(BETTING_EVENTS_COLLECTION).document(event_id).update({
            'messageId': message.id,
            'channelId': channel.id
        })
        
        await interaction.edit_original_response(content=f"‚úÖ Betting event created! Event ID: `{event_id}`")
        print(f"[BETTING] Event created: {title} by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Betting event creation failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to create event: {str(e)}")

# Handle betting button clicks
@bot.event
async def on_interaction(interaction: discord.Interaction):
    if interaction.type != discord.InteractionType.component:
        return
    
    custom_id = interaction.data.get('custom_id', '')
    
    # Handle bet placement - SHOW CONTESTANT BUTTONS
    if custom_id.startswith('bet_place_'):
        event_id = custom_id.replace('bet_place_', '')
        
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Get event
            event_doc = db.collection(BETTING_EVENTS_COLLECTION).document(event_id).get()
            if not event_doc.exists:
                return await interaction.response.send_message("‚ùå Event not found.", ephemeral=True)
            
            event_data = event_doc.to_dict()
            
            # Check if closed
            if event_data.get('status') != 'open':
                return await interaction.response.send_message("‚ùå Betting is closed for this event.", ephemeral=True)
            
            now_utc = datetime.now(timezone.utc)
            closes_at = event_data.get('closesAt')
            
            if now_utc >= closes_at:
                return await interaction.response.send_message("‚ùå Betting has closed for this event.", ephemeral=True)
            
            # Show contestant selection buttons
            contestants = event_data.get('contestants', [])
            
            embed = discord.Embed(
                title=f"{DIAMOND_EMOJI} Select Your Contestant",
                description=f"**{event_data.get('title', 'Event')}**\n\nClick the button for who you want to bet on:",
                color=BETTING_COLOR
            )
            embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
            
            # Show current odds
            total_pool = event_data.get('totalPool', 0)
            bets_per = event_data.get('betsPerContestant', {})
            
            odds_text = ""
            for c in contestants:
                amount = bets_per.get(c, 0)
                if total_pool > 0:
                    odds = (total_pool / amount) if amount > 0 else 0
                    odds_text += f"**{c}**: {odds:.2f}:1 ({amount:,.0f}d)\n"
                else:
                    odds_text += f"**{c}**: Even (No bets yet)\n"
            
            embed.add_field(name="üìä Current Odds", value=odds_text, inline=False)
            embed.set_footer(text="Click a contestant below to place your bet!")
            
            # Check if event has contestants
            if not contestants:
                return await interaction.response.send_message("‚ùå This event has no contestants.", ephemeral=True)
            
            # Create buttons for ALL contestants (up to 25 max - Discord limit)
            view = discord.ui.View(timeout=300)
            
            for contestant in contestants[:25]:  # Discord max: 25 buttons (5 rows x 5 buttons)
                button = discord.ui.Button(
                    label=contestant[:80],  # Discord max label length is 80 chars
                    style=discord.ButtonStyle.primary,
                    custom_id=f"bet_contestant_{event_id}_{contestant}",
                    emoji="üéØ"
                )
                view.add_item(button)
            
            # If more than 25 contestants, warn user
            if len(contestants) > 25:
                embed.add_field(
                    name="‚ö†Ô∏è Note",
                    value=f"Only showing first 25 contestants (total: {len(contestants)})",
                    inline=False
                )
            
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
            
        except Exception as e:
            print(f"[ERR] Bet button interaction failed: {e}")
            await interaction.response.send_message(f"‚ùå Error: {str(e)}", ephemeral=True)
    
    # Handle contestant selection - SHOW BET AMOUNT MODAL
    if custom_id.startswith('bet_contestant_'):
        parts = custom_id.replace('bet_contestant_', '').split('_', 1)
        event_id = parts[0]
        contestant_name = parts[1] if len(parts) > 1 else ""
        
        if not db:
            return await interaction.response.send_message("‚ùå Database not available.", ephemeral=True)
        
        try:
            # Get event
            event_doc = db.collection(BETTING_EVENTS_COLLECTION).document(event_id).get()
            if not event_doc.exists:
                return await interaction.response.send_message("‚ùå Event not found.", ephemeral=True)
            
            event_data = event_doc.to_dict()
            
            # Create modal for bet amount only
            class BetAmountModal(discord.ui.Modal, title=f"Bet on {contestant_name}"):
                amount = discord.ui.TextInput(
                    label="Bet Amount (Diamonds)",
                    placeholder="e.g., 50 (Min: 5, Max: 500)",
                    required=True,
                    max_length=10
                )
                
                async def on_submit(modal_self, modal_interaction: discord.Interaction):
                    await modal_interaction.response.send_message(f"{DIAMOND_EMOJI} Processing bet...")
                    
                    try:
                        bet_amount = float(modal_self.amount.value)
                        
                        if bet_amount < 5:
                            return await modal_interaction.edit_original_response(content="‚ùå Minimum bet is 5 diamonds.")
                        
                        if bet_amount > 500:
                            return await modal_interaction.edit_original_response(content="‚ùå Maximum bet is 500 diamonds.")
                        
                        # Create private thread for this bet
                        channel = modal_interaction.channel
                        thread_name = f"Bet: {modal_interaction.user.name} - {event_data.get('title', 'Event')[:50]}"
                        
                        thread = await channel.create_thread(
                            name=thread_name,
                            type=discord.ChannelType.private_thread,
                            invitable=False
                        )
                        
                        # Add user to thread
                        await thread.add_user(modal_interaction.user)
                        
                        # Record bet
                        now_utc = datetime.now(timezone.utc)
                        _, bet_ref = db.collection(BETTING_BETS_COLLECTION).add({
                            'eventId': event_id,
                            'userId': modal_interaction.user.id,
                            'userTag': modal_interaction.user.mention,
                            'userName': modal_interaction.user.name,
                            'contestant': contestant_name,
                            'amount': bet_amount,
                            'placedAt': now_utc,
                            'status': 'pending',
                            'paymentStatus': 'unpaid',
                            'payout': 0.0,
                            'threadId': thread.id
                        })
                        
                        # Update event pool
                        current_pool = event_data.get('totalPool', 0.0)
                        contestant_total = event_data.get('betsPerContestant', {}).get(contestant_name, 0.0)
                        
                        db.collection(BETTING_EVENTS_COLLECTION).document(event_id).update({
                            'totalPool': current_pool + bet_amount,
                            f'betsPerContestant.{contestant_name}': contestant_total + bet_amount
                        })
                        
                        # Send confirmation in thread
                        est_tz = EST
                        now_est = now_utc.astimezone(est_tz)
                        
                        thread_embed = discord.Embed(
                            title=f"{DIAMOND_EMOJI} Bet Placed - PAYMENT REQUIRED",
                            description=f"**{event_data.get('title')}**\n\n‚ö†Ô∏è **Your bet is UNPAID** - You must pay diamonds in-game!",
                            color=discord.Color.orange()
                        )
                        thread_embed.set_author(name="Tom Brady")
                        thread_embed.add_field(name="üéØ Contestant", value=contestant_name, inline=True)
                        thread_embed.add_field(name="üí∞ Amount Owed", value=f"**{bet_amount:,.0f} diamonds**", inline=True)
                        thread_embed.add_field(name="‚è∞ Placed", value=now_est.strftime('%I:%M %p EST'), inline=False)
                        
                        # Payment instructions
                        thread_embed.add_field(
                            name="üìç PAYMENT INSTRUCTIONS - Choose ONE method:",
                            value=(
                                f"**Option 1: {DIAMOND_EMOJI} Direct In-Game Payment**\n"
                                f"‚Ä¢ Find an Admin/Treasurer in-game\n"
                                f"‚Ä¢ Give them **{bet_amount:,.0f} diamonds** directly\n"
                                f"‚Ä¢ Tell them Bet ID: `{bet_ref.id}`\n\n"
                                f"**Option 2: üè¶ Bank Transfer**\n"
                                f"‚Ä¢ Transfer **{bet_amount:,.0f} diamonds** to **Sort Code HS-3112**\n"
                                f"‚Ä¢ Tell Admin: Bet ID `{bet_ref.id}`\n"
                                f"‚Ä¢ Admin will withdraw from bank\n\n"
                                f"‚ùå **Unpaid bets will be CANCELLED**"
                            ),
                            inline=False
                        )
                        
                        thread_embed.set_footer(text=f"Bet ID: {bet_ref.id} | Payment Status: UNPAID")
                        
                        # Ping Betting Manager + Bancquero for payment notification
                        # Only ping if the roles actually exist in the guild (prevents @unknown)
                        pings = []
                        if interaction.guild:
                            if BETTING_MANAGER_ROLE_ID:
                                betting_role = interaction.guild.get_role(BETTING_MANAGER_ROLE_ID)
                                if betting_role:
                                    pings.append(f"<@&{BETTING_MANAGER_ROLE_ID}>")
                            if BANCQUERO_ROLE_ID:
                                bancquero_role = interaction.guild.get_role(BANCQUERO_ROLE_ID)
                                if bancquero_role:
                                    pings.append(f"<@&{BANCQUERO_ROLE_ID}>")
                        
                        ping_text = " ".join(pings) if pings else "Admins"
                        await thread.send(
                            content=f"{ping_text} **Payment Collection Required**",
                            embed=thread_embed
                        )
                        
                        await modal_interaction.edit_original_response(
                            content=f"‚úÖ Bet placed on **{contestant_name}**! Check your private thread: {thread.mention}"
                        )
                        
                        # Update live odds on main event message
                        await update_event_odds(event_id)
                        
                        print(f"[BETTING] {modal_interaction.user} bet {bet_amount}d on {contestant_name} in event {event_id}")
                        
                    except ValueError:
                        await modal_interaction.edit_original_response(content="‚ùå Invalid bet amount. Enter a number.")
                    except Exception as e:
                        print(f"[ERR] Bet placement failed: {e}")
                        await modal_interaction.edit_original_response(content=f"‚ùå Failed to place bet: {str(e)}")
            
            modal = BetAmountModal()
            await interaction.response.send_modal(modal)
            
        except Exception as e:
            print(f"[ERR] Contestant selection failed: {e}")
            await interaction.response.send_message(f"‚ùå Error: {str(e)}")

# Helper function to update live odds
async def update_event_odds(event_id):
    """Update live odds display on event message"""
    try:
        if not db:
            return
        
        event_doc = db.collection(BETTING_EVENTS_COLLECTION).document(event_id).get()
        if not event_doc.exists:
            return
        
        event_data = event_doc.to_dict()
        channel_id = event_data.get('channelId')
        message_id = event_data.get('messageId')
        
        if not channel_id or not message_id:
            return
        
        channel = bot.get_channel(channel_id)
        if not channel:
            return
        
        message = await channel.fetch_message(message_id)
        
        # Calculate odds
        total_pool = event_data.get('totalPool', 0.0)
        bets_per_contestant = event_data.get('betsPerContestant', {})
        contestants = event_data.get('contestants', [])
        
        # Count total bets
        all_bets = list(db.collection(BETTING_BETS_COLLECTION).where(filter=FieldFilter('eventId', '==', event_id)).stream())
        total_bets_count = len(all_bets)
        
        # Build odds text
        odds_lines = []
        for contestant in contestants:
            contestant_total = bets_per_contestant.get(contestant, 0.0)
            if total_pool > 0 and contestant_total > 0:
                multiplier = total_pool / contestant_total
                odds_lines.append(f"**{contestant}**: {multiplier:.2f}x ({contestant_total:,.0f}d)")
            else:
                odds_lines.append(f"**{contestant}**: No bets yet")
        
        odds_text = "\n".join(odds_lines)
        
        # Update embed
        embed = message.embeds[0]
        
        # Update odds field (index 2)
        embed.set_field_at(2, name="üìä Live Odds", value=odds_text, inline=False)
        
        # Update pool field (index 3)
        embed.set_field_at(3, name="üí∞ Total Pool", value=f"{total_pool:,.0f} diamonds", inline=True)
        
        # Update bets count field (index 4)
        embed.set_field_at(4, name="üìà Total Bets", value=f"{total_bets_count} bets placed", inline=True)
        
        await message.edit(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Failed to update odds: {e}")

@betting_group.command(name="declare_winner", description="üèÜ Declare event winner and payout (Admin only)")
@app_commands.describe(
    event_id="Event ID (from event footer)",
    winner="Name of winning contestant"
)
async def bet_declare_winner_cmd(interaction: discord.Interaction, event_id: str, winner: str):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can declare winners.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Clean event ID (remove backticks if user copied them)
        event_id = event_id.strip().strip('`')
        
        # Get event
        event_doc = db.collection(BETTING_EVENTS_COLLECTION).document(event_id).get()
        if not event_doc.exists:
            return await interaction.edit_original_response(content="‚ùå Event not found.")
        
        event_data = event_doc.to_dict()
        
        if event_data.get('status') == 'completed':
            return await interaction.edit_original_response(content="‚ùå Winner already declared for this event.")
        
        contestants = event_data.get('contestants', [])
        if winner not in contestants:
            return await interaction.edit_original_response(content=f"‚ùå Invalid winner. Choose from: {', '.join(contestants)}")
        
        # Close event
        db.collection(BETTING_EVENTS_COLLECTION).document(event_id).update({
            'status': 'completed',
            'winner': winner
        })
        
        # Get all bets
        all_bets = list(db.collection(BETTING_BETS_COLLECTION).where(filter=FieldFilter('eventId', '==', event_id)).stream())
        
        total_pool = event_data.get('totalPool', 0.0)
        house_cut = total_pool * 0.25  # 25% house cut
        prize_pool = total_pool - house_cut
        
        # Calculate winning bets total
        winning_total = event_data.get('betsPerContestant', {}).get(winner, 0.0)
        
        if winning_total == 0:
            # No winners - house keeps all
            await interaction.edit_original_response(content=f"üèÜ Winner declared: **{winner}**\n\n‚ùå No winning bets - house keeps the pool!")
            return
        
        # Pay winners (ONLY PAID BETS COUNT!)
        winners_list = []
        losers_list = []
        unpaid_cancelled = []
        
        for bet_doc in all_bets:
            bet_data = bet_doc.to_dict()
            bet_contestant = bet_data.get('contestant')
            bet_amount = bet_data.get('amount', 0.0)
            user_tag = bet_data.get('userTag')
            thread_id = bet_data.get('threadId')
            user_id = bet_data.get('userId')
            payment_status = bet_data.get('paymentStatus', 'unpaid')
            
            # Skip unpaid bets - they are cancelled
            if payment_status != 'paid':
                unpaid_cancelled.append({
                    'tag': user_tag,
                    'bet': bet_amount,
                    'contestant': bet_contestant,
                    'thread_id': thread_id
                })
                
                # Mark as cancelled
                db.collection(BETTING_BETS_COLLECTION).document(bet_doc.id).update({
                    'status': 'cancelled_unpaid'
                })
                
                # Notify user in thread
                if thread_id:
                    try:
                        thread = await bot.fetch_channel(thread_id)
                        cancel_embed = discord.Embed(
                            title="‚ùå BET CANCELLED - UNPAID",
                            description=f"**{event_data.get('title')}**\n\nYour bet was cancelled because you did not pay in-game.",
                            color=discord.Color.dark_red()
                        )
                        cancel_embed.set_author(name="Tom Brady")
                        cancel_embed.add_field(name="üí∞ Unpaid Amount", value=f"{bet_amount:,.0f}d", inline=True)
                        cancel_embed.add_field(name="üéØ Contestant", value=bet_contestant, inline=True)
                        cancel_embed.set_footer(text="Only PAID bets count. Pay in-game before event ends!")
                        await thread.send(embed=cancel_embed)
                    except:
                        pass
                
                continue  # Skip to next bet
            
            if bet_contestant == winner:
                # Winner!
                payout = (bet_amount / winning_total) * prize_pool
                profit = payout - bet_amount
                
                db.collection(BETTING_BETS_COLLECTION).document(bet_doc.id).update({
                    'status': 'won',
                    'payout': payout
                })
                
                winners_list.append({
                    'tag': user_tag,
                    'bet': bet_amount,
                    'payout': payout,
                    'profit': profit,
                    'thread_id': thread_id
                })
                
                # Update leaderboard
                stats_doc = get_betting_stats(user_id)
                if stats_doc:
                    stats = stats_doc.to_dict()
                    db.collection(BETTING_LEADERBOARD_COLLECTION).document(stats_doc.id).update({
                        'totalBets': stats.get('totalBets', 0) + 1,
                        'totalWagered': stats.get('totalWagered', 0.0) + bet_amount,
                        'totalWon': stats.get('totalWon', 0.0) + payout,
                        'netProfit': stats.get('netProfit', 0.0) + profit,
                        'wins': stats.get('wins', 0) + 1,
                        'winRate': ((stats.get('wins', 0) + 1) / (stats.get('totalBets', 0) + 1)) * 100,
                        'biggestWin': max(stats.get('biggestWin', 0.0), profit)
                    })
                
                # Send win notification in thread
                if thread_id:
                    try:
                        thread = await bot.fetch_channel(thread_id)
                        win_embed = discord.Embed(
                            title="üéâ YOU WON!",
                            description=f"**{event_data.get('title')}**\n\n**Winner: {winner}** üèÜ",
                            color=discord.Color.gold()
                        )
                        win_embed.set_author(name="Tom Brady")
                        win_embed.add_field(name="üí∞ Your Bet", value=f"{bet_amount:,.0f}d", inline=True)
                        win_embed.add_field(name=f"{DIAMOND_EMOJI} Payout", value=f"{payout:,.2f}d", inline=True)
                        win_embed.add_field(name="üìà Profit", value=f"+{profit:,.2f}d", inline=True)
                        win_embed.set_footer(text="Congratulations! Diamonds have been credited.")
                        await thread.send(embed=win_embed)
                    except:
                        pass
                
            else:
                # Loser
                db.collection(BETTING_BETS_COLLECTION).document(bet_doc.id).update({
                    'status': 'lost',
                    'payout': 0.0
                })
                
                losers_list.append({
                    'tag': user_tag,
                    'bet': bet_amount,
                    'thread_id': thread_id
                })
                
                # Update leaderboard
                stats_doc = get_betting_stats(user_id)
                if stats_doc:
                    stats = stats_doc.to_dict()
                    db.collection(BETTING_LEADERBOARD_COLLECTION).document(stats_doc.id).update({
                        'totalBets': stats.get('totalBets', 0) + 1,
                        'totalWagered': stats.get('totalWagered', 0.0) + bet_amount,
                        'totalLost': stats.get('totalLost', 0.0) + bet_amount,
                        'netProfit': stats.get('netProfit', 0.0) - bet_amount,
                        'losses': stats.get('losses', 0) + 1,
                        'winRate': (stats.get('wins', 0) / (stats.get('totalBets', 0) + 1)) * 100,
                        'biggestLoss': max(stats.get('biggestLoss', 0.0), bet_amount)
                    })
                
                # Send loss notification in thread
                if thread_id:
                    try:
                        thread = await bot.fetch_channel(thread_id)
                        loss_embed = discord.Embed(
                            title="‚ùå Bet Lost",
                            description=f"**{event_data.get('title')}**\n\n**Winner: {winner}**",
                            color=discord.Color.red()
                        )
                        loss_embed.set_author(name="Tom Brady")
                        loss_embed.add_field(name="üí∞ Your Bet", value=f"{bet_amount:,.0f}d", inline=True)
                        loss_embed.add_field(name="üìâ Loss", value=f"-{bet_amount:,.0f}d", inline=True)
                        loss_embed.set_footer(text="Better luck next time!")
                        await thread.send(embed=loss_embed)
                    except:
                        pass
        
        # Post results
        results_embed = discord.Embed(
            title=f"üèÜ Event Results - {event_data.get('title')}",
            description=f"**Winner: {winner}**\n\n*\"The house always knows! Congratulations to our winners!\"* - {BETTING_MASCOT_NAME}",
            color=discord.Color.gold()
        )
        results_embed.set_author(name="Tom Brady")
        
        results_embed.add_field(
            name="üí∞ Total Pool",
            value=f"{total_pool:,.0f} diamonds",
            inline=True
        )
        results_embed.add_field(
            name="üíº The House (25%)",
            value=f"{house_cut:,.2f}d",
            inline=True
        )
        results_embed.add_field(
            name=f"{DIAMOND_EMOJI} Prize Pool",
            value=f"{prize_pool:,.2f}d",
            inline=True
        )
        
        # Top 5 winners
        winners_list.sort(key=lambda x: x['profit'], reverse=True)
        if winners_list:
            winners_text = "\n".join([
                f"{w['tag']}: +{w['profit']:,.2f}d (bet {w['bet']:,.0f}d ‚Üí won {w['payout']:,.2f}d)"
                for w in winners_list[:5]
            ])
            results_embed.add_field(name=f"üéâ Winners ({len(winners_list)} total)", value=winners_text, inline=False)
        
        # Show cancelled bets info
        if unpaid_cancelled:
            results_embed.add_field(
                name=f"‚ùå Cancelled Bets ({len(unpaid_cancelled)} unpaid)",
                value=f"{len(unpaid_cancelled)} bets cancelled for non-payment",
                inline=False
            )
        
        results_embed.set_footer(text=f"Event ID: {event_id} | Check your private thread for details!")
        
        channel = interaction.channel
        await channel.send(embed=results_embed)
        
        await interaction.edit_original_response(content=
            f"‚úÖ Winner declared!\n"
            f"{DIAMOND_EMOJI} {len(winners_list)} winners (PAID bets)\n"
            f"‚ùå {len(losers_list)} losers\n"
            f"üö´ {len(unpaid_cancelled)} cancelled (unpaid)")
        print(f"[BETTING] Event {event_id} completed: {winner} won, {len(winners_list)} winners")
        
    except Exception as e:
        print(f"[ERR] Declare winner failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to declare winner: {str(e)}")

@betting_group.command(name="events", description="üìã View active betting events")
async def bet_events_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get open events
        open_events = list(db.collection(BETTING_EVENTS_COLLECTION).where(filter=FieldFilter('status', '==', 'open')).stream())
        
        if not open_events:
            return await interaction.edit_original_response(content="üìã No active betting events right now. Check back soon!")
        
        embed = discord.Embed(
            title=f"{BETTING_MASCOT_NAME}",
            description=f"**Active Betting Events**\n\n*\"Choose wisely, citizens!\"*",
            color=BETTING_COLOR
        )
        embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
        
        est_tz = EST
        
        for event_doc in open_events[:10]:  # Show top 10
            event_data = event_doc.to_dict()
            title = event_data.get('title', 'Unknown Event')
            total_pool = event_data.get('totalPool', 0.0)
            closes_at = event_data.get('closesAt')
            closes_est = closes_at.astimezone(est_tz)
            
            embed.add_field(
                name=f"üé∞ {title}",
                value=f"üí∞ Pool: {total_pool:,.0f}d | ‚è∞ Closes: {closes_est.strftime('%I:%M %p EST')}\nID: `{event_doc.id}`",
                inline=False
            )
        
        embed.set_footer(text="Use event ID with /bet_declare_winner when event concludes")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] View events failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view events: {str(e)}")

@betting_group.command(name="confirm_payment", description=f"{DIAMOND_EMOJI} Confirm in-game diamond payment (Admin only)")
@app_commands.describe(
    bet_id="Bet ID from citizen's payment instructions",
    payment_method="How they paid"
)
@app_commands.choices(payment_method=[
    app_commands.Choice(name=f"{DIAMOND_EMOJI} Direct in-game payment", value="direct"),
    app_commands.Choice(name="üè¶ Bank transfer to Sort Code HS-3112", value="bank_hs3112")
])
async def bet_confirm_payment_cmd(interaction: discord.Interaction, bet_id: str, payment_method: app_commands.Choice[str]):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can confirm payments.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get bet
        bet_doc = db.collection(BETTING_BETS_COLLECTION).document(bet_id).get()
        if not bet_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Bet ID `{bet_id}` not found.")
        
        bet_data = bet_doc.to_dict()
        
        if bet_data.get('paymentStatus') == 'paid':
            return await interaction.edit_original_response(content=f"‚úÖ This bet is already marked as PAID.")
        
        # Mark as paid with payment method
        db.collection(BETTING_BETS_COLLECTION).document(bet_id).update({
            'paymentStatus': 'paid',
            'paymentMethod': payment_method.value,
            'paidBy': interaction.user.id,
            'paidAt': datetime.now(timezone.utc)
        })
        
        # Payment method display
        payment_method_display = f"{DIAMOND_EMOJI} Direct payment" if payment_method.value == 'direct' else "üè¶ Bank transfer (HS-3112)"
        
        # Notify user in their thread
        thread_id = bet_data.get('threadId')
        if thread_id:
            try:
                thread = await interaction.guild.fetch_channel(thread_id)
                
                paid_embed = discord.Embed(
                    title="‚úÖ PAYMENT CONFIRMED!",
                    description=f"Your bet is now ACTIVE!",
                    color=discord.Color.green()
                )
                paid_embed.set_author(name="Tom Brady")
                paid_embed.add_field(
                    name=f"{DIAMOND_EMOJI} Confirmed By",
                    value=interaction.user.mention,
                    inline=True
                )
                paid_embed.add_field(
                    name="üí∞ Amount",
                    value=f"{bet_data.get('amount', 0):,.0f} diamonds",
                    inline=True
                )
                paid_embed.add_field(
                    name="üí≥ Payment Method",
                    value=payment_method_display,
                    inline=True
                )
                paid_embed.set_footer(text=f"Bet ID: {bet_id} | Status: PAID & ACTIVE")
                
                await thread.send(embed=paid_embed)
            except:
                pass
        
        await interaction.edit_original_response(content=
            f"‚úÖ Payment confirmed for Bet ID `{bet_id}`\n"
            f"**User**: {bet_data.get('userTag')}\n"
            f"**Amount**: {bet_data.get('amount', 0):,.0f} diamonds\n"
            f"**Contestant**: {bet_data.get('contestant')}\n"
            f"**Payment Method**: {payment_method_display}")
        
        print(f"[BETTING] Payment confirmed for bet {bet_id} by {interaction.user} ({payment_method_display})")
        
    except Exception as e:
        print(f"[ERR] Payment confirmation failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to confirm payment: {str(e)}")

@betting_group.command(name="payment_pending", description="üìã View all unpaid bets (Admin only)")
async def bet_payment_pending_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can view pending payments.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all unpaid bets
        unpaid_bets = list(db.collection(BETTING_BETS_COLLECTION).where(filter=FieldFilter('paymentStatus', '==', 'unpaid')).stream())
        
        if not unpaid_bets:
            return await interaction.edit_original_response(content="‚úÖ No pending payments! All bets are paid.")
        
        embed = discord.Embed(
            title=f"{DIAMOND_EMOJI} PENDING DIAMOND PAYMENTS",
            description=f"**{len(unpaid_bets)} bets awaiting in-game payment**",
            color=discord.Color.orange()
        )
        embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
        
        # Group by event
        events_dict = {}
        for bet_doc in unpaid_bets:
            bet_data = bet_doc.to_dict()
            event_id = bet_data.get('eventId')
            
            if event_id not in events_dict:
                events_dict[event_id] = []
            
            events_dict[event_id].append({
                'id': bet_doc.id,
                'user': bet_data.get('userName', 'Unknown'),
                'amount': bet_data.get('amount', 0),
                'contestant': bet_data.get('contestant', 'Unknown')
            })
        
        # Display by event
        for event_id, bets in events_dict.items():
            # Get event name
            try:
                event_doc = db.collection(BETTING_EVENTS_COLLECTION).document(event_id).get()
                event_name = event_doc.to_dict().get('title', 'Unknown Event') if event_doc.exists else 'Unknown Event'
            except:
                event_name = 'Unknown Event'
            
            bets_text = "\n".join([
                f"‚Ä¢ `{b['id'][:8]}` - {b['user']}: {b['amount']:,.0f}d on {b['contestant']}"
                for b in bets[:5]  # Show max 5 per event
            ])
            
            if len(bets) > 5:
                bets_text += f"\n... and {len(bets) - 5} more"
            
            embed.add_field(
                name=f"üìä {event_name}",
                value=bets_text,
                inline=False
            )
        
        total_owed = sum(bet_doc.to_dict().get('amount', 0) for bet_doc in unpaid_bets)
        embed.add_field(
            name="üí∞ Total Diamonds Owed",
            value=f"**{total_owed:,.0f} diamonds**",
            inline=False
        )
        
        embed.set_footer(text="Use /bet_confirm_payment <bet_id> after receiving diamonds in-game")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] View pending payments failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view pending payments: {str(e)}")

@betting_group.command(name="payout_list", description="üí∏ Generate payout list after event ends (Admin only)")
@app_commands.describe(
    event_id="Event ID to generate payout list for"
)
async def bet_payout_list_cmd(interaction: discord.Interaction, event_id: str):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can generate payout lists.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Clean event ID (remove backticks if user copied them)
        event_id = event_id.strip().strip('`')
        
        # Get event
        event_doc = db.collection(BETTING_EVENTS_COLLECTION).document(event_id).get()
        if not event_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Event ID `{event_id}` not found.")
        
        event_data = event_doc.to_dict()
        
        if event_data.get('status') != 'completed':
            return await interaction.edit_original_response(content=f"‚ùå Event must be completed first. Use /bet_declare_winner")
        
        # Get all winning bets that are PAID
        all_bets = list(db.collection(BETTING_BETS_COLLECTION).where(filter=FieldFilter('eventId', '==', event_id)).stream())
        winner = event_data.get('winner')
        
        winning_bets = [
            bet_doc for bet_doc in all_bets 
            if bet_doc.to_dict().get('contestant') == winner and bet_doc.to_dict().get('paymentStatus') == 'paid'
        ]
        
        if not winning_bets:
            return await interaction.edit_original_response(content=f"‚ùå No paid winning bets found for this event.")
        
        embed = discord.Embed(
            title=f"üí∏ PAYOUT LIST - {event_data.get('title')}",
            description=f"**Winner: {winner}**\n\nDistribute these diamonds IN-GAME:",
            color=discord.Color.gold()
        )
        embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
        
        # List all winners and payouts
        payout_list = []
        total_payout = 0
        
        for bet_doc in winning_bets:
            bet_data = bet_doc.to_dict()
            user_name = bet_data.get('userName', 'Unknown')
            payout = bet_data.get('payout', 0.0)
            
            payout_list.append({
                'user': user_name,
                'payout': payout
            })
            total_payout += payout
        
        # Sort by payout amount
        payout_list.sort(key=lambda x: x['payout'], reverse=True)
        
        payout_text = "\n".join([
            f"‚Ä¢ **{p['user']}**: {p['payout']:,.2f} diamonds"
            for p in payout_list
        ])
        
        embed.add_field(
            name=f"{DIAMOND_EMOJI} Winners to Pay ({len(payout_list)} people)",
            value=payout_text,
            inline=False
        )
        
        embed.add_field(
            name="üí∞ Total to Distribute",
            value=f"**{total_payout:,.2f} diamonds**",
            inline=True
        )
        
        embed.set_footer(text="Go in-game and distribute these diamonds to winners")
        
        await interaction.edit_original_response(embed=embed)
        
        print(f"[BETTING] Payout list generated for event {event_id} by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Payout list failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to generate payout list: {str(e)}")

@betting_group.command(name="leaderboard", description="üèÜ View betting leaderboard")
async def bet_leaderboard_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all stats, sorted by net profit
        all_stats = list(db.collection(BETTING_LEADERBOARD_COLLECTION).stream())
        
        if not all_stats:
            return await interaction.edit_original_response(content="üèÜ No betting activity yet. Be the first to place a bet!")
        
        # Sort by net profit
        sorted_stats = sorted(all_stats, key=lambda x: x.to_dict().get('netProfit', 0.0), reverse=True)
        
        embed = discord.Embed(
            title=f"üèÜ Betting Champions",
            description=f"*\"The bold and the lucky!\"* - {BETTING_MASCOT_NAME}",
            color=BETTING_COLOR
        )
        embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
        
        # Top 10
        for i, stat_doc in enumerate(sorted_stats[:10], 1):
            stats = stat_doc.to_dict()
            user_id = stats.get('userId')
            
            try:
                user = await bot.fetch_user(user_id)
                user_name = user.mention
            except:
                user_name = f"<@{user_id}>"
            
            net_profit = stats.get('netProfit', 0.0)
            win_rate = stats.get('winRate', 0.0)
            total_bets = stats.get('totalBets', 0)
            biggest_win = stats.get('biggestWin', 0.0)
            
            medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"#{i}"
            
            embed.add_field(
                name=f"{medal} {user_name}",
                value=f"{DIAMOND_EMOJI} Profit: **{net_profit:+,.2f}d** | üìä Win Rate: {win_rate:.1f}% ({total_bets} bets)\nüèÜ Biggest Win: {biggest_win:,.2f}d",
                inline=False
            )
        
        embed.set_footer(text="Place bets to climb the leaderboard!")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Leaderboard failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view leaderboard: {str(e)}")

@betting_group.command(name="my_bets", description="üìä View your betting history and stats")
async def my_bets_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get user stats
        stats_doc = get_betting_stats(interaction.user.id)
        
        if not stats_doc:
            return await interaction.edit_original_response(content="üìä You haven't placed any bets yet! Use /bet_events to get started.")
        
        stats = stats_doc.to_dict()
        
        embed = discord.Embed(
            title=f"üìä Your Betting Stats",
            description=f"**{interaction.user.display_name}**",
            color=BETTING_COLOR
        )
        embed.set_author(name="Tom Brady", icon_url=BETTING_MASCOT_AVATAR)
        
        # Overall stats
        embed.add_field(
            name="üí∞ Net Profit",
            value=f"{stats.get('netProfit', 0.0):+,.2f}d",
            inline=True
        )
        embed.add_field(
            name="üìà Win Rate",
            value=f"{stats.get('winRate', 0.0):.1f}%",
            inline=True
        )
        embed.add_field(
            name="üé≤ Total Bets",
            value=f"{stats.get('totalBets', 0)} bets",
            inline=True
        )
        
        embed.add_field(
            name="‚úÖ Wins",
            value=f"{stats.get('wins', 0)}",
            inline=True
        )
        embed.add_field(
            name="‚ùå Losses",
            value=f"{stats.get('losses', 0)}",
            inline=True
        )
        embed.add_field(
            name=f"{DIAMOND_EMOJI} Total Wagered",
            value=f"{stats.get('totalWagered', 0.0):,.2f}d",
            inline=True
        )
        
        embed.add_field(
            name="üèÜ Biggest Win",
            value=f"+{stats.get('biggestWin', 0.0):,.2f}d",
            inline=True
        )
        embed.add_field(
            name="üíÄ Biggest Loss",
            value=f"-{stats.get('biggestLoss', 0.0):,.2f}d",
            inline=True
        )
        
        # Get recent bets
        recent_bets = list(db.collection(BETTING_BETS_COLLECTION).where(filter=FieldFilter('userId', '==', interaction.user.id)).limit(5).stream())
        
        if recent_bets:
            recent_text = []
            for bet_doc in recent_bets:
                bet_data = bet_doc.to_dict()
                status = bet_data.get('status', 'pending')
                amount = bet_data.get('amount', 0.0)
                contestant = bet_data.get('contestant', 'Unknown')
                
                status_emoji = "‚è≥" if status == 'pending' else "‚úÖ" if status == 'won' else "‚ùå"
                recent_text.append(f"{status_emoji} {contestant}: {amount:,.0f}d ({status})")
            
            embed.add_field(
                name="üìã Recent Bets",
                value="\n".join(recent_text),
                inline=False
            )
        
        embed.set_footer(text="Keep betting to improve your stats!")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] My bets failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to view stats: {str(e)}")

@betting_group.command(name="clear_all", description="üßπ Remove all live betting events (Admin only - for testing)")
async def bet_clear_all_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Processing...", ephemeral=True)
    
    if not has_admin_role(interaction):
        return await interaction.edit_original_response(content="‚ùå Only administrators can clear all events.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all pending and open betting events
        all_events = list(db.collection(BETTING_EVENTS_COLLECTION).stream())
        events_to_delete = [e for e in all_events if e.to_dict().get('status') in ['pending', 'open']]
        
        if not events_to_delete:
            return await interaction.edit_original_response(content="üìã No pending or open betting events to clear.")
        
        # Delete all pending/open events and their bets
        deleted_events = 0
        deleted_bets = 0
        
        for event_doc in events_to_delete:
            event_id = event_doc.id
            event_data = event_doc.to_dict()
            
            # Delete all bets for this event
            bets = list(db.collection(BETTING_BETS_COLLECTION).where(filter=FieldFilter('eventId', '==', event_id)).stream())
            for bet_doc in bets:
                bet_doc.reference.delete()
                deleted_bets += 1
            
            # Delete the event
            event_doc.reference.delete()
            deleted_events += 1
            
            print(f"[BETTING] Admin cleared event {event_id}: {event_data.get('title')}")
        
        embed = discord.Embed(
            title="üßπ Betting Events Cleared",
            description=f"‚úÖ Successfully removed **{deleted_events}** live events and **{deleted_bets}** pending bets.",
            color=discord.Color.orange()
        )
        embed.set_footer(text="All betting data removed for testing purposes")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Clear all failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to clear events: {str(e)}")

# ==================================================
# BANK SYSTEM - COMMANDS
# ==================================================

class ViewBankingGraphButton(ui.Button):
    """Button to view banking deposits graph on demand"""
    def __init__(self):
        super().__init__(
            label="View Banking Graph",
            style=discord.ButtonStyle.secondary,
            emoji="üìä",
            custom_id="view_banking_graph"
        )
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("üìä Generating banking deposits graph...", ephemeral=True)
        
        try:
            graph_buffer = generate_banking_deposits_graph()
            
            if graph_buffer:
                now_est = datetime.now(timezone.utc).astimezone(EST)
                
                embed = discord.Embed(
                    title="üìä FLORAB√çS BANKING DEPOSITS TREND",
                    description=f"*Historical Banking System Growth*",
                    color=0x003d5c
                )
                embed.set_footer(text=f"Updated: {now_est.strftime('%b %d, %Y at %I:%M %p EST')} | All-time deposit history")
                
                file = discord.File(graph_buffer, filename="bank_deposits.png")
                embed.set_image(url="attachment://bank_deposits.png")
                await interaction.edit_original_response(content=None, embed=embed, attachments=[file])
            else:
                await interaction.edit_original_response(content="üìã **No Banking Data Available**\n\nThe banking graph will appear once deposit activity begins.")
        except Exception as e:
            print(f"[ERR] Failed to generate banking graph: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to generate graph: {str(e)}")

@bank_group.command(name="dashboard", description="üè¶ View your bank account dashboard")
async def bank_dashboard_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Banking is now open to foreigners (non-citizens) for international trade
    
    try:
        # Get or create account
        account = get_or_create_bank_account(interaction.user.id)
        if not account or not account.exists:
            return await interaction.edit_original_response(content="‚ùå Could not access your bank account.")
        
        account_data = account.to_dict()
        account_number = account_data.get('accountNumber', 'Unknown')
        diamond_balance = account_data.get('diamondBalance', account_data.get('balance', 0.0))
        essence_balance = account_data.get('essenceBalance', 0.0)
        iron_balance = account_data.get('ironBalance', 0.0)
        gold_balance = account_data.get('goldBalance', 0.0)
        emerald_balance = account_data.get('emeraldBalance', 0.0)
        
        # Get market prices
        essence_price = get_market_price('essence')
        iron_price = get_market_price('iron')
        gold_price = get_market_price('gold')
        emerald_price = get_market_price('emerald')
        
        # Calculate total portfolio value
        total_value = diamond_balance + (essence_balance * essence_price) + (iron_balance * iron_price) + (gold_balance * gold_price) + (emerald_balance * emerald_price)
        
        # Get recent transactions (fetch all, then sort in Python to avoid index requirements)
        all_transactions = list(db.collection(BANK_TRANSACTIONS_COLLECTION).where(
            filter=FieldFilter('userId', '==', interaction.user.id)
        ).stream())
        
        # Sort by timestamp in Python (most recent first)
        all_transactions.sort(key=lambda x: x.to_dict().get('timestamp', datetime.min), reverse=True)
        transactions = all_transactions[:5]  # Get top 5
        
        # Build dashboard embed with clean UI
        embed = discord.Embed(
            title="üè¶ FLORAB√çS FINANCIAL CENTER",
            description=f"**Account #** `{account_number}`",
            color=0x003d5c  # Keep original bank color
        )
        
        # Commodity Balances - Clean format with abbreviations
        embed.add_field(
            name="üí∞ ACCOUNT BALANCES",
            value=(
                f"**{DIAMOND_EMOJI} {diamond_balance:,.2f} d** (~{diamond_balance:,.2f}d)\n"
                f"**{ESSENCE_EMOJI} {essence_balance:,.0f} es** (~{essence_balance * essence_price:,.2f}d)\n"
                f"**{IRON_EMOJI} {iron_balance:,.0f} i** (~{iron_balance * iron_price:,.2f}d)\n"
                f"**{GOLD_EMOJI} {gold_balance:,.0f} gld** (~{gold_balance * gold_price:,.2f}d)\n"
                f"**{EMERALD_EMOJI} {emerald_balance:,.0f} em** (~{emerald_balance * emerald_price:,.2f}d)\n\n"
                f"**{DIAMOND_EMOJI} Portfolio Value:** {total_value:,.2f}d"
            ),
            inline=False
        )
        
        # Recent activity
        if transactions:
            activity_text = ""
            for trans in transactions:
                trans_data = trans.to_dict()
                trans_type = trans_data.get('type', 'unknown')
                amount = trans_data.get('amount', 0)
                memo = trans_data.get('memo', '')
                commodity = trans_data.get('commodity', 'diamond')
                
                # Commodity emoji mapping
                commodity_emoji_map = {
                    'diamond': 'd',
                    'essence': ESSENCE_EMOJI,
                    'iron': IRON_EMOJI,
                    'gold': GOLD_EMOJI,
                    'emerald': EMERALD_EMOJI
                }
                commodity_display = commodity_emoji_map.get(commodity, 'd')
                
                # Icon based on type
                icon = {
                    'deposit': '‚úÖ',
                    'withdrawal': 'üí∏',
                    'transfer_in': '‚û°Ô∏è',
                    'transfer_out': '‚¨ÖÔ∏è',
                    'bet': 'üé∞',
                    'stock_buy': 'üìà',
                    'stock_sell': 'üí∞',
                    'dividend': 'üíµ'
                }.get(trans_type, 'üìù')
                
                activity_text += f"{icon} {trans_type.replace('_', ' ').title()}: {'+' if amount > 0 else ''}{amount:,.2f}{commodity_display}"
                if memo:
                    activity_text += f" ({memo})"
                activity_text += "\n"
            
            embed.add_field(name="üìä Recent Activity", value=activity_text or "No transactions yet", inline=False)
        else:
            embed.add_field(name="üìä Recent Activity", value="No transactions yet", inline=False)
        
        # Footer - graphs are optional, view via button
        embed.set_footer(text="Use /bank commands to manage your account | Click 'View Banking Graph' to see deposit trends")
        
        # Add View Graph button
        view = ui.View()
        view.add_item(ViewBankingGraphButton())
        await interaction.edit_original_response(content=None, embed=embed, view=view)
        
    except Exception as e:
        print(f"[ERR] Bank dashboard failed: {e}")
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to load dashboard: {str(e)}")

@bank_group.command(name="deposit", description="üí∞ Admin deposits diamonds to citizen's bank account")
@app_commands.describe(
    citizen="The citizen to deposit to",
    amount="Amount of diamonds to deposit",
    memo="Optional note for the transaction"
)
async def bank_deposit_cmd(interaction: discord.Interaction, citizen: discord.Member, amount: float, memo: str = "Admin deposit"):
    await interaction.response.send_message("‚è≥ Processing deposit...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can deposit funds.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if not is_citizen(citizen.id):
        return await interaction.edit_original_response(content=f"‚ùå {citizen.mention} is not a Florab√≠s citizen.")
    
    if amount <= 0:
        return await interaction.edit_original_response(content="‚ùå Amount must be positive.")
    
    try:
        # Get or create account
        account = get_or_create_bank_account(citizen.id)
        if not account or not account.exists:
            return await interaction.edit_original_response(content=f"‚ùå Could not access bank account for {citizen.mention}.")
        
        account_data = account.to_dict()
        old_balance = account_data.get('balance', 0.0)
        new_balance = old_balance + amount
        
        # Update balance
        account.reference.update({'balance': new_balance})
        
        # Record transaction
        _, trans_ref = db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': citizen.id,
            'userTag': citizen.mention,
            'type': 'deposit',
            'amount': amount,
            'balanceBefore': old_balance,
            'balanceAfter': new_balance,
            'memo': memo,
            'processedBy': interaction.user.id,
            'processedByTag': interaction.user.mention,
            'timestamp': datetime.now(timezone.utc)
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Deposited {amount:,.2f}d** to {citizen.mention}'s bank account\n"
            f"üí∞ New balance: **{new_balance:,.2f}d**\n"
            f"üìù Memo: {memo}"
        )
        
        print(f"[BANK] {interaction.user} deposited {amount:.2f}d to {citizen}'s account (new balance: {new_balance:.2f}d)")
        
    except Exception as e:
        print(f"[ERR] Bank deposit failed: {e}")
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to deposit: {str(e)}")

@bank_group.command(name="withdraw", description="üí∏ Admin withdraws diamonds from citizen's bank account")
@app_commands.describe(
    citizen="The citizen to withdraw from",
    amount="Amount of diamonds to withdraw",
    memo="Optional note for the transaction"
)
async def bank_withdraw_cmd(interaction: discord.Interaction, citizen: discord.Member, amount: float, memo: str = "Admin withdrawal"):
    await interaction.response.send_message("‚è≥ Processing withdrawal...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can withdraw funds.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if not is_citizen(citizen.id):
        return await interaction.edit_original_response(content=f"‚ùå {citizen.mention} is not a Florab√≠s citizen.")
    
    if amount <= 0:
        return await interaction.edit_original_response(content="‚ùå Amount must be positive.")
    
    try:
        # Get account
        account = get_or_create_bank_account(citizen.id)
        if not account or not account.exists:
            return await interaction.edit_original_response(content=f"‚ùå Could not access bank account for {citizen.mention}.")
        
        account_data = account.to_dict()
        old_balance = account_data.get('balance', 0.0)
        
        if old_balance < amount:
            return await interaction.edit_original_response(content=
                f"‚ùå Insufficient funds. {citizen.mention} has **{old_balance:,.2f}d** but you're trying to withdraw **{amount:,.2f}d**."
            )
        
        new_balance = old_balance - amount
        
        # Update balance
        account.reference.update({'balance': new_balance})
        
        # Record transaction
        _, trans_ref = db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': citizen.id,
            'userTag': citizen.mention,
            'type': 'withdrawal',
            'amount': -amount,
            'balanceBefore': old_balance,
            'balanceAfter': new_balance,
            'memo': memo,
            'processedBy': interaction.user.id,
            'processedByTag': interaction.user.mention,
            'timestamp': datetime.now(timezone.utc)
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Withdrew {amount:,.2f}d** from {citizen.mention}'s bank account\n"
            f"üí∞ New balance: **{new_balance:,.2f}d**\n"
            f"üìù Memo: {memo}"
        )
        
        print(f"[BANK] {interaction.user} withdrew {amount:.2f}d from {citizen}'s account (new balance: {new_balance:.2f}d)")
        
    except Exception as e:
        print(f"[ERR] Bank withdrawal failed: {e}")
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to withdraw: {str(e)}")

@bank_group.command(name="transfer", description="üí∏ Transfer diamonds to another citizen's bank account")
@app_commands.describe(
    recipient="The citizen to transfer to",
    amount="Amount of diamonds to transfer",
    memo="Optional note for the transfer"
)
async def bank_transfer_cmd(interaction: discord.Interaction, recipient: discord.Member, amount: float, memo: str = "Transfer"):
    await interaction.response.send_message("‚è≥ Processing transfer...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Banking is now open to foreigners (non-citizens) for international trade
    
    if recipient.id == interaction.user.id:
        return await interaction.edit_original_response(content="‚ùå You cannot transfer to yourself.")
    
    if amount <= 0:
        return await interaction.edit_original_response(content="‚ùå Amount must be positive.")
    
    try:
        # Get sender account
        sender_account = get_or_create_bank_account(interaction.user.id)
        if not sender_account or not sender_account.exists:
            return await interaction.edit_original_response(content="‚ùå Could not access your bank account.")
        
        sender_data = sender_account.to_dict()
        sender_balance = sender_data.get('balance', 0.0)
        
        if sender_balance < amount:
            return await interaction.edit_original_response(content=
                f"‚ùå Insufficient funds. You have **{sender_balance:,.2f}d** but need **{amount:,.2f}d**."
            )
        
        # Get recipient account
        recipient_account = get_or_create_bank_account(recipient.id)
        if not recipient_account or not recipient_account.exists:
            return await interaction.edit_original_response(content=f"‚ùå Could not access {recipient.mention}'s bank account.")
        
        recipient_data = recipient_account.to_dict()
        recipient_balance = recipient_data.get('balance', 0.0)
        
        # Execute transfer
        new_sender_balance = sender_balance - amount
        new_recipient_balance = recipient_balance + amount
        
        sender_account.reference.update({'balance': new_sender_balance})
        recipient_account.reference.update({'balance': new_recipient_balance})
        
        # Record sender transaction
        _, trans_ref = db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': interaction.user.id,
            'userTag': interaction.user.mention,
            'type': 'transfer_out',
            'amount': -amount,
            'balanceBefore': sender_balance,
            'balanceAfter': new_sender_balance,
            'memo': f"Transfer to {recipient.name}: {memo}",
            'relatedUserId': recipient.id,
            'timestamp': datetime.now(timezone.utc)
        })
        
        # Record recipient transaction
        _, trans_ref2 = db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': recipient.id,
            'userTag': recipient.mention,
            'type': 'transfer_in',
            'amount': amount,
            'balanceBefore': recipient_balance,
            'balanceAfter': new_recipient_balance,
            'memo': f"Transfer from {interaction.user.name}: {memo}",
            'relatedUserId': interaction.user.id,
            'timestamp': datetime.now(timezone.utc)
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Transferred {amount:,.2f}d** to {recipient.mention}\n"
            f"üí∞ Your new balance: **{new_sender_balance:,.2f}d**\n"
            f"üìù {memo}"
        )
        
        print(f"[BANK] {interaction.user} transferred {amount:.2f}d to {recipient} (sender: {new_sender_balance:.2f}d, recipient: {new_recipient_balance:.2f}d)")
        
    except Exception as e:
        print(f"[ERR] Bank transfer failed: {e}")
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to transfer: {str(e)}")

@bank_group.command(name="deposit_commodity", description=f"{ESSENCE_EMOJI} Admin deposits commodities to account")
@app_commands.describe(
    citizen="The user to deposit to (citizen or foreigner)",
    commodity="Type of commodity",
    amount="Amount to deposit",
    memo="Optional note"
)
@app_commands.choices(commodity=[
    app_commands.Choice(name=f"{ESSENCE_EMOJI} Essence", value="essence"),
    app_commands.Choice(name=f"{IRON_EMOJI} Iron (ingots)", value="iron"),
    app_commands.Choice(name=f"{GOLD_EMOJI} Gold (ingots)", value="gold"),
    app_commands.Choice(name=f"{EMERALD_EMOJI} Emerald (units)", value="emerald"),
    app_commands.Choice(name=f"{IRON_BLOCK_EMOJI} Iron Blocks", value="iron_block"),
    app_commands.Choice(name=f"{GOLD_BLOCK_EMOJI} Gold Blocks", value="gold_block"),
    app_commands.Choice(name=f"{EMERALD_BLOCK_EMOJI} Emerald Blocks", value="emerald_block")
])
async def deposit_commodity_cmd(interaction: discord.Interaction, citizen: discord.Member, commodity: str, amount: float, memo: str = "Admin deposit"):
    await interaction.response.send_message("‚è≥ Processing commodity deposit...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can deposit commodities.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if not is_citizen(citizen.id):
        return await interaction.edit_original_response(content=f"‚ùå {citizen.mention} is not a Florab√≠s citizen.")
    
    if amount <= 0:
        return await interaction.edit_original_response(content="‚ùå Amount must be positive.")
    
    try:
        # Map commodity to emoji
        emoji_map = {
            'essence': ESSENCE_EMOJI,
            'iron': IRON_EMOJI,
            'gold': GOLD_EMOJI,
            'emerald': EMERALD_EMOJI,
            'iron_block': IRON_BLOCK_EMOJI,
            'gold_block': GOLD_BLOCK_EMOJI,
            'emerald_block': EMERALD_BLOCK_EMOJI
        }
        commodity_emoji = emoji_map.get(commodity, DIAMOND_EMOJI)
        
        success = update_commodity_balance(citizen.id, commodity, amount, 'deposit', memo)
        
        if success:
            new_balance = get_commodity_balance(citizen.id, commodity)
            await interaction.edit_original_response(content=
                f"‚úÖ **Deposited {amount:,.0f} {commodity_emoji} {commodity}** to {citizen.mention}'s account\n"
                f"üí∞ New {commodity} balance: **{new_balance:,.0f}**\n"
                f"üìù Memo: {memo}"
            )
            print(f"[BANK] {interaction.user} deposited {amount} {commodity} to {citizen}'s account")
        else:
            await interaction.edit_original_response(content="‚ùå Failed to deposit commodity.")
        
    except Exception as e:
        print(f"[ERR] Commodity deposit failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to deposit: {str(e)}")

@bank_group.command(name="withdraw_commodity", description=f"{ESSENCE_EMOJI} Admin withdraws commodities from account")
@app_commands.describe(
    citizen="The user to withdraw from (citizen or foreigner)",
    commodity="Type of commodity",
    amount="Amount to withdraw",
    memo="Optional note"
)
@app_commands.choices(commodity=[
    app_commands.Choice(name=f"{ESSENCE_EMOJI} Essence", value="essence"),
    app_commands.Choice(name=f"{IRON_EMOJI} Iron (ingots)", value="iron"),
    app_commands.Choice(name=f"{GOLD_EMOJI} Gold (ingots)", value="gold"),
    app_commands.Choice(name=f"{EMERALD_EMOJI} Emerald (units)", value="emerald"),
    app_commands.Choice(name=f"{IRON_BLOCK_EMOJI} Iron Blocks", value="iron_block"),
    app_commands.Choice(name=f"{GOLD_BLOCK_EMOJI} Gold Blocks", value="gold_block"),
    app_commands.Choice(name=f"{EMERALD_BLOCK_EMOJI} Emerald Blocks", value="emerald_block")
])
async def withdraw_commodity_cmd(interaction: discord.Interaction, citizen: discord.Member, commodity: str, amount: float, memo: str = "Admin withdrawal"):
    await interaction.response.send_message("‚è≥ Processing commodity withdrawal...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can withdraw commodities.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if not is_citizen(citizen.id):
        return await interaction.edit_original_response(content=f"‚ùå {citizen.mention} is not a Florab√≠s citizen.")
    
    if amount <= 0:
        return await interaction.edit_original_response(content="‚ùå Amount must be positive.")
    
    try:
        # Map commodity to emoji
        emoji_map = {
            'essence': ESSENCE_EMOJI,
            'iron': IRON_EMOJI,
            'gold': GOLD_EMOJI,
            'emerald': EMERALD_EMOJI,
            'iron_block': IRON_BLOCK_EMOJI,
            'gold_block': GOLD_BLOCK_EMOJI,
            'emerald_block': EMERALD_BLOCK_EMOJI
        }
        commodity_emoji = emoji_map.get(commodity, DIAMOND_EMOJI)
        
        current_balance = get_commodity_balance(citizen.id, commodity)
        
        if current_balance < amount:
            return await interaction.edit_original_response(content=
                f"‚ùå Insufficient {commodity}. {citizen.mention} has **{current_balance:,.0f} {commodity_emoji}** but you're trying to withdraw **{amount:,.0f}**."
            )
        
        success = update_commodity_balance(citizen.id, commodity, -amount, 'withdrawal', memo)
        
        if success:
            new_balance = get_commodity_balance(citizen.id, commodity)
            await interaction.edit_original_response(content=
                f"‚úÖ **Withdrew {amount:,.0f} {commodity_emoji} {commodity}** from {citizen.mention}'s account\n"
                f"üí∞ New {commodity} balance: **{new_balance:,.0f}**\n"
                f"üìù Memo: {memo}"
            )
            print(f"[BANK] {interaction.user} withdrew {amount} {commodity} from {citizen}'s account")
        else:
            await interaction.edit_original_response(content="‚ùå Failed to withdraw commodity.")
        
    except Exception as e:
        print(f"[ERR] Commodity withdrawal failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to withdraw: {str(e)}")

@bank_group.command(name="balance", description="üí∞ Check a citizen's bank balance (Admin only)")
@app_commands.describe(citizen="The citizen to check")
async def bank_balance_cmd(interaction: discord.Interaction, citizen: discord.Member):
    await interaction.response.send_message("‚è≥ Checking balance...", ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can check balances.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if not is_citizen(citizen.id):
        return await interaction.edit_original_response(content=f"‚ùå {citizen.mention} is not a Florab√≠s citizen.")
    
    try:
        account = get_or_create_bank_account(citizen.id)
        if not account or not account.exists:
            return await interaction.edit_original_response(content=f"‚ùå Could not access bank account for {citizen.mention}.")
        
        account_data = account.to_dict()
        account_number = account_data.get('accountNumber', 'Unknown')
        diamond_balance = account_data.get('diamondBalance', account_data.get('balance', 0.0))
        essence_balance = account_data.get('essenceBalance', 0.0)
        iron_balance = account_data.get('ironBalance', 0.0)
        gold_balance = account_data.get('goldBalance', 0.0)
        emerald_balance = account_data.get('emeraldBalance', 0.0)
        iron_block_balance = account_data.get('ironBlockBalance', 0.0)
        gold_block_balance = account_data.get('goldBlockBalance', 0.0)
        emerald_block_balance = account_data.get('emeraldBlockBalance', 0.0)
        
        # Get market prices for calculations
        essence_price = get_market_price('essence')
        iron_price = get_market_price('iron')
        gold_price = get_market_price('gold')
        emerald_price = get_market_price('emerald')
        iron_block_price = get_market_price('iron_block')
        gold_block_price = get_market_price('gold_block')
        emerald_block_price = get_market_price('emerald_block')
        
        # Get market rates for display
        diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread = get_market_rate('diamond')
        essence_rate, essence_unit, essence_buy, essence_sell, essence_spread = get_market_rate('essence')
        iron_rate, iron_unit, iron_buy, iron_sell, iron_spread = get_market_rate('iron')
        gold_rate, gold_unit, gold_buy, gold_sell, gold_spread = get_market_rate('gold')
        emerald_rate, emerald_unit, emerald_buy, emerald_sell, emerald_spread = get_market_rate('emerald')
        iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, iron_block_spread = get_market_rate('iron_block')
        gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, gold_block_spread = get_market_rate('gold_block')
        emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, emerald_block_spread = get_market_rate('emerald_block')
        
        # Calculate total value
        total_value = (diamond_balance + 
                      (essence_balance * essence_price) + 
                      (iron_balance * iron_price) + 
                      (gold_balance * gold_price) + 
                      (emerald_balance * emerald_price) +
                      (iron_block_balance * iron_block_price) +
                      (gold_block_balance * gold_block_price) +
                      (emerald_block_balance * emerald_block_price))
        
        await interaction.edit_original_response(content=
            f"üè¶ **{citizen.display_name}**\n"
            f"**Account:** `{account_number}`\n\n"
            f"**üí∞ Commodity Balances:**\n"
            f"{DIAMOND_EMOJI} Diamonds: **{diamond_balance:,.2f}d**\n"
            f"{ESSENCE_EMOJI} Essence: **{essence_balance:,.0f}** essence (~{essence_balance * essence_price:,.2f}d)\n"
            f"{IRON_EMOJI} Iron: **{iron_balance:,.0f}** ingots (~{iron_balance * iron_price:,.2f}d)\n"
            f"{GOLD_EMOJI} Gold: **{gold_balance:,.0f}** ingots (~{gold_balance * gold_price:,.2f}d)\n"
            f"{EMERALD_EMOJI} Emerald: **{emerald_balance:,.0f}** emerald (~{emerald_balance * emerald_price:,.2f}d)\n"
            f"{IRON_BLOCK_EMOJI} Iron Blocks: **{iron_block_balance:,.0f}** (~{iron_block_balance * iron_block_price:,.2f}d)\n"
            f"{GOLD_BLOCK_EMOJI} Gold Blocks: **{gold_block_balance:,.0f}** (~{gold_block_balance * gold_block_price:,.2f}d)\n"
            f"{EMERALD_BLOCK_EMOJI} Emerald Blocks: **{emerald_block_balance:,.0f}** (~{emerald_block_balance * emerald_block_price:,.2f}d)\n\n"
            f"üìä **Total Value:** {DIAMOND_EMOJI} **{total_value:,.2f}d**"
        )
        
    except Exception as e:
        print(f"[ERR] Bank balance check failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to check balance: {str(e)}")

@bank_group.command(name="view_user", description="üîç [ADMIN] View any user's full banking dashboard")
@app_commands.describe(user="The user whose banking info you want to view")
async def bank_view_user_cmd(interaction: discord.Interaction, user: discord.Member):
    await interaction.response.defer(ephemeral=True)
    
    if not interaction.user.guild_permissions.administrator:
        return await interaction.edit_original_response(content="‚ùå Only administrators can view other users' banking info.")
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get user's bank account
        account = get_or_create_bank_account(user.id)
        if not account or not account.exists:
            return await interaction.edit_original_response(content=f"‚ùå Could not access bank account for {user.mention}.")
        
        account_data = account.to_dict()
        account_number = account_data.get('accountNumber', 'Unknown')
        diamond_balance = account_data.get('diamondBalance', account_data.get('balance', 0.0))
        essence_balance = account_data.get('essenceBalance', 0.0)
        iron_balance = account_data.get('ironBalance', 0.0)
        gold_balance = account_data.get('goldBalance', 0.0)
        emerald_balance = account_data.get('emeraldBalance', 0.0)
        iron_block_balance = account_data.get('ironBlockBalance', 0.0)
        gold_block_balance = account_data.get('goldBlockBalance', 0.0)
        emerald_block_balance = account_data.get('emeraldBlockBalance', 0.0)
        
        # Get market prices for calculations
        essence_price = get_market_price('essence')
        iron_price = get_market_price('iron')
        gold_price = get_market_price('gold')
        emerald_price = get_market_price('emerald')
        iron_block_price = get_market_price('iron_block')
        gold_block_price = get_market_price('gold_block')
        emerald_block_price = get_market_price('emerald_block')
        
        # Get market rates for display
        diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread = get_market_rate('diamond')
        essence_rate, essence_unit, essence_buy, essence_sell, essence_spread = get_market_rate('essence')
        iron_rate, iron_unit, iron_buy, iron_sell, iron_spread = get_market_rate('iron')
        gold_rate, gold_unit, gold_buy, gold_sell, gold_spread = get_market_rate('gold')
        emerald_rate, emerald_unit, emerald_buy, emerald_sell, emerald_spread = get_market_rate('emerald')
        iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, iron_block_spread = get_market_rate('iron_block')
        gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, gold_block_spread = get_market_rate('gold_block')
        emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, emerald_block_spread = get_market_rate('emerald_block')
        
        # Calculate total value
        total_value = (diamond_balance + 
                      (essence_balance * essence_price) + 
                      (iron_balance * iron_price) + 
                      (gold_balance * gold_price) + 
                      (emerald_balance * emerald_price) +
                      (iron_block_balance * iron_block_price) +
                      (gold_block_balance * gold_block_price) +
                      (emerald_block_balance * emerald_block_price))
        
        # Get recent transactions
        recent_txs = list(
            db.collection(BANK_TRANSACTIONS_COLLECTION)
            .where(filter=FieldFilter('userId', '==', user.id))
            .order_by('timestamp', direction='DESCENDING')
            .limit(5)
            .stream()
        )
        
        # Build transaction history
        tx_text = ""
        if recent_txs:
            for tx_doc in recent_txs:
                tx = tx_doc.to_dict()
                tx_type = tx.get('type', 'unknown')
                amount = tx.get('amount', 0)
                commodity = tx.get('commodity', 'diamond')
                memo = tx.get('memo', 'No memo')
                timestamp = tx.get('timestamp')
                
                emoji_map = {
                    'diamond': DIAMOND_EMOJI,
                    'essence': ESSENCE_EMOJI,
                    'iron': IRON_EMOJI,
                    'gold': GOLD_EMOJI,
                    'emerald': EMERALD_EMOJI,
                    'iron_block': IRON_BLOCK_EMOJI,
                    'gold_block': GOLD_BLOCK_EMOJI,
                    'emerald_block': EMERALD_BLOCK_EMOJI
                }
                
                emoji = emoji_map.get(commodity, DIAMOND_EMOJI)
                sign = '+' if tx_type in ['deposit', 'transfer_in'] else '-'
                
                if timestamp:
                    est_time = timestamp.astimezone(EST)
                    time_str = est_time.strftime('%b %d, %I:%M %p')
                else:
                    time_str = 'Unknown'
                
                tx_text += f"\n‚ñ∏ {sign}{amount:,.2f}{emoji} - {memo} ({time_str})"
        else:
            tx_text = "\nNo recent transactions"
        
        # Send detailed dashboard as private message
        await interaction.edit_original_response(content=
            f"üè¶ **BANKING DASHBOARD - {user.display_name}** (Admin View)\n"
            f"**Account:** `{account_number}`\n\n"
            f"**üí∞ COMMODITY BALANCES:**\n"
            f"{DIAMOND_EMOJI} Diamonds: **{diamond_balance:,.2f}d**\n"
            f"{ESSENCE_EMOJI} Essence: **{essence_balance:,.0f}** essence (~{essence_balance * essence_price:,.2f}d)\n"
            f"{IRON_EMOJI} Iron: **{iron_balance:,.0f}** ingots (~{iron_balance * iron_price:,.2f}d)\n"
            f"{GOLD_EMOJI} Gold: **{gold_balance:,.0f}** ingots (~{gold_balance * gold_price:,.2f}d)\n"
            f"{EMERALD_EMOJI} Emerald: **{emerald_balance:,.0f}** emerald (~{emerald_balance * emerald_price:,.2f}d)\n"
            f"{IRON_BLOCK_EMOJI} Iron Blocks: **{iron_block_balance:,.0f}** (~{iron_block_balance * iron_block_price:,.2f}d)\n"
            f"{GOLD_BLOCK_EMOJI} Gold Blocks: **{gold_block_balance:,.0f}** (~{gold_block_balance * gold_block_price:,.2f}d)\n"
            f"{EMERALD_BLOCK_EMOJI} Emerald Blocks: **{emerald_block_balance:,.0f}** (~{emerald_block_balance * emerald_block_price:,.2f}d)\n\n"
            f"üìä **Total Portfolio Value:** {DIAMOND_EMOJI} **{total_value:,.2f}d**\n\n"
            f"**üìú RECENT TRANSACTIONS (Last 5):**{tx_text}\n\n"
            f"**üìà LIVE MARKET RATES:**\n"
            f"{ESSENCE_EMOJI} {essence_rate:.2f}{essence_unit} | "
            f"{IRON_EMOJI} {iron_rate:.2f}{iron_unit} | "
            f"{GOLD_EMOJI} {gold_rate:.1f}{gold_unit} | "
            f"{EMERALD_EMOJI} {emerald_rate:.2f}{emerald_unit}\n"
            f"{IRON_BLOCK_EMOJI} {iron_block_rate:.2f}{iron_block_unit} | "
            f"{GOLD_BLOCK_EMOJI} {gold_block_rate:.1f}{gold_block_unit} | "
            f"{EMERALD_BLOCK_EMOJI} {emerald_block_rate:.2f}{emerald_block_unit}"
        )
        
        print(f"[BANK] Admin {interaction.user} viewed {user}'s banking dashboard")
        
    except Exception as e:
        print(f"[ERR] View user banking failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to access user's banking: {str(e)}")

class ViewFullDashboardButton(ui.View):
    def __init__(self, user_id: int):
        super().__init__(timeout=300)
        self.user_id = user_id
        
    @ui.button(label="View Full Dashboard", style=discord.ButtonStyle.primary, emoji="üìä")
    async def view_dashboard(self, interaction: discord.Interaction, button: ui.Button):
        # Only allow the owner to click
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your balance!", ephemeral=True)
        
        await interaction.response.send_message("‚è≥ Opening your banking dashboard...", ephemeral=True)
        
        try:
            # Check for existing banking thread
            account = get_or_create_bank_account(interaction.user.id)
            if not account or not account.exists:
                return await interaction.edit_original_response(content="‚ùå Could not access your bank account.")
            
            account_data = account.to_dict()
            existing_thread_id = account_data.get('bankingThreadId')
            
            # Try to find existing thread
            thread = None
            if existing_thread_id:
                try:
                    thread = interaction.guild.get_thread(existing_thread_id)
                    if not thread:
                        thread = await interaction.guild.fetch_channel(existing_thread_id)
                except:
                    pass  # Thread doesn't exist anymore
            
            # Create new thread if needed
            if not thread:
                thread_name = f"üè¶ {interaction.user.name}'s Banking"
                thread = await interaction.channel.create_thread(
                    name=thread_name,
                    type=discord.ChannelType.private_thread,
                    invitable=False
                )
                
                # Save thread ID to account
                db.collection(BANK_ACCOUNTS_COLLECTION).document(str(interaction.user.id)).update({
                    'bankingThreadId': thread.id
                })
                
                # Add user to thread
                await thread.add_user(interaction.user)
                
                # Send initial welcome message
                await self.send_dashboard_to_thread(thread, interaction.user, account_data, is_new=True)
                
                await interaction.edit_original_response(
                    content=f"‚úÖ Created your private banking thread! Check {thread.mention}"
                )
            else:
                # Thread exists, send updated dashboard
                await thread.add_user(interaction.user)  # Make sure they're added
                await self.send_dashboard_to_thread(thread, interaction.user, account_data, is_new=False)
                
                await interaction.edit_original_response(
                    content=f"‚úÖ Updated your banking dashboard! Check {thread.mention}"
                )
                
        except Exception as e:
            print(f"[ERR] View dashboard failed: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to open dashboard: {str(e)}")
    
    async def send_dashboard_to_thread(self, thread, user, account_data, is_new=False):
        """Send full banking dashboard to thread"""
        try:
            account_number = account_data.get('accountNumber', 'Unknown')
            diamond_balance = account_data.get('diamondBalance', account_data.get('balance', 0.0))
            essence_balance = account_data.get('essenceBalance', 0.0)
            iron_balance = account_data.get('ironBalance', 0.0)
            gold_balance = account_data.get('goldBalance', 0.0)
            
            # Get market prices
            essence_price = get_market_price('essence')
            iron_price = get_market_price('iron')
            gold_price = get_market_price('gold')
            emerald_price = get_market_price('emerald')
            
            # Calculate total value
            total_value = diamond_balance + (essence_balance * essence_price) + (iron_balance * iron_price) + (gold_balance * gold_price)
            
            if is_new:
                # Send welcome message
                welcome_embed = discord.Embed(
                    title="üèõÔ∏è FLORAB√çS STATE ECONOMY",
                    description=(
                        f"*State Reserve & Commodities Exchange*\n"
                        f"**Private Banking for {user.mention}**\n\n"
                    ),
                    color=0x003d5c
                )
                
                # Account Summary
                welcome_embed.add_field(
                    name="üíº ACCOUNT SUMMARY",
                    value=(
                        f"**Account:** `{account_number}`\n"
                        f"**Total Value:** {DIAMOND_EMOJI} **{total_value:,.2f}d**\n"
                        f"**Status:** ‚úÖ Active & Verified"
                    ),
                    inline=False
                )
                
                # Commodity Balances - Clean format with abbreviations
                welcome_embed.add_field(
                    name="üí∞ ACCOUNT BALANCES",
                    value=(
                        f"**{DIAMOND_EMOJI} {diamond_balance:,.2f} d**\n"
                        f"**{ESSENCE_EMOJI} {essence_balance:,.0f} es**\n"
                        f"**{IRON_EMOJI} {iron_balance:,.0f} i**\n"
                        f"**{GOLD_EMOJI} {gold_balance:,.0f} gld**"
                    ),
                    inline=True
                )
                
                # Live Market Prices - Clean format
                welcome_embed.add_field(
                    name="üìà LIVE EXCHANGE RATES",
                    value=(
                        f"**{DIAMOND_EMOJI} d** ‚Äî 1.00 (base)\n"
                        f"**{ESSENCE_EMOJI} es** ‚Äî {(1/essence_price):.2f}/1d\n"
                        f"**{IRON_EMOJI} i** ‚Äî {(1/iron_price):.2f}/1d\n"
                        f"**{GOLD_EMOJI} gld** ‚Äî {(1/gold_price):.1f}/1d\n"
                        f"**{EMERALD_EMOJI} em** ‚Äî {(1/emerald_price):.2f}/1d"
                    ),
                    inline=True
                )
                
                welcome_embed.add_field(
                    name="üí° How to Use This Thread",
                    value=(
                        "‚Ä¢ This is your **private** banking thread\n"
                        "‚Ä¢ Use `/bank mybalance` anytime for quick balance check\n"
                        "‚Ä¢ Click 'View Full Dashboard' to come back here\n"
                        "‚Ä¢ Admins can help you with deposits/withdrawals here"
                    ),
                    inline=False
                )
                
                welcome_embed.set_footer(text="üèõÔ∏è Florab√≠s State Bank | Secure ‚Ä¢ Private ‚Ä¢ Trusted")
                
                await thread.send(embed=welcome_embed)
            else:
                # Send balance update
                update_embed = discord.Embed(
                    title="üîÑ BALANCE UPDATE",
                    description=f"**Account:** `{account_number}`",
                    color=0x003d5c
                )
                
                update_embed.add_field(
                    name="üí∞ Current Balances",
                    value=(
                        f"**{DIAMOND_EMOJI} {diamond_balance:,.2f} d** (~{diamond_balance:,.2f}d)\n"
                        f"**{ESSENCE_EMOJI} {essence_balance:,.0f} es** (~{essence_balance * essence_price:,.2f}d)\n"
                        f"**{IRON_EMOJI} {iron_balance:,.0f} i** (~{iron_balance * iron_price:,.2f}d)\n"
                        f"**{GOLD_EMOJI} {gold_balance:,.0f} gld** (~{gold_balance * gold_price:,.2f}d)\n\n"
                        f"**{DIAMOND_EMOJI} Portfolio Value:** {total_value:,.2f}d"
                    ),
                    inline=False
                )
                
                update_embed.set_footer(text=f"Updated at {datetime.now(timezone.utc).strftime('%I:%M %p EST')}")
                
                await thread.send(embed=update_embed)
                
        except Exception as e:
            print(f"[ERR] Send dashboard to thread failed: {e}")
            import traceback
            traceback.print_exc()

# ========================================
# TREASURY BONDS SYSTEM
# ========================================

@economy_group.command(name="buy_bond", description="üí∞ Invest in a Treasury Bond (earn interest over time)")
@app_commands.describe(
    amount="Amount of diamonds to invest",
    duration_days="Bond duration in days (7, 14, or 30)"
)
@app_commands.choices(duration_days=[
    app_commands.Choice(name="7 Days (3% interest)", value=7),
    app_commands.Choice(name="14 Days (6% interest)", value=14),
    app_commands.Choice(name="30 Days (10% interest)", value=30)
])
async def buy_bond_cmd(interaction: discord.Interaction, amount: float, duration_days: int):
    await interaction.response.send_message("‚è≥ Processing bond purchase...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if amount < 10:
        return await interaction.edit_original_response(content="‚ùå Minimum bond investment is 10 diamonds.")
    
    # Calculate interest based on duration
    interest_rates = {7: 0.03, 14: 0.06, 30: 0.10}
    interest_rate = interest_rates.get(duration_days, 0.05)
    interest_amount = amount * interest_rate
    maturity_amount = amount + interest_amount
    
    try:
        # Deduct diamonds from account
        success = deduct_from_bank(interaction.user.id, amount, 'bond_purchase', f"Purchased {duration_days}-day Treasury Bond")
        
        if not success:
            current_balance = get_bank_balance(interaction.user.id)
            return await interaction.edit_original_response(content=
                f"‚ùå Insufficient funds. You have **{current_balance:,.2f}d** but need **{amount:,.2f}d**."
            )
        
        # Generate unique bond ID (check for collisions)
        import random, string
        max_attempts = 10
        bond_id = None
        for attempt in range(max_attempts):
            temp_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            # Check if ID already exists
            if not db.collection(TREASURY_BONDS_COLLECTION).document(temp_id).get().exists:
                bond_id = temp_id
                break
        
        if not bond_id:
            return await interaction.edit_original_response(content="‚ùå Failed to generate unique bond ID. Please try again.")
        
        # Calculate maturity date
        from datetime import timedelta
        now_utc = datetime.now(timezone.utc)
        maturity_date = now_utc + timedelta(days=duration_days)
        
        # Create bond
        db.collection(TREASURY_BONDS_COLLECTION).document(bond_id).set({
            'bondId': bond_id,
            'userId': interaction.user.id,
            'userTag': interaction.user.mention,
            'userName': interaction.user.name,
            'principal': amount,
            'interestRate': interest_rate,
            'interestAmount': interest_amount,
            'maturityAmount': maturity_amount,
            'durationDays': duration_days,
            'purchaseDate': now_utc,
            'maturityDate': maturity_date,
            'jurisdiction': jurisdiction,
            'status': 'active',
            'redeemedAt': None
        })
        
        # Format maturity date in EST
        maturity_est = maturity_date.astimezone(EST)
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Treasury Bond Purchased!**\n\n"
            f"üìú **Bond ID:** `{bond_id}`\n"
            f"{DIAMOND_EMOJI} **Investment:** {amount:,.2f}d\n"
            f"üìä **Interest Rate:** {interest_rate*100:.0f}%\n"
            f"üí∞ **Maturity Value:** {maturity_amount:,.2f}d\n"
            f"üìÖ **Matures:** {maturity_est.strftime('%b %d, %Y at %I:%M %p EST')}\n\n"
            f"üí° Use `/economy my_bonds` to view all bonds\n"
            f"üí° Use `/economy redeem_bond` after maturity to claim"
        )
        
        print(f"[ECONOMY] {interaction.user} purchased {duration_days}-day bond for {amount:.2f}d (ID: {bond_id})")
        
    except Exception as e:
        print(f"[ERR] Bond purchase failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to purchase bond: {str(e)}")

@economy_group.command(name="my_bonds", description="üìä View your active Treasury Bonds")
async def my_bonds_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Loading your bonds...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all active bonds for user
        bonds = list(db.collection(TREASURY_BONDS_COLLECTION).where(
            filter=FieldFilter('userId', '==', interaction.user.id)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream())
        
        if not bonds:
            return await interaction.edit_original_response(content="üìã You have no active bonds.\n\nüí° Use `/economy buy_bond` to start investing!")
        
        now_utc = datetime.now(timezone.utc)
        
        bond_list = []
        total_invested = 0
        total_mature_value = 0
        
        for bond_doc in bonds:
            bond = bond_doc.to_dict()
            bond_id = bond.get('bondId')
            principal = bond.get('principal', 0)
            maturity_amount = bond.get('maturityAmount', 0)
            maturity_date = bond.get('maturityDate')
            duration = bond.get('durationDays', 0)
            
            total_invested += principal
            total_mature_value += maturity_amount
            
            # Check if matured
            if maturity_date and now_utc >= maturity_date:
                status_emoji = "‚úÖ"
                status_text = "READY TO REDEEM"
            else:
                status_emoji = "‚è≥"
                days_left = (maturity_date - now_utc).days if maturity_date else 0
                status_text = f"{days_left} days remaining"
            
            bond_list.append(
                f"{status_emoji} **{bond_id}** - {principal:,.0f}d ‚Üí {maturity_amount:,.0f}d ({duration}d)\n"
                f"   *{status_text}*"
            )
        
        embed = discord.Embed(
            title="üí∞ YOUR TREASURY BONDS",
            description="\n\n".join(bond_list),
            color=0x003d5c
        )
        
        embed.add_field(
            name="üìä Portfolio Summary",
            value=(
                f"{DIAMOND_EMOJI} **Total Invested:** {total_invested:,.2f}d\n"
                f"üí∞ **Maturity Value:** {total_mature_value:,.2f}d\n"
                f"üìà **Expected Profit:** {total_mature_value - total_invested:,.2f}d"
            ),
            inline=False
        )
        
        embed.set_footer(text="üí° Use /economy redeem_bond <bond_id> to redeem matured bonds")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Failed to load bonds: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to load bonds: {str(e)}")

@economy_group.command(name="redeem_bond", description=f"{DIAMOND_EMOJI} Redeem a matured Treasury Bond")
@app_commands.describe(bond_id="Bond ID to redeem")
async def redeem_bond_cmd(interaction: discord.Interaction, bond_id: str):
    await interaction.response.send_message("‚è≥ Processing redemption...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get bond
        bond_doc = db.collection(TREASURY_BONDS_COLLECTION).document(bond_id.upper()).get()
        
        if not bond_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Bond `{bond_id}` not found.")
        
        bond = bond_doc.to_dict()
        
        # Verify ownership
        if bond.get('userId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå This bond does not belong to you.")
        
        # Check if already redeemed
        if bond.get('status') != 'active':
            return await interaction.edit_original_response(content="‚ùå This bond has already been redeemed.")
        
        # Check if matured
        maturity_date = bond.get('maturityDate')
        now_utc = datetime.now(timezone.utc)
        
        if maturity_date and now_utc < maturity_date:
            maturity_est = maturity_date.astimezone(EST)
            return await interaction.edit_original_response(content=
                f"‚ùå Bond has not matured yet.\n"
                f"üìÖ Matures: {maturity_est.strftime('%b %d, %Y at %I:%M %p EST')}"
            )
        
        # Redeem bond
        maturity_amount = bond.get('maturityAmount', 0)
        principal = bond.get('principal', 0)
        interest = maturity_amount - principal
        
        # Deposit to account
        success = deposit_to_bank(interaction.user.id, maturity_amount, 'bond_redemption', f"Redeemed bond {bond_id}")
        
        if success:
            # Mark bond as redeemed
            bond_doc.reference.update({
                'status': 'redeemed',
                'redeemedAt': now_utc
            })
            
            await interaction.edit_original_response(content=
                f"‚úÖ **Bond Redeemed Successfully!**\n\n"
                f"üìú **Bond ID:** `{bond_id}`\n"
                f"{DIAMOND_EMOJI} **Principal:** {principal:,.2f}d\n"
                f"üìä **Interest Earned:** {interest:,.2f}d\n"
                f"üí∞ **Total Deposited:** {maturity_amount:,.2f}d\n\n"
                f"üí° Diamonds have been added to your bank account!"
            )
            
            print(f"[ECONOMY] {interaction.user} redeemed bond {bond_id} for {maturity_amount:.2f}d")
        else:
            await interaction.edit_original_response(content="‚ùå Failed to deposit to bank account.")
        
    except Exception as e:
        print(f"[ERR] Bond redemption failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to redeem bond: {str(e)}")

# ========================================
# ESSENCE CERTIFICATES SYSTEM
# ========================================

@economy_group.command(name="issue_certificate", description=f"{ESSENCE_EMOJI} Lock essence and issue tradeable certificate")
@app_commands.describe(amount="Amount of essence to lock")
async def issue_certificate_cmd(interaction: discord.Interaction, amount: float):
    await interaction.response.send_message("‚è≥ Issuing essence certificate...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if amount < 1:
        return await interaction.edit_original_response(content="‚ùå Minimum certificate amount is 1 essence.")
    
    try:
        # Check essence balance
        current_balance = get_commodity_balance(interaction.user.id, 'essence')
        
        if current_balance < amount:
            return await interaction.edit_original_response(content=
                f"‚ùå Insufficient essence. You have **{current_balance:,.0f} {ESSENCE_EMOJI}** but need **{amount:,.0f}**."
            )
        
        # Deduct essence from account
        success = update_commodity_balance(interaction.user.id, 'essence', -amount, 'certificate_lock', f"Locked {amount} essence in certificate")
        
        if not success:
            return await interaction.edit_original_response(content="‚ùå Failed to lock essence.")
        
        # Generate unique certificate ID (check for collisions)
        import random, string
        max_attempts = 10
        cert_id = None
        for attempt in range(max_attempts):
            temp_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            # Check if ID already exists
            if not db.collection(ESSENCE_CERTIFICATES_COLLECTION).document(temp_id).get().exists:
                cert_id = temp_id
                break
        
        if not cert_id:
            return await interaction.edit_original_response(content="‚ùå Failed to generate unique certificate ID. Please try again.")
        
        # Calculate certificate value at current market price
        essence_price = get_market_price('essence')
        estimated_value = amount * essence_price
        
        # Create certificate
        now_utc = datetime.now(timezone.utc)
        db.collection(ESSENCE_CERTIFICATES_COLLECTION).document(cert_id).set({
            'certificateId': cert_id,
            'issuerId': interaction.user.id,
            'issuerTag': interaction.user.mention,
            'issuerName': interaction.user.name,
            'currentOwnerId': interaction.user.id,
            'currentOwnerTag': interaction.user.mention,
            'essenceAmount': amount,
            'issuedAt': now_utc,
            'jurisdiction': jurisdiction,
            'status': 'active',
            'redeemedAt': None
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Essence Certificate Issued!**\n\n"
            f"üìú **Certificate ID:** `{cert_id}`\n"
            f"{ESSENCE_EMOJI} **Essence Locked:** {amount:,.0f} essence\n"
            f"{DIAMOND_EMOJI} **Estimated Value:** {estimated_value:,.2f}d\n\n"
            f"üí° This certificate is tradeable (future feature)\n"
            f"üí° Use `/economy redeem_certificate` to redeem for essence"
        )
        
        print(f"[ECONOMY] {interaction.user} issued essence certificate {cert_id} for {amount} essence")
        
    except Exception as e:
        print(f"[ERR] Certificate issuance failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to issue certificate: {str(e)}")

@economy_group.command(name="my_certificates", description="üìú View your essence certificates")
async def my_certificates_cmd(interaction: discord.Interaction):
    await interaction.response.send_message("‚è≥ Loading your certificates...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get all active certificates owned by user
        certs = list(db.collection(ESSENCE_CERTIFICATES_COLLECTION).where(
            filter=FieldFilter('currentOwnerId', '==', interaction.user.id)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream())
        
        if not certs:
            return await interaction.edit_original_response(content="üìã You have no active certificates.\n\nüí° Use `/economy issue_certificate` to lock essence!")
        
        # Get current essence price
        essence_price = get_market_price('essence')
        
        cert_list = []
        total_essence = 0
        total_value = 0
        
        for cert_doc in certs:
            cert = cert_doc.to_dict()
            cert_id = cert.get('certificateId')
            essence_amount = cert.get('essenceAmount', 0)
            issued_at = cert.get('issuedAt')
            
            total_essence += essence_amount
            value = essence_amount * essence_price
            total_value += value
            
            if isinstance(issued_at, datetime):
                issued_date = issued_at.astimezone(EST).strftime('%b %d, %Y')
            else:
                issued_date = 'Unknown'
            
            cert_list.append(
                f"üìú **{cert_id}** - {essence_amount:,.0f} {ESSENCE_EMOJI} (~{value:,.2f}d)\n"
                f"   *Issued: {issued_date}*"
            )
        
        embed = discord.Embed(
            title=f"{ESSENCE_EMOJI} YOUR ESSENCE CERTIFICATES",
            description="\n\n".join(cert_list),
            color=0xd4af37  # Gold color
        )
        
        embed.add_field(
            name="üìä Portfolio Summary",
            value=(
                f"{ESSENCE_EMOJI} **Total Essence:** {total_essence:,.0f} essence\n"
                f"{DIAMOND_EMOJI} **Current Value:** {total_value:,.2f}d\n"
                f"üìà **Market Price:** {(1/essence_price):.2f}es/1d"
            ),
            inline=False
        )
        
        embed.set_footer(text="üí° Use /economy redeem_certificate <cert_id> to redeem for essence")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Failed to load certificates: {e}")
        await interaction.edit_original_response(content=f"‚ùå Failed to load certificates: {str(e)}")

@economy_group.command(name="redeem_certificate", description=f"{DIAMOND_EMOJI} Redeem essence certificate for essence")
@app_commands.describe(certificate_id="Certificate ID to redeem")
async def redeem_certificate_cmd(interaction: discord.Interaction, certificate_id: str):
    await interaction.response.send_message("‚è≥ Redeeming certificate...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Get certificate
        cert_doc = db.collection(ESSENCE_CERTIFICATES_COLLECTION).document(certificate_id.upper()).get()
        
        if not cert_doc.exists:
            return await interaction.edit_original_response(content=f"‚ùå Certificate `{certificate_id}` not found.")
        
        cert = cert_doc.to_dict()
        
        # Verify ownership
        if cert.get('currentOwnerId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå This certificate does not belong to you.")
        
        # Check if already redeemed
        if cert.get('status') != 'active':
            return await interaction.edit_original_response(content="‚ùå This certificate has already been redeemed.")
        
        # Redeem certificate
        essence_amount = cert.get('essenceAmount', 0)
        
        # Deposit essence to account
        success = update_commodity_balance(interaction.user.id, 'essence', essence_amount, 'certificate_redemption', f"Redeemed certificate {certificate_id}")
        
        if success:
            # Mark certificate as redeemed
            now_utc = datetime.now(timezone.utc)
            cert_doc.reference.update({
                'status': 'redeemed',
                'redeemedAt': now_utc
            })
            
            # Get current market value
            essence_price = get_market_price('essence')
            current_value = essence_amount * essence_price
            
            await interaction.edit_original_response(content=
                f"‚úÖ **Certificate Redeemed Successfully!**\n\n"
                f"üìú **Certificate ID:** `{certificate_id}`\n"
                f"{ESSENCE_EMOJI} **Essence Returned:** {essence_amount:,.0f} essence\n"
                f"{DIAMOND_EMOJI} **Current Value:** {current_value:,.2f}d\n\n"
                f"üí° Essence has been added to your commodity account!"
            )
            
            print(f"[ECONOMY] {interaction.user} redeemed certificate {certificate_id} for {essence_amount} essence")
        else:
            await interaction.edit_original_response(content="‚ùå Failed to deposit essence to account.")
        
    except Exception as e:
        print(f"[ERR] Certificate redemption failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to redeem certificate: {str(e)}")

# ========================================
# ECONOMIC DASHBOARD
# ========================================

class ViewGDPGraphButton(ui.Button):
    """Button to view GDP graph on demand"""
    def __init__(self):
        super().__init__(
            label="View GDP Graph",
            style=discord.ButtonStyle.secondary,
            emoji="üìä",
            custom_id="view_gdp_graph"
        )
    
    async def callback(self, interaction: discord.Interaction):
        await interaction.response.send_message("üìä Generating GDP graph...", ephemeral=True)
        
        try:
            graph_buffer = generate_economy_gdp_graph()
            
            if graph_buffer:
                now_est = datetime.now(timezone.utc).astimezone(EST)
                
                embed = discord.Embed(
                    title="üìä FLORAB√çS GDP TREND",
                    description=f"*Historical Economic Performance*",
                    color=0x00C853
                )
                embed.set_footer(text=f"Updated: {now_est.strftime('%b %d, %Y at %I:%M %p EST')} | All-time GDP history")
                
                file = discord.File(graph_buffer, filename="gdp_trend.png")
                embed.set_image(url="attachment://gdp_trend.png")
                await interaction.edit_original_response(content=None, embed=embed, attachments=[file])
            else:
                await interaction.edit_original_response(content="üìã **No GDP Data Available**\n\nThe GDP graph will appear once economic activity begins (banking transactions, stock trades, etc.).")
        except Exception as e:
            print(f"[ERR] Failed to generate GDP graph: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to generate graph: {str(e)}")

@economy_group.command(name="dashboard", description="üìä View Florab√≠s State Economy Dashboard")
async def economy_dashboard_cmd(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection is alive before heavy query workload
    await ensure_firestore()
    
    try:
        # Get market prices for calculations
        essence_price = get_market_price('essence')
        iron_price = get_market_price('iron')
        gold_price = get_market_price('gold')
        emerald_price = get_market_price('emerald')
        iron_block_price = get_market_price('iron_block')
        gold_block_price = get_market_price('gold_block')
        emerald_block_price = get_market_price('emerald_block')
        
        # Get market rates for display
        diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread = get_market_rate('diamond')
        essence_rate, essence_unit, essence_buy, essence_sell, essence_spread = get_market_rate('essence')
        iron_rate, iron_unit, iron_buy, iron_sell, iron_spread = get_market_rate('iron')
        gold_rate, gold_unit, gold_buy, gold_sell, gold_spread = get_market_rate('gold')
        emerald_rate, emerald_unit, emerald_buy, emerald_sell, emerald_spread = get_market_rate('emerald')
        iron_block_rate, iron_block_unit, iron_block_buy, iron_block_sell, iron_block_spread = get_market_rate('iron_block')
        gold_block_rate, gold_block_unit, gold_block_buy, gold_block_sell, gold_block_spread = get_market_rate('gold_block')
        emerald_block_rate, emerald_block_unit, emerald_block_buy, emerald_block_sell, emerald_block_spread = get_market_rate('emerald_block')
        
        # Get STATE TREASURY RESERVES first
        treasury_items = db.collection(TREASURY_COLLECTION).stream()
        treasury_reserves = {}
        state_treasury_value = 0
        
        for doc in treasury_items:
            data = doc.to_dict()
            # Use document ID as resource name (document ID = commodity name)
            resource = doc.id
            amount = data.get('amount', 0)
            if amount > 0:
                treasury_reserves[resource] = amount
                
                # Calculate value
                if resource == 'Diamonds':
                    state_treasury_value += amount
                elif resource == 'Essence':
                    state_treasury_value += amount * essence_price
                elif resource == 'Iron':
                    state_treasury_value += amount * iron_price
                elif resource == 'Gold':
                    state_treasury_value += amount * gold_price
                elif resource == 'Emeralds':
                    state_treasury_value += amount // 10
                elif resource == 'Xp (Bottles)':
                    state_treasury_value += amount // 64
        
        # Get state-owned stock portfolio
        STATE_USER_ID = 0
        state_holdings = list(db.collection(SHARES_COLLECTION).where(filter=FieldFilter('ownerId', '==', STATE_USER_ID)).stream())
        state_portfolio_value = 0
        
        for holding in state_holdings:
            data = holding.to_dict()
            business_name = data.get('businessName', 'Unknown')
            shares = data.get('shares', 0)
            
            # Get current IPO price
            ipo = list(db.collection(IPOS_COLLECTION).where(filter=FieldFilter('businessName', '==', business_name)).limit(1).stream())
            price = ipo[0].to_dict()['pricePerShare'] if ipo else 10.0
            state_portfolio_value += shares * price
        
        # Calculate total deposits across all citizen accounts
        all_accounts = list(db.collection(BANK_ACCOUNTS_COLLECTION).stream())
        
        total_diamonds = 0
        total_essence = 0
        total_iron = 0
        total_gold = 0
        total_emerald = 0
        total_iron_blocks = 0
        total_gold_blocks = 0
        total_emerald_blocks = 0
        
        for acc_doc in all_accounts:
            acc = acc_doc.to_dict()
            total_diamonds += acc.get('diamondBalance', acc.get('balance', 0))
            total_essence += acc.get('essenceBalance', 0)
            total_iron += acc.get('ironBalance', 0)
            total_gold += acc.get('goldBalance', 0)
            total_emerald += acc.get('emeraldBalance', 0)
            total_iron_blocks += acc.get('ironBlockBalance', 0)
            total_gold_blocks += acc.get('goldBlockBalance', 0)
            total_emerald_blocks += acc.get('emeraldBlockBalance', 0)
        
        # Calculate total value in diamonds
        total_essence_value = total_essence * essence_price
        total_iron_value = total_iron * iron_price
        total_gold_value = total_gold * gold_price
        total_emerald_value = total_emerald * emerald_price
        total_iron_block_value = total_iron_blocks * iron_block_price
        total_gold_block_value = total_gold_blocks * gold_block_price
        total_emerald_block_value = total_emerald_blocks * emerald_block_price
        total_liquidity = (total_diamonds + total_essence_value + total_iron_value + total_gold_value + 
                          total_emerald_value + total_iron_block_value + total_gold_block_value + total_emerald_block_value)
        
        # Get active bonds
        active_bonds = list(db.collection(TREASURY_BONDS_COLLECTION).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream())
        
        total_bond_principal = sum(bond.to_dict().get('principal', 0) for bond in active_bonds)
        
        # Get active certificates
        active_certs = list(db.collection(ESSENCE_CERTIFICATES_COLLECTION).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream())
        
        locked_essence = sum(cert.to_dict().get('essenceAmount', 0) for cert in active_certs)
        
        # Build dashboard embed with beautiful UI
        embed = discord.Embed(
            title="üèõÔ∏è FLORAB√çS FINANCIAL CENTER",
            description="*Real-time market data & economic overview*",
            color=0x2F3136  # Dark theme
        )
        
        # Format exchange rates with bid/ask spreads if available, otherwise show simple rate
        def format_spread(buy, sell, rate, unit):
            if buy > 0 and sell > 0:
                return f"‚Üì{buy:.2f}{unit} | ‚Üë{sell:.2f}{unit}"
            else:
                return f"{rate:.2f}{unit}"
        
        diamond_display = format_spread(diamond_buy, diamond_sell, diamond_rate, diamond_unit)
        essence_display = format_spread(essence_buy, essence_sell, essence_rate, essence_unit)
        iron_display = format_spread(iron_buy, iron_sell, iron_rate, iron_unit)
        gold_display = format_spread(gold_buy, gold_sell, gold_rate, gold_unit)
        emerald_display = format_spread(emerald_buy, emerald_sell, emerald_rate, emerald_unit)
        iron_block_display = format_spread(iron_block_buy, iron_block_sell, iron_block_rate, iron_block_unit)
        gold_block_display = format_spread(gold_block_buy, gold_block_sell, gold_block_rate, gold_block_unit)
        emerald_block_display = format_spread(emerald_block_buy, emerald_block_sell, emerald_block_rate, emerald_block_unit)
        
        # Market Exchange Rates - Clean format with abbreviations
        embed.add_field(
            name="üíπ EXCHANGE RATES",
            value=(
                f"**{DIAMOND_EMOJI} d** ‚Äî {diamond_display}\n"
                f"**{ESSENCE_EMOJI} es** ‚Äî {essence_display}\n"
                f"**{IRON_EMOJI} i** ‚Äî {iron_display}\n"
                f"**{GOLD_EMOJI} gld** ‚Äî {gold_display}\n"
                f"**{EMERALD_EMOJI} em** ‚Äî {emerald_display}"
            ),
            inline=True
        )
        
        # Block Exchange Rates
        embed.add_field(
            name="üì¶ BLOCK RATES",
            value=(
                f"**{IRON_BLOCK_EMOJI} i-blk** ‚Äî {iron_block_display}\n"
                f"**{GOLD_BLOCK_EMOJI} gld-blk** ‚Äî {gold_block_display}\n"
                f"**{EMERALD_BLOCK_EMOJI} em-blk** ‚Äî {emerald_block_display}"
            ),
            inline=True
        )
        
        # Block Exchange Calculator - Show conversions based on average price
        # 1 Diamond Block = 9 Diamonds
        diamond_block_value = 9.0
        
        # Calculate how many material blocks you can get per diamond block
        iron_blocks_per_dblock = diamond_block_value / iron_block_price if iron_block_price > 0 else 0
        gold_blocks_per_dblock = diamond_block_value / gold_block_price if gold_block_price > 0 else 0
        emerald_blocks_per_dblock = diamond_block_value / emerald_block_price if emerald_block_price > 0 else 0
        
        # Calculate total possible exchanges based on citizen holdings
        max_iron_exchanges = int(total_iron_blocks / iron_blocks_per_dblock) if iron_blocks_per_dblock > 0 else 0
        max_gold_exchanges = int(total_gold_blocks / gold_blocks_per_dblock) if gold_blocks_per_dblock > 0 else 0
        max_emerald_exchanges = int(total_emerald_blocks / emerald_blocks_per_dblock) if emerald_blocks_per_dblock > 0 else 0
        
        exchange_text = ""
        if iron_blocks_per_dblock > 0:
            exchange_text += f"{DIAMOND_BLOCK_EMOJI} **1 d-blk** ‚Üí {iron_blocks_per_dblock:.1f} {IRON_BLOCK_EMOJI} i-blk | {max_iron_exchanges} exchanges left\n"
        if gold_blocks_per_dblock > 0:
            exchange_text += f"{DIAMOND_BLOCK_EMOJI} **1 d-blk** ‚Üí {gold_blocks_per_dblock:.1f} {GOLD_BLOCK_EMOJI} gld-blk | {max_gold_exchanges} exchanges left\n"
        if emerald_blocks_per_dblock > 0:
            exchange_text += f"{DIAMOND_BLOCK_EMOJI} **1 d-blk** ‚Üí {emerald_blocks_per_dblock:.1f} {EMERALD_BLOCK_EMOJI} em-blk | {max_emerald_exchanges} exchanges left"
        
        if exchange_text:
            embed.add_field(
                name="üîÑ BLOCK EXCHANGE",
                value=exchange_text,
                inline=False
            )
        
        # STATE TREASURY (only add if we have variables defined - check if state_treasury_value exists)
        try:
            treasury_text = ""
            for resource, amount in treasury_reserves.items():
                if resource == 'Diamonds':
                    treasury_text += f"{DIAMOND_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Essence':
                    treasury_text += f"{ESSENCE_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Iron':
                    treasury_text += f"{IRON_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Gold':
                    treasury_text += f"{GOLD_EMOJI} **{resource}:** {amount:,.0f}\n"
                elif resource == 'Emeralds':
                    treasury_text += f"{EMERALD_EMOJI} **{resource}:** {amount:,.0f}\n"
                else:
                    treasury_text += f"**{resource}:** {amount:,.0f}\n"
            
            total_state_value = state_treasury_value + state_portfolio_value
            if not treasury_text:
                treasury_text = "No reserves"
            else:
                treasury_text += f"\nüìä **Treasury Value:** {state_treasury_value:,.0f}d"
                if state_portfolio_value > 0:
                    treasury_text += f"\nüìà **Stock Portfolio:** {state_portfolio_value:,.0f}d"
                    treasury_text += f"\nüí∞ **Total State Assets:** {total_state_value:,.0f}d"
            
            embed.add_field(
                name="üèõÔ∏è STATE TREASURY",
                value=treasury_text,
                inline=False
            )
        except:
            pass  # Skip if state treasury vars not defined
        
        # Citizen Bank Liquidity - Clean format
        embed.add_field(
            name="üí∞ CITIZEN LIQUIDITY",
            value=(
                f"{DIAMOND_EMOJI} **{total_diamonds:,.0f} d** (~{total_diamonds:,.0f}d)\n"
                f"{ESSENCE_EMOJI} **{total_essence:,.0f} es** (~{total_essence_value:,.0f}d)\n"
                f"{IRON_EMOJI} **{total_iron:,.0f} i** (~{total_iron_value:,.0f}d)\n"
                f"{GOLD_EMOJI} **{total_gold:,.0f} gld** (~{total_gold_value:,.0f}d)\n"
                f"{EMERALD_EMOJI} **{total_emerald:,.0f} em** (~{total_emerald_value:,.0f}d)\n"
                f"{IRON_BLOCK_EMOJI} **{total_iron_blocks:,.0f} i-blk** (~{total_iron_block_value:,.0f}d)\n"
                f"{GOLD_BLOCK_EMOJI} **{total_gold_blocks:,.0f} gld-blk** (~{total_gold_block_value:,.0f}d)\n"
                f"{EMERALD_BLOCK_EMOJI} **{total_emerald_blocks:,.0f} em-blk** (~{total_emerald_block_value:,.0f}d)\n"
                f"\n"
                f"**{DIAMOND_EMOJI} Total:** {total_liquidity:,.0f}d"
            ),
            inline=False
        )
        
        # Investment Activity - Clean format
        embed.add_field(
            name="üìà INVESTMENTS",
            value=(
                f"üí∞ **Bonds:** {len(active_bonds)} active | {total_bond_principal:,.0f}d\n"
                f"üìú **Certificates:** {len(active_certs)} active | {locked_essence:,.0f} es locked"
            ),
            inline=True
        )
        
        # Economic Indicators - Clean format
        liquidity_status = "üü¢ Healthy" if total_liquidity > 1000 else "üî¥ Low"
        market_status = "üü¢ Active" if len(active_bonds) > 0 else "üîµ Calm"
        
        embed.add_field(
            name="üìä MARKET STATUS",
            value=(
                f"**Liquidity:** {liquidity_status}\n"
                f"**Activity:** {market_status}\n"
                f"**Accounts:** {len(all_accounts)} citizens"
            ),
            inline=True
        )
        
        now_est = datetime.now(timezone.utc).astimezone(EST)
        
        # Footer - graphs are optional, view via button
        embed.set_footer(text=f"Updated: {now_est.strftime('%b %d, %Y at %I:%M %p EST')} | üìä Click 'View GDP Graph' to see trends")
        
        # Add View Graph button wrapped in a View
        view = ui.View()
        view.add_item(ViewGDPGraphButton())
        await interaction.edit_original_response(embed=embed, view=view)
        
    except Exception as e:
        print(f"[ERR] Economic dashboard failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to load dashboard: {str(e)}")


# ========================================
# CONSTITUTION MANAGEMENT
# ========================================

@bot.tree.command(name="constitution", description="[ADMIN] View or set constitutions for the website")
@app_commands.describe(
    action="View or set constitution",
    doc_type="Which constitution to manage",
    content="Full text of the constitution (for 'set' action only)"
)
@app_commands.choices(
    action=[
        app_commands.Choice(name="View current", value="view"),
        app_commands.Choice(name="Set content", value="set")
    ],
    doc_type=[
        app_commands.Choice(name="State of Florab√≠s Constitution", value="state"),
        app_commands.Choice(name="Imperial Federation Constitution", value="federal")
    ]
)
async def constitution_cmd(interaction: discord.Interaction, action: str, doc_type: str, content: str = None):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    await interaction.response.defer(ephemeral=True)
    
    await ensure_firestore()
    if not db:
        return await interaction.followup.send("‚ùå Database not available.")
    
    doc_name = f"{doc_type}_constitution"
    doc_ref = db.collection('florabi_config').document(doc_name)
    
    try:
        if action == "view":
            doc = await asyncio.to_thread(doc_ref.get)
            if doc.exists:
                current = doc.to_dict().get('content', '')
                if len(current) > 1900:
                    current = current[:1900] + "...\n\n(Truncated - view full on website)"
                embed = discord.Embed(
                    title=f"üìú {'State' if doc_type == 'state' else 'Imperial Federation'} Constitution",
                    description=current if current else "*Not set yet*",
                    color=discord.Color.gold()
                )
                await interaction.followup.send(embed=embed)
            else:
                await interaction.followup.send(f"‚ÑπÔ∏è The {doc_type} constitution has not been set yet.")
        
        elif action == "set":
            if not content:
                return await interaction.followup.send("‚ùå Please provide the constitution content.")
            
            await asyncio.to_thread(lambda: doc_ref.set({
                'content': content,
                'updatedAt': datetime.now(timezone.utc),
                'updatedBy': str(interaction.user)
            }))
            
            await interaction.followup.send(f"‚úÖ {'State' if doc_type == 'state' else 'Imperial Federation'} Constitution has been updated! View it at your website's /constitutions page.")
    
    except Exception as e:
        print(f"[ERR] Constitution command failed: {e}")
        await interaction.followup.send(f"‚ùå Error: {str(e)}")

# ========================================
# ADMIN MARKET PRICE MANAGEMENT
# ========================================

@bot.tree.command(name="setprice", description="[ADMIN] Set CivMC market rate for commodities")
@app_commands.describe(
    commodity="Commodity to price",
    rate="Mid-market rate (e.g., 3.5 for '3.5es/1d' or 8 for '8i/1d')",
    spread_percent="Optional: State profit margin % (e.g., 5 = 5% spread between buy/sell)"
)
@app_commands.choices(commodity=[
    app_commands.Choice(name=f"{DIAMOND_EMOJI} Diamond (base)", value="diamond:d/1d"),
    app_commands.Choice(name=f"{ESSENCE_EMOJI} Essence", value="essence:es/1d"),
    app_commands.Choice(name=f"{IRON_EMOJI} Iron Ingots", value="iron:i/1d"),
    app_commands.Choice(name=f"{GOLD_EMOJI} Gold Ingots", value="gold:gld/1d"),
    app_commands.Choice(name=f"{EMERALD_EMOJI} Emerald", value="emerald:em/1d"),
    app_commands.Choice(name=f"{IRON_BLOCK_EMOJI} Iron Blocks", value="iron_block:iblk/1d"),
    app_commands.Choice(name=f"{GOLD_BLOCK_EMOJI} Gold Blocks", value="gold_block:gblk/1d"),
    app_commands.Choice(name=f"{EMERALD_BLOCK_EMOJI} Emerald Blocks", value="emerald_block:eblk/1d")
])
async def setprice_cmd(interaction: discord.Interaction, commodity: str, rate: float, spread_percent: float = 0.0):
    # Admin check FIRST
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    # Parse commodity and unit
    commodity_id, unit_display = commodity.split(':')
    
    await interaction.response.send_message(f"‚è≥ Setting {commodity_id} rate...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if rate <= 0:
        return await interaction.edit_original_response(content="‚ùå Rate must be greater than 0.")
    
    try:
        # Convert rate to price (rate = units per diamond, price = diamonds per unit)
        price = 1.0 / rate
        
        # Calculate buy/sell rates with spread (CivMC style)
        # State BUYS from citizens at lower rate (citizens get less)
        # State SELLS to citizens at higher rate (citizens pay more)
        spread_multiplier = spread_percent / 100.0 if spread_percent > 0 else 0.0
        
        buy_rate = rate * (1 - spread_multiplier / 2)  # State buys at lower rate
        sell_rate = rate * (1 + spread_multiplier / 2)  # State sells at higher rate
        
        # Store data in Firestore
        price_data = {
            'price': price,  # Used for calculations (diamonds per unit) - uses mid rate
            'rate': rate,    # Mid-market rate (units per diamond)
            'buyRate': buy_rate,  # State buying rate (lower)
            'sellRate': sell_rate,  # State selling rate (higher)
            'spreadPercent': spread_percent,
            'unit': unit_display,
            'lastUpdated': datetime.now(timezone.utc),
            'updatedBy': interaction.user.id
        }
        
        db.collection(MARKET_PRICES_COLLECTION).document(commodity_id).set(price_data)
        
        # Get emoji
        emoji_map = {
            'diamond': DIAMOND_EMOJI,
            'essence': ESSENCE_EMOJI,
            'iron': IRON_EMOJI,
            'gold': GOLD_EMOJI,
            'emerald': EMERALD_EMOJI,
            'iron_block': IRON_BLOCK_EMOJI,
            'gold_block': GOLD_BLOCK_EMOJI,
            'emerald_block': EMERALD_BLOCK_EMOJI
        }
        
        emoji = emoji_map.get(commodity_id, '')
        commodity_display = commodity_id.replace('_', ' ').title()
        
        # Build response message
        response_msg = f"‚úÖ **Market Rate Updated!**\n\n{emoji} **{commodity_display}**\n"
        
        if spread_percent > 0:
            response_msg += (
                f"üìä **Mid-Market:** {rate:.2f}{unit_display}\n"
                f"üü¢ **State Buys:** {buy_rate:.2f}{unit_display} (you sell to state)\n"
                f"üî¥ **State Sells:** {sell_rate:.2f}{unit_display} (you buy from state)\n"
                f"üíπ **Spread:** {spread_percent}% (state profit margin)\n\n"
                f"üí° The {spread_percent}% spread ensures state liquidity and profit."
            )
        else:
            response_msg += (
                f"üìä **Rate:** {rate:.2f}{unit_display}\n"
                f"{DIAMOND_EMOJI} **Conversion:** {rate:.2f} {commodity_id} = 1 diamond\n\n"
                f"üí° No spread set - single unified rate for all transactions."
            )
        
        await interaction.edit_original_response(content=response_msg)
        
        print(f"[ECONOMY] Admin {interaction.user} set {commodity_id} rate to {rate} {unit_display} (price: {price:.4f}d)")
        
    except Exception as e:
        print(f"[ERR] Set market rate failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to set rate: {str(e)}")

@economy_group.command(name="view_prices", description="[ADMIN] View and manage current market prices")
async def view_market_prices_cmd(interaction: discord.Interaction):
    # Admin check FIRST
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå This command is for Admins only.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Loading market prices...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        essence_price = get_market_price('essence')
        iron_price = get_market_price('iron')
        gold_price = get_market_price('gold')
        
        essence_per_diamond = 1 / essence_price if essence_price > 0 else 0
        iron_per_diamond = 1 / iron_price if iron_price > 0 else 0
        gold_per_diamond = 1 / gold_price if gold_price > 0 else 0
        
        embed = discord.Embed(
            title="üíπ MARKET PRICE MANAGEMENT",
            description="*Current commodity exchange rates*\n",
            color=0xFFD700
        )
        
        embed.add_field(
            name=f"{ESSENCE_EMOJI} ESSENCE",
            value=(
                f"**CivMC Rate:** {(1/essence_price):.2f}es/1d\n"
                f"**Bot Price:** {essence_price:.4f}d/unit"
            ),
            inline=True
        )
        
        embed.add_field(
            name=f"{IRON_EMOJI} IRON",
            value=(
                f"**CivMC Rate:** {(1/iron_price):.2f}i/1d\n"
                f"**Bot Price:** {iron_price:.4f}d/ingot"
            ),
            inline=True
        )
        
        embed.add_field(
            name=f"{GOLD_EMOJI} GOLD",
            value=(
                f"**CivMC Rate:** {(1/gold_price):.1f}gld/1d\n"
                f"**Bot Price:** {gold_price:.4f}d/ingot"
            ),
            inline=True
        )
        
        embed.add_field(
            name="‚öôÔ∏è HOW TO UPDATE",
            value=(
                "Use `/economy set_price` to change rates:\n"
                f"‚Ä¢ `/economy set_price essence 0.125` ‚Üí 8 essence = 1d\n"
                f"‚Ä¢ `/economy set_price iron 0.1` ‚Üí 10 iron = 1d\n"
                f"‚Ä¢ `/economy set_price gold 0.05` ‚Üí 20 gold = 1d"
            ),
            inline=False
        )
        
        embed.set_footer(text="üèõÔ∏è Florab√≠s State Economy | Admin Controls")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] View market prices failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to load prices: {str(e)}")

# ========================================
# UNIFIED ACCOUNT DASHBOARD
# ========================================

class AccountDashboardView(discord.ui.View):
    """Unified account dashboard with all banking and economy features"""
    def __init__(self, user_id: int):
        super().__init__(timeout=300)
        self.user_id = user_id
    
    @discord.ui.button(label="üí∞ My Bonds", style=discord.ButtonStyle.primary, row=0)
    async def view_bonds_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your account!", ephemeral=True)
        
        await interaction.response.send_message("‚è≥ Loading your bonds...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            bonds = list(db.collection(TREASURY_BONDS_COLLECTION).where(
                filter=FieldFilter('userId', '==', self.user_id)
            ).where(
                filter=FieldFilter('status', '==', 'active')
            ).stream())
            
            if not bonds:
                return await interaction.edit_original_response(content="üìã You have no active bonds.\n\nüí° Click **Invest** to buy bonds and earn interest!")
            
            now_utc = datetime.now(timezone.utc)
            
            bond_list = []
            total_invested = 0
            total_mature_value = 0
            
            for bond_doc in bonds:
                bond = bond_doc.to_dict()
                bond_id = bond.get('bondId')
                principal = bond.get('principal', 0)
                maturity_amount = bond.get('maturityAmount', 0)
                maturity_date = bond.get('maturityDate')
                duration = bond.get('durationDays', 0)
                
                total_invested += principal
                total_mature_value += maturity_amount
                
                if maturity_date and now_utc >= maturity_date:
                    status_emoji = "‚úÖ"
                    status_text = "READY TO REDEEM"
                else:
                    status_emoji = "‚è≥"
                    days_left = (maturity_date - now_utc).days if maturity_date else 0
                    status_text = f"{days_left} days remaining"
                
                bond_list.append(
                    f"{status_emoji} **{bond_id}** - {principal:,.0f}d ‚Üí {maturity_amount:,.0f}d ({duration}d)\n"
                    f"   *{status_text}*"
                )
            
            embed = discord.Embed(
                title="üí∞ YOUR TREASURY BONDS",
                description="\n\n".join(bond_list),
                color=0x003d5c
            )
            
            embed.add_field(
                name="üìä Portfolio Summary",
                value=(
                    f"{DIAMOND_EMOJI} **Total Invested:** {total_invested:,.2f}d\n"
                    f"üí∞ **Maturity Value:** {total_mature_value:,.2f}d\n"
                    f"üìà **Expected Profit:** {total_mature_value - total_invested:,.2f}d"
                ),
                inline=False
            )
            
            embed.set_footer(text="üí° Use /redeem_bond <bond_id> to redeem matured bonds")
            
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Failed to load bonds: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to load bonds: {str(e)}")
    
    @discord.ui.button(label=f"üìú My Certificates", style=discord.ButtonStyle.primary, row=0)
    async def view_certificates_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your account!", ephemeral=True)
        
        await interaction.response.send_message("‚è≥ Loading your certificates...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            certs = list(db.collection(ESSENCE_CERTIFICATES_COLLECTION).where(
                filter=FieldFilter('currentOwnerId', '==', self.user_id)
            ).where(
                filter=FieldFilter('status', '==', 'active')
            ).stream())
            
            if not certs:
                return await interaction.edit_original_response(content=f"üìã You have no active certificates.\n\nüí° Click **Invest** to lock {ESSENCE_EMOJI} essence!")
            
            essence_price = get_market_price('essence')
            
            cert_list = []
            total_essence = 0
            total_value = 0
            
            for cert_doc in certs:
                cert = cert_doc.to_dict()
                cert_id = cert.get('certificateId')
                essence_amount = cert.get('essenceAmount', 0)
                issued_at = cert.get('issuedAt')
                
                total_essence += essence_amount
                value = essence_amount * essence_price
                total_value += value
                
                if isinstance(issued_at, datetime):
                    issued_date = issued_at.astimezone(EST).strftime('%b %d, %Y')
                else:
                    issued_date = 'Unknown'
                
                cert_list.append(
                    f"üìú **{cert_id}** - {essence_amount:,.0f} {ESSENCE_EMOJI} (~{value:,.2f}d)\n"
                    f"   *Issued: {issued_date}*"
                )
            
            embed = discord.Embed(
                title=f"{ESSENCE_EMOJI} YOUR ESSENCE CERTIFICATES",
                description="\n\n".join(cert_list),
                color=0xd4af37
            )
            
            embed.add_field(
                name="üìä Portfolio Summary",
                value=(
                    f"{ESSENCE_EMOJI} **Total Essence:** {total_essence:,.0f} essence\n"
                    f"{DIAMOND_EMOJI} **Current Value:** {total_value:,.2f}d\n"
                    f"üìà **Market Price:** {(1/essence_price):.2f}es/1d"
                ),
                inline=False
            )
            
            embed.set_footer(text="üí° Use /redeem_certificate <cert_id> to redeem for essence")
            
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Failed to load certificates: {e}")
            await interaction.edit_original_response(content=f"‚ùå Failed to load certificates: {str(e)}")
    
    @discord.ui.button(label="üìä Transaction History", style=discord.ButtonStyle.secondary, row=0)
    async def view_history_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your account!", ephemeral=True)
        
        await interaction.response.send_message("‚è≥ Loading transaction history...", ephemeral=True)
        
        if not db:
            return await interaction.edit_original_response(content="‚ùå Database not available.")
        
        try:
            account = get_or_create_bank_account(self.user_id)
            if not account or not account.exists:
                return await interaction.edit_original_response(content="‚ùå Bank account not found.")
            
            account_number = account.to_dict().get('accountNumber')
            
            transactions = list(db.collection(BANK_TRANSACTIONS_COLLECTION).where(
                filter=FieldFilter('accountNumber', '==', account_number)
            ).order_by('timestamp', direction=firestore.Query.DESCENDING).limit(10).stream())
            
            if not transactions:
                return await interaction.edit_original_response(content="üìã No transaction history yet.")
            
            tx_list = []
            for tx_doc in transactions:
                tx = tx_doc.to_dict()
                tx_type = tx.get('type', 'unknown')
                amount = tx.get('amount', 0)
                balance_after = tx.get('balanceAfter', 0)
                memo = tx.get('memo', '')
                timestamp = tx.get('timestamp')
                commodity = tx.get('commodity', 'diamond')
                
                if isinstance(timestamp, datetime):
                    time_est = timestamp.astimezone(EST).strftime('%b %d, %I:%M %p')
                else:
                    time_est = 'Unknown'
                
                if commodity == 'essence':
                    emoji = ESSENCE_EMOJI
                    unit = 'units'
                elif commodity == 'iron':
                    emoji = IRON_EMOJI
                    unit = 'stacks'
                else:
                    emoji = DIAMOND_EMOJI
                    unit = 'd'
                
                sign = '+' if amount > 0 else ''
                tx_list.append(f"`{time_est}` {sign}{amount:,.2f}{emoji} - *{tx_type}*\n  Balance: {balance_after:,.2f} {unit}")
            
            embed = discord.Embed(
                title="üìä RECENT TRANSACTIONS",
                description="\n\n".join(tx_list[:10]),
                color=0x003d5c
            )
            
            embed.set_footer(text=f"Account: {account_number} | Last 10 transactions")
            
            await interaction.edit_original_response(embed=embed)
            
        except Exception as e:
            print(f"[ERR] Failed to load history: {e}")
            import traceback
            traceback.print_exc()
            await interaction.edit_original_response(content=f"‚ùå Failed to load history: {str(e)}")
    
    @discord.ui.button(label="üè¶ Invest", style=discord.ButtonStyle.success, row=1)
    async def invest_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your account!", ephemeral=True)
        
        await interaction.response.send_message(
            "üí∞ **INVESTMENT OPTIONS**\n\n"
            "Choose how you want to grow your wealth:\n\n"
            "**Treasury Bonds:**\n"
            "‚Ä¢ Invest diamonds, earn guaranteed interest\n"
            "‚Ä¢ 7 days ‚Üí 3% | 14 days ‚Üí 6% | 30 days ‚Üí 10%\n"
            "‚Ä¢ Use: `/buy_bond <amount> <duration>`\n\n"
            f"**Essence Certificates:**\n"
            f"‚Ä¢ Lock {ESSENCE_EMOJI} essence, get tradeable certificate\n"
            "‚Ä¢ Redeem anytime for your essence back\n"
            f"‚Ä¢ Use: `/issue_certificate <amount>`\n\n"
            "üí° All investments are safe and state-guaranteed!",
            ephemeral=True
        )
    
    @discord.ui.button(label="üí∏ Transfer", style=discord.ButtonStyle.success, row=1)
    async def transfer_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your account!", ephemeral=True)
        
        await interaction.response.send_message(
            "üí∏ **TRANSFER FUNDS**\n\n"
            "Send diamonds instantly to another citizen:\n\n"
            "**Command:** `/bank transfer @citizen <amount>`\n\n"
            "**Example:** `/bank transfer @JohnDoe 100`\n\n"
            "üí° Transfers are instant and free!",
            ephemeral=True
        )
    
    @discord.ui.button(label="üîÑ Refresh", style=discord.ButtonStyle.secondary, row=1)
    async def refresh_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("‚ùå This is not your account!", ephemeral=True)
        
        await interaction.response.defer(ephemeral=True)
        
        # Regenerate the account view
        if not db or not is_citizen(self.user_id):
            return await interaction.followup.send("‚ùå Cannot refresh account.", ephemeral=True)
        
        try:
            account = get_or_create_bank_account(self.user_id)
            if not account or not account.exists:
                return await interaction.followup.send("‚ùå Bank account not found.", ephemeral=True)
            
            account_data = account.to_dict()
            diamond_balance = account_data.get('diamondBalance', account_data.get('balance', 0))
            essence_balance = account_data.get('essenceBalance', 0)
            iron_balance = account_data.get('ironBalance', 0)
            account_number = account_data.get('accountNumber', 'Unknown')
            
            essence_price = get_market_price('essence')
            iron_price = get_market_price('iron')
            
            # Get market rates for display
            diamond_rate, diamond_unit, diamond_buy, diamond_sell, diamond_spread = get_market_rate('diamond')
            
            essence_value = essence_balance * essence_price
            iron_value = iron_balance * iron_price
            total_value = diamond_balance + essence_value + iron_value
            
            embed = discord.Embed(
                title="üèõÔ∏è YOUR FLORAB√çS ACCOUNT",
                description=f"**Account:** `{account_number}`\n",
                color=0x003d5c
            )
            
            embed.add_field(
                name="üí∞ BALANCES",
                value=(
                    f"{DIAMOND_EMOJI} **Diamonds:** {diamond_balance:,.2f}d\n"
                    f"{ESSENCE_EMOJI} **Essence:** {essence_balance:,.0f} units (~{essence_value:,.2f}d)\n"
                    f"{IRON_EMOJI} **Iron:** {iron_balance:,.0f} ingots (~{iron_value:,.2f}d)\n"
                    f"\n"
                    f"üìä **Total Value:** {total_value:,.2f}d"
                ),
                inline=False
            )
            
            embed.add_field(
                name="üíπ CURRENT MARKET PRICES",
                value=(
                    f"{DIAMOND_EMOJI} Diamond: {diamond_rate:.2f}{diamond_unit}\n"
                    f"{ESSENCE_EMOJI} Essence: {(1/essence_price):.2f}es/1d\n"
                    f"{IRON_EMOJI} Iron: {(1/iron_price):.2f}i/1d"
                ),
                inline=True
            )
            
            bonds_count = len(list(db.collection(TREASURY_BONDS_COLLECTION).where(
                filter=FieldFilter('userId', '==', self.user_id)
            ).where(filter=FieldFilter('status', '==', 'active')).stream()))
            
            certs_count = len(list(db.collection(ESSENCE_CERTIFICATES_COLLECTION).where(
                filter=FieldFilter('currentOwnerId', '==', self.user_id)
            ).where(filter=FieldFilter('status', '==', 'active')).stream()))
            
            embed.add_field(
                name="üìà INVESTMENTS",
                value=(
                    f"üí∞ Active Bonds: {bonds_count}\n"
                    f"üìú Certificates: {certs_count}"
                ),
                inline=True
            )
            
            now_est = datetime.now(timezone.utc).astimezone(EST)
            embed.set_footer(text=f"Updated: {now_est.strftime('%I:%M %p EST')} | Click buttons below to manage")
            
            view = AccountDashboardView(self.user_id)
            
            await interaction.edit_original_response(embed=embed, view=view)
            await interaction.followup.send("‚úÖ Account refreshed!", ephemeral=True)
            
        except Exception as e:
            print(f"[ERR] Failed to refresh account: {e}")
            await interaction.followup.send(f"‚ùå Failed to refresh: {str(e)}", ephemeral=True)

# ========================================
# ECONOMIC REPORTS SYSTEM (#18)
# ========================================

@economy_group.command(name="report", description="üìä View comprehensive economic report for Florab√≠s")
async def economic_report(interaction: discord.Interaction):
    await interaction.response.send_message("üìä Generating economic report...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        
        # Get all bank accounts
        accounts = list(db.collection(BANK_ACCOUNTS_COLLECTION).stream())
        
        # Calculate total citizen liquidity
        total_diamonds = 0
        total_essence = 0
        total_iron = 0
        total_gold = 0
        total_accounts = len(accounts)
        
        richest_citizen = None
        richest_balance = 0
        
        for acc_doc in accounts:
            acc = acc_doc.to_dict()
            diamonds = acc.get('balances', {}).get('diamonds', 0)
            essence = acc.get('balances', {}).get('essence', 0)
            iron = acc.get('balances', {}).get('iron', 0)
            gold = acc.get('balances', {}).get('gold', 0)
            
            total_diamonds += diamonds
            total_essence += essence
            total_iron += iron
            total_gold += gold
            
            # Track richest citizen
            if diamonds > richest_balance:
                richest_balance = diamonds
                richest_citizen = acc.get('accountNumber', 'Unknown')
        
        # Get treasury reserves
        treasury_diamonds = 0
        treasury_essence = 0
        treasury_iron = 0
        treasury_gold = 0
        treasury_emeralds = 0
        
        for item in db.collection(TREASURY_COLLECTION).stream():
            commodity = item.id
            data = item.to_dict()
            quantity = data.get('quantity', 0)
            
            if commodity == 'Diamonds':
                treasury_diamonds = quantity
            elif commodity == 'Essence':
                treasury_essence = quantity
            elif commodity == 'Iron':
                treasury_iron = quantity
            elif commodity == 'Gold':
                treasury_gold = quantity
            elif commodity == 'Emeralds':
                treasury_emeralds = quantity
        
        # Get market prices
        essence_price = get_market_price('essence')
        iron_price = get_market_price('iron')
        gold_price = get_market_price('gold')
        
        # Calculate citizen liquidity value in diamonds
        citizen_liquidity_value = (
            total_diamonds +
            (total_essence * essence_price) +
            (total_iron * iron_price) +
            (total_gold * gold_price)
        )
        
        # Calculate state reserves value in diamonds
        state_reserves_value = (
            treasury_diamonds +
            (treasury_essence * essence_price) +
            (treasury_iron * iron_price) +
            (treasury_gold * gold_price) +
            (treasury_emeralds * 64.0)  # Emeralds worth 64d each
        )
        
        # Calculate total GDP (state + citizens)
        total_gdp = citizen_liquidity_value + state_reserves_value
        
        # Get business data
        businesses = list(db.collection(BUSINESSES_COLLECTION).stream())
        total_businesses = len(businesses)
        public_businesses = sum(1 for b in businesses if b.to_dict().get('status') == 'public')
        
        # Calculate total market cap
        total_market_cap = 0
        for biz_doc in businesses:
            biz = biz_doc.to_dict()
            if biz.get('status') == 'public':
                share_price = biz.get('currentPrice', biz.get('ipoPrice', 0))
                total_shares = biz.get('totalShares', 0)
                total_market_cap += share_price * total_shares
        
        # Get transaction count (last 7 days)
        week_ago = datetime.now(timezone.utc) - timedelta(days=7)
        recent_transactions = list(db.collection(BANK_TRANSACTIONS_COLLECTION).where(
            filter=FieldFilter('timestamp', '>=', week_ago)
        ).stream())
        weekly_transaction_volume = len(recent_transactions)
        
        # Create the report embed
        embed = discord.Embed(
            title="üìä FLORAB√çS ECONOMIC REPORT",
            description=f"*Comprehensive economic analysis as of {datetime.now(timezone.utc).astimezone(EST).strftime('%B %d, %Y')}*\n",
            color=0xFFD700
        )
        
        # GDP & Money Supply (prevent division by zero)
        state_pct = (state_reserves_value/total_gdp*100) if total_gdp > 0 else 0
        citizen_pct = (citizen_liquidity_value/total_gdp*100) if total_gdp > 0 else 0
        
        embed.add_field(
            name="üí∞ GROSS DOMESTIC PRODUCT",
            value=(
                f"**Total GDP:** {total_gdp:,.2f}d\n"
                f"**State Reserves:** {state_reserves_value:,.2f}d ({state_pct:.1f}%)\n"
                f"**Citizen Liquidity:** {citizen_liquidity_value:,.2f}d ({citizen_pct:.1f}%)"
            ),
            inline=False
        )
        
        # Banking Statistics
        embed.add_field(
            name="üè¶ BANKING SECTOR",
            value=(
                f"**Total Accounts:** {total_accounts}\n"
                f"**Deposits:** {citizen_liquidity_value:,.2f}d\n"
                f"**Richest Account:** {richest_citizen} ({richest_balance:,.1f}d)\n"
                f"**Avg Balance:** {citizen_liquidity_value/max(total_accounts, 1):,.1f}d"
            ),
            inline=True
        )
        
        # Stock Market
        embed.add_field(
            name="üìà STOCK MARKET",
            value=(
                f"**Listed Companies:** {public_businesses}\n"
                f"**Total Businesses:** {total_businesses}\n"
                f"**Market Cap:** {total_market_cap:,.2f}d\n"
                f"**Avg Market Cap:** {total_market_cap/max(public_businesses, 1):,.1f}d"
            ),
            inline=True
        )
        
        # Real Estate Sector
        try:
            properties = list(db.collection(PROPERTIES_COLLECTION).stream())
            total_properties = len(properties)
            
            cycle_data = get_current_economic_cycle()
            total_real_estate_value = 0
            
            for prop_doc in properties:
                prop_data = prop_doc.to_dict()
                prop_value = calculate_property_value(prop_data, cycle_data)
                total_real_estate_value += prop_value
            
            active_mortgages = list(db.collection(MORTGAGES_COLLECTION).where(
                filter=FieldFilter('status', '==', 'active')
            ).stream())
            
            total_mortgage_debt = sum(m.to_dict().get('remainingBalance', 0.0) for m in active_mortgages)
            
            cycle_emoji = {'boom': 'üìà', 'stable': 'üìä', 'recession': 'üìâ'}.get(cycle_data.get('state', 'stable'), 'üìä')
            re_gdp_pct = (total_real_estate_value/total_gdp*100) if total_gdp > 0 else 0
            
            embed.add_field(
                name="üèòÔ∏è REAL ESTATE SECTOR",
                value=(
                    f"**Total Properties:** {total_properties}\n"
                    f"**Total Value:** {total_real_estate_value:,.2f}d ({re_gdp_pct:.1f}% of GDP)\n"
                    f"**Active Mortgages:** {len(active_mortgages)}\n"
                    f"**Mortgage Debt:** {total_mortgage_debt:,.2f}d\n"
                    f"**Market Condition:** {cycle_emoji} {cycle_data.get('state', 'stable').upper()}"
                ),
                inline=False
            )
        except Exception as re_err:
            print(f"[WARN] Real estate data unavailable: {re_err}")
        
        # Economic Activity
        embed.add_field(
            name="üìä ECONOMIC ACTIVITY",
            value=(
                f"**7-Day Transactions:** {weekly_transaction_volume}\n"
                f"**Daily Avg:** {weekly_transaction_volume/7:.1f} txns\n"
                f"**Economic Health:** {'üü¢ Strong' if weekly_transaction_volume > 50 else 'üü° Moderate' if weekly_transaction_volume > 20 else 'üî¥ Weak'}"
            ),
            inline=False
        )
        
        # Commodity Reserves
        embed.add_field(
            name=f"{DIAMOND_EMOJI} COMMODITY BREAKDOWN - CITIZENS",
            value=(
                f"**Diamonds:** {total_diamonds:,.1f}d\n"
                f"**Essence:** {total_essence:,.0f} es\n"
                f"**Iron:** {total_iron:,.0f} ingots\n"
                f"**Gold:** {total_gold:,.0f} ingots"
            ),
            inline=True
        )
        
        embed.add_field(
            name=f"üèõÔ∏è STATE RESERVES",
            value=(
                f"**Diamonds:** {treasury_diamonds:,.1f}d\n"
                f"**Essence:** {treasury_essence:,.0f} ess\n"
                f"**Iron:** {treasury_iron:,.0f} ingots\n"
                f"**Gold:** {treasury_gold:,.0f} ingots\n"
                f"**Emeralds:** {treasury_emeralds:,.0f}"
            ),
            inline=True
        )
        
        embed.set_footer(text="üèõÔ∏è Florab√≠s State Economy | Updated in real-time")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Economic report failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Failed to generate report: {str(e)}")

# ========================================
# STOCK MARKET ENHANCEMENTS (#7)
# ========================================

@market_group.command(name="stock_split", description="[BUSINESS OWNER] Execute a stock split (2:1, 3:1, etc.)")
@app_commands.describe(
    business_name="Your business name",
    split_ratio="Split ratio (e.g., 2 for 2:1 split, 3 for 3:1 split)"
)
async def stock_split(interaction: discord.Interaction, business_name: str, split_ratio: int):
    await interaction.response.send_message("‚è≥ Processing stock split...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if split_ratio < 2 or split_ratio > 10:
        return await interaction.edit_original_response(content="‚ùå Split ratio must be between 2 and 10.")
    
    try:
        # Find the business
        businesses = db.collection(BUSINESSES_COLLECTION).where(filter=FieldFilter('name', '==', business_name)).limit(1).stream()
        business_doc = None
        business_data = None
        
        for doc in businesses:
            business_doc = doc
            business_data = doc.to_dict()
            break
        
        if not business_data:
            return await interaction.edit_original_response(content=f"‚ùå Business `{business_name}` not found.")
        
        # Check ownership
        if business_data.get('ownerId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå Only the business owner can execute a stock split.")
        
        # Get current values
        current_price = business_data.get('currentPrice', business_data.get('ipoPrice', 0))
        total_shares = business_data.get('totalShares', 0)
        
        # Calculate new values
        new_price = current_price / split_ratio
        new_total_shares = total_shares * split_ratio
        
        # Update all shareholders' shares
        shareholders = business_data.get('shareholders', {})
        updated_shareholders = {}
        for holder_id, shares in shareholders.items():
            updated_shareholders[holder_id] = shares * split_ratio
        
        # ATOMIC UPDATE: Update both business data and shareholders in a single operation
        business_doc.reference.update({
            'currentPrice': new_price,
            'totalShares': new_total_shares,
            'ipoPrice': new_price,  # Update IPO price to reflect split
            'lastSplit': datetime.now(timezone.utc),
            'splitRatio': split_ratio,
            'shareholders': updated_shareholders  # Update shareholders atomically
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Stock Split Executed!**\n\n"
            f"**Business:** {business_name}\n"
            f"**Split Ratio:** {split_ratio}:1\n\n"
            f"**Previous:**\n"
            f"‚Ä¢ Share Price: {current_price:.2f}d\n"
            f"‚Ä¢ Total Shares: {total_shares:,}\n\n"
            f"**New:**\n"
            f"‚Ä¢ Share Price: {new_price:.2f}d\n"
            f"‚Ä¢ Total Shares: {new_total_shares:,}\n\n"
            f"All shareholders have received {split_ratio}x their previous shares!"
        )
        
        print(f"[OK] Stock split executed for {business_name}: {split_ratio}:1")
        
    except Exception as e:
        print(f"[ERR] Stock split failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@market_group.command(name="leaderboard", description="üìä View top companies by market capitalization")
async def market_cap_leaderboard(interaction: discord.Interaction):
    await interaction.response.send_message("üìä Loading market cap leaderboard...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        businesses = list(db.collection(BUSINESSES_COLLECTION).stream())
        
        # Calculate market cap for each public business
        market_caps = []
        for biz_doc in businesses:
            biz = biz_doc.to_dict()
            if biz.get('status') == 'public':
                share_price = biz.get('currentPrice', biz.get('ipoPrice', 0))
                total_shares = biz.get('totalShares', 0)
                market_cap = share_price * total_shares
                
                market_caps.append({
                    'name': biz.get('name', 'Unknown'),
                    'marketCap': market_cap,
                    'sharePrice': share_price,
                    'totalShares': total_shares,
                    'symbol': biz.get('symbol', '???')
                })
        
        if not market_caps:
            return await interaction.edit_original_response(content="üìä No public companies listed yet.")
        
        # Sort by market cap (highest first)
        market_caps.sort(key=lambda x: x['marketCap'], reverse=True)
        
        # Create leaderboard
        leaderboard_text = []
        for i, company in enumerate(market_caps[:10], 1):  # Top 10
            medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"**{i}.**"
            leaderboard_text.append(
                f"{medal} **{company['name']}** ({company['symbol']})\n"
                f"   üí∞ Market Cap: {company['marketCap']:,.2f}d | "
                f"üìà Price: {company['sharePrice']:.2f}d | "
                f"üìä Shares: {company['totalShares']:,}\n"
            )
        
        total_market_cap = sum(c['marketCap'] for c in market_caps)
        
        embed = discord.Embed(
            title="üìä MARKET CAPITALIZATION LEADERBOARD",
            description=f"*Top companies by total market value*\n\n" + "\n".join(leaderboard_text),
            color=0x00FF00
        )
        
        embed.add_field(
            name="üìà MARKET STATISTICS",
            value=(
                f"**Total Market Cap:** {total_market_cap:,.2f}d\n"
                f"**Listed Companies:** {len(market_caps)}\n"
                f"**Avg Market Cap:** {total_market_cap/len(market_caps):,.2f}d"
            ),
            inline=False
        )
        
        embed.set_footer(text="üèõÔ∏è Florab√≠s Stock Exchange | Real-time market data")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] Market cap leaderboard failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

# ========================================
# PROPERTY/LAND REGISTRY SYSTEM (#4)
# ========================================

@property_group.command(name="register", description="üèòÔ∏è Register a property in the land registry")
@app_commands.describe(
    property_name="Name of the property (e.g., 'Town Hall', 'Farm #3')",
    x_coord="X coordinate",
    y_coord="Y coordinate (height)",
    z_coord="Z coordinate",
    property_type="Type of property",
    description="Description of the property (optional)"
)
@app_commands.choices(property_type=[
    app_commands.Choice(name="Residential", value="residential"),
    app_commands.Choice(name="Commercial", value="commercial"),
    app_commands.Choice(name="Industrial", value="industrial"),
    app_commands.Choice(name="Agricultural", value="agricultural"),
    app_commands.Choice(name="Government", value="government"),
    app_commands.Choice(name="Public", value="public")
])
async def register_property(
    interaction: discord.Interaction,
    property_name: str,
    x_coord: int,
    y_coord: int,
    z_coord: int,
    property_type: str,
    description: str = ""
):
    await interaction.response.send_message("üèòÔ∏è Registering property...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before property registration
    await ensure_firestore()
    
    # Check if user is a citizen
    if not is_citizen(interaction.user.id):
        return await interaction.edit_original_response(content="‚ùå Only citizens can register property.")
    
    try:
        # Check if property name already exists
        existing = list(db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('name', '==', property_name)
        ).limit(1).stream())
        
        if existing:
            return await interaction.edit_original_response(content=f"‚ùå Property name `{property_name}` is already registered.")
        
        # Generate property ID
        import random
        import string
        property_id = f"PROP-{''.join(random.choices(string.ascii_uppercase + string.digits, k=6))}"
        
        # Calculate base property value based on type
        base_values = {
            'residential': 100.0,
            'commercial': 250.0,
            'industrial': 400.0,
            'agricultural': 150.0,
            'government': 500.0,
            'public': 300.0
        }
        base_value = base_values.get(property_type, 100.0)
        current_value = base_value
        
        # Register the property
        _, property_ref = db.collection(PROPERTIES_COLLECTION).add({
            'propertyId': property_id,
            'name': property_name,
            'ownerId': interaction.user.id,
            'ownerName': str(interaction.user),
            'coordinates': {
                'x': x_coord,
                'y': y_coord,
                'z': z_coord
            },
            'type': property_type,
            'description': description,
            'registeredAt': datetime.now(timezone.utc),
            'jurisdiction': jurisdiction,
            'status': 'active',
            'baseValue': base_value,
            'currentValue': current_value,
            'purchasePrice': base_value,
            'lastAppraisal': datetime.now(timezone.utc)
        })
        
        # Record initial property value in history
        db.collection(PROPERTY_VALUES_COLLECTION).add({
            'propertyId': property_id,
            'value': base_value,
            'timestamp': datetime.now(timezone.utc),
            'changeReason': 'initial_registration',
            'marketCondition': 'stable'
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Property Registered Successfully!**\n\n"
            f"**Property ID:** {property_id}\n"
            f"**Name:** {property_name}\n"
            f"**Type:** {property_type.title()}\n"
            f"**Location:** ({x_coord}, {y_coord}, {z_coord})\n"
            f"**Owner:** {interaction.user.mention}\n\n"
            f"{'üìù Description: ' + description if description else ''}"
        )
        
        print(f"[OK] Property registered: {property_name} at ({x_coord}, {y_coord}, {z_coord}) by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Property registration failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="transfer", description="üìù Transfer property ownership to another citizen")
@app_commands.describe(
    property_id="Property ID to transfer",
    new_owner="The citizen receiving the property"
)
async def transfer_property(interaction: discord.Interaction, property_id: str, new_owner: discord.Member):
    await interaction.response.send_message("üìù Processing property transfer...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before transfer
    await ensure_firestore()
    
    # Check if new owner is a citizen
    if not is_citizen(new_owner.id):
        return await interaction.edit_original_response(content=f"‚ùå {new_owner.mention} is not a registered citizen.")
    
    try:
        # Find the property
        properties = db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        property_doc = None
        property_data = None
        
        for doc in properties:
            property_doc = doc
            property_data = doc.to_dict()
            break
        
        if not property_data:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` not found.")
        
        # Check ownership
        if property_data.get('ownerId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå You don't own this property.")
        
        # Transfer ownership
        property_doc.reference.update({
            'ownerId': new_owner.id,
            'ownerName': str(new_owner),
            'lastTransfer': datetime.now(timezone.utc),
            'previousOwner': interaction.user.id
        })
        
        property_name = property_data.get('name', 'Unknown')
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Property Transfer Complete!**\n\n"
            f"**Property:** {property_name} ({property_id})\n"
            f"**Previous Owner:** {interaction.user.mention}\n"
            f"**New Owner:** {new_owner.mention}\n\n"
            f"Ownership has been successfully transferred!"
        )
        
        print(f"[OK] Property {property_id} transferred from {interaction.user} to {new_owner}")
        
    except Exception as e:
        print(f"[ERR] Property transfer failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

class PropertyListView(ui.View):
    def __init__(self, properties, filter_type="all", page=0, items_per_page=5):
        super().__init__(timeout=300)
        self.properties = properties
        self.filter_type = filter_type
        self.page = page
        self.items_per_page = items_per_page
        self.total_pages = max(1, (len(properties) + items_per_page - 1) // items_per_page)
        
        # Disable buttons if only one page
        if self.total_pages == 1:
            self.previous_button.disabled = True
            self.next_button.disabled = True
        elif self.page == 0:
            self.previous_button.disabled = True
        elif self.page >= self.total_pages - 1:
            self.next_button.disabled = True
    
    def build_embed(self):
        start_idx = self.page * self.items_per_page
        end_idx = start_idx + self.items_per_page
        page_properties = self.properties[start_idx:end_idx]
        
        property_list = []
        type_counts = {}
        
        for prop_doc in page_properties:
            prop = prop_doc.to_dict()
            coords = prop.get('coordinates', {})
            prop_type = prop.get('type', 'unknown')
            
            # Count by type (for current page)
            type_counts[prop_type] = type_counts.get(prop_type, 0) + 1
            
            property_list.append(
                f"üèòÔ∏è **{prop.get('name')}** ({prop.get('propertyId')})\n"
                f"   üìç ({coords.get('x')}, {coords.get('y')}, {coords.get('z')}) | "
                f"üè∑Ô∏è {prop_type.title()} | üë§ <@{prop.get('ownerId')}>"
            )
        
        filter_title = f"{self.filter_type.upper()} " if self.filter_type != "all" else ""
        
        embed = discord.Embed(
            title=f"üèòÔ∏è {filter_title}PROPERTY REGISTRY",
            description="\n\n".join(property_list) if property_list else "No properties to display.",
            color=0x3498db
        )
        
        embed.set_footer(text=f"Page {self.page + 1}/{self.total_pages} ‚Ä¢ Total: {len(self.properties)} properties")
        
        return embed
    
    @ui.button(label="‚óÄ Previous", style=discord.ButtonStyle.secondary)
    async def previous_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer()
        self.page = max(0, self.page - 1)
        
        # Update button states
        self.previous_button.disabled = (self.page == 0)
        self.next_button.disabled = False
        
        await interaction.edit_original_response(embed=self.build_embed(), view=self)
    
    @ui.button(label="Next ‚ñ∂", style=discord.ButtonStyle.secondary)
    async def next_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer()
        self.page = min(self.total_pages - 1, self.page + 1)
        
        # Update button states
        self.next_button.disabled = (self.page >= self.total_pages - 1)
        self.previous_button.disabled = False
        
        await interaction.edit_original_response(embed=self.build_embed(), view=self)

@property_group.command(name="list", description="üìã View all registered properties")
@app_commands.describe(
    filter_type="Filter by property type (optional)"
)
@app_commands.choices(filter_type=[
    app_commands.Choice(name="All Properties", value="all"),
    app_commands.Choice(name="Residential", value="residential"),
    app_commands.Choice(name="Commercial", value="commercial"),
    app_commands.Choice(name="Industrial", value="industrial"),
    app_commands.Choice(name="Agricultural", value="agricultural"),
    app_commands.Choice(name="Government", value="government"),
    app_commands.Choice(name="Public", value="public")
])
async def list_properties(interaction: discord.Interaction, filter_type: str = "all"):
    await interaction.response.send_message("üìã Loading properties...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before listing
    await ensure_firestore()
    
    try:
        # Get properties
        if filter_type == "all":
            properties = list(db.collection(PROPERTIES_COLLECTION).stream())
        else:
            properties = list(db.collection(PROPERTIES_COLLECTION).where(
                filter=FieldFilter('type', '==', filter_type)
            ).stream())
        
        if not properties:
            filter_text = f"{filter_type} " if filter_type != "all" else ""
            return await interaction.edit_original_response(content=f"üìã No {filter_text}properties registered yet.")
        
        # Create paginated view (5 properties per page)
        view = PropertyListView(properties, filter_type, page=0, items_per_page=5)
        embed = view.build_embed()
        
        await interaction.edit_original_response(embed=embed, view=view)
        
    except Exception as e:
        print(f"[ERR] List properties failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="my_properties", description="üè† View properties you own")
async def my_properties(interaction: discord.Interaction):
    await interaction.response.send_message("üè† Loading your properties...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before querying
    await ensure_firestore()
    
    try:
        properties = list(db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('ownerId', '==', interaction.user.id)
        ).stream())
        
        if not properties:
            return await interaction.edit_original_response(content="üè† You don't own any registered properties yet.\n\nüí° Use `/property register` to register your first property!")
        
        property_list = []
        for prop_doc in properties:
            prop = prop_doc.to_dict()
            coords = prop.get('coordinates', {})
            
            property_list.append(
                f"üèòÔ∏è **{prop.get('name')}** ({prop.get('propertyId')})\n"
                f"   üìç ({coords.get('x')}, {coords.get('y')}, {coords.get('z')})\n"
                f"   üè∑Ô∏è Type: {prop.get('type', 'unknown').title()}"
            )
        
        embed = discord.Embed(
            title=f"üè† YOUR PROPERTIES ({len(properties)})",
            description="\n\n".join(property_list),
            color=0x2ecc71
        )
        
        embed.set_footer(text=f"You own {len(properties)} {'property' if len(properties) == 1 else 'properties'}")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] My properties failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

# ========================================
# PROPERTY MARKETPLACE SYSTEM
# ========================================

@property_group.command(name="list_for_sale", description="üí∞ List your property for sale on the marketplace")
@app_commands.describe(
    property_id="Property ID to sell",
    price="Sale price in diamonds"
)
async def list_for_sale(interaction: discord.Interaction, property_id: str, price: float):
    await interaction.response.send_message("üí∞ Listing property for sale...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before multiple queries
    await ensure_firestore()
    
    if price <= 0:
        return await interaction.edit_original_response(content="‚ùå Price must be greater than 0 diamonds.")
    
    try:
        # Find the property
        properties = db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        property_doc = None
        property_data = None
        
        for doc in properties:
            property_doc = doc
            property_data = doc.to_dict()
            break
        
        if not property_data:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` not found.")
        
        # Check ownership
        if property_data.get('ownerId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå You don't own this property.")
        
        # Check if already listed
        existing_listings = list(db.collection(PROPERTY_LISTINGS_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream())
        
        if existing_listings:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` is already listed for sale.\n\nüí° Use `/property unlist {property_id}` to remove the listing first.")
        
        # Create listing
        db.collection(PROPERTY_LISTINGS_COLLECTION).add({
            'propertyId': property_id,
            'propertyName': property_data.get('name'),
            'sellerId': interaction.user.id,
            'sellerName': str(interaction.user),
            'price': price,
            'listedAt': datetime.now(timezone.utc),
            'jurisdiction': jurisdiction,
            'status': 'active',
            'propertyType': property_data.get('type'),
            'coordinates': property_data.get('coordinates'),
            'description': property_data.get('description', '')
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Property Listed for Sale!**\n\n"
            f"**Property:** {property_data.get('name')} ({property_id})\n"
            f"**Sale Price:** {DIAMOND_EMOJI} **{price:,.2f} diamonds**\n"
            f"**Listed By:** {interaction.user.mention}\n\n"
            f"Your property is now visible on `/property marketplace`!"
        )
        
        print(f"[OK] Property {property_id} listed for sale at {price}d by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] List for sale failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="unlist", description="üö´ Remove your property from the marketplace")
@app_commands.describe(
    property_id="Property ID to unlist"
)
async def unlist_property(interaction: discord.Interaction, property_id: str):
    await interaction.response.send_message("üö´ Removing listing...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before unlisting
    await ensure_firestore()
    
    try:
        # Find the listing
        listings = db.collection(PROPERTY_LISTINGS_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        listing_doc = None
        listing_data = None
        
        for doc in listings:
            listing_doc = doc
            listing_data = doc.to_dict()
            break
        
        if not listing_data:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` is not listed for sale.")
        
        # Check ownership
        if listing_data.get('sellerId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå You don't own this listing.")
        
        # Delete the listing
        listing_doc.reference.delete()
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Listing Removed!**\n\n"
            f"**Property:** {listing_data.get('propertyName')} ({property_id})\n"
            f"Your property has been removed from the marketplace."
        )
        
        print(f"[OK] Property {property_id} unlisted by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Unlist property failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

class MarketplaceView(ui.View):
    def __init__(self, listings, page=0, items_per_page=3):
        super().__init__(timeout=300)
        self.listings = listings
        self.page = page
        self.items_per_page = items_per_page
        self.total_pages = max(1, (len(listings) + items_per_page - 1) // items_per_page)
        
        # Disable buttons if only one page
        if self.total_pages == 1:
            self.previous_button.disabled = True
            self.next_button.disabled = True
        elif self.page == 0:
            self.previous_button.disabled = True
        elif self.page >= self.total_pages - 1:
            self.next_button.disabled = True
    
    def build_embed(self):
        start_idx = self.page * self.items_per_page
        end_idx = start_idx + self.items_per_page
        page_listings = self.listings[start_idx:end_idx]
        
        cycle_data = get_current_economic_cycle()
        cycle_emoji = {'boom': 'üìà', 'stable': 'üìä', 'recession': 'üìâ'}.get(cycle_data.get('state', 'stable'), 'üìä')
        
        embed = discord.Embed(
            title="üè™ PROPERTY MARKETPLACE",
            description=(
                f"*Buy properties directly with diamonds from your bank account*\n"
                f"{cycle_emoji} **Market Conditions:** {cycle_data.get('state', 'stable').upper()} ({cycle_data.get('multiplier', 1.0):.2f}x)\n\n"
            ),
            color=0xFFD700
        )
        
        for listing_doc in page_listings:
            listing = listing_doc.to_dict()
            coords = listing.get('coordinates', {})
            property_id = listing.get('propertyId')
            listing_price = listing.get('price', 0)
            
            try:
                if db:
                    properties = db.collection(PROPERTIES_COLLECTION).where(
                        filter=FieldFilter('propertyId', '==', property_id)
                    ).limit(1).stream()
                    
                    for prop_doc in properties:
                        prop_data = prop_doc.to_dict()
                        current_market_value = calculate_property_value(prop_data, cycle_data)
                        
                        price_diff = listing_price - current_market_value
                        price_diff_pct = (price_diff / current_market_value * 100) if current_market_value > 0 else 0
                        
                        if price_diff < -10:
                            value_indicator = f"üî• **Great Deal!** ({abs(price_diff_pct):.0f}% below market)"
                        elif price_diff > 10:
                            value_indicator = f"üìà Above Market (+{price_diff_pct:.0f}%)"
                        else:
                            value_indicator = f"‚úÖ Fair Price ({abs(price_diff_pct):.0f}% {'below' if price_diff < 0 else 'above'} market)"
                        
                        break
                else:
                    current_market_value = None
                    value_indicator = ""
            except:
                current_market_value = None
                value_indicator = ""
            
            field_value = (
                f"**Seller:** <@{listing.get('sellerId')}>\n"
                f"**List Price:** {DIAMOND_EMOJI} **{listing_price:,.2f}d**\n"
            )
            
            if current_market_value:
                field_value += f"**Market Value:** {DIAMOND_EMOJI} {current_market_value:,.2f}d\n"
                if value_indicator:
                    field_value += f"{value_indicator}\n"
            
            field_value += (
                f"**Type:** {listing.get('propertyType', 'Unknown').title()}\n"
                f"**Location:** ({coords.get('x')}, {coords.get('y')}, {coords.get('z')})\n"
                f"**Property ID:** `{property_id}`\n"
            )
            
            if listing.get('description'):
                field_value += f"üìù {listing.get('description')[:100]}\n"
            
            field_value += f"\nüí° Use `/property buy {property_id}` to purchase"
            if current_market_value:
                field_value += f"\nüí° Use `/property appraise {property_id}` for full appraisal"
            
            embed.add_field(
                name=f"üèòÔ∏è {listing.get('propertyName')}",
                value=field_value,
                inline=False
            )
        
        if not page_listings:
            embed.description += "No properties currently for sale."
        
        embed.set_footer(text=f"Page {self.page + 1}/{self.total_pages} ‚Ä¢ {len(self.listings)} properties for sale")
        
        return embed
    
    @ui.button(label="‚óÄ Previous", style=discord.ButtonStyle.secondary)
    async def previous_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer()
        self.page = max(0, self.page - 1)
        
        # Update button states
        self.previous_button.disabled = (self.page == 0)
        self.next_button.disabled = False
        
        await interaction.edit_original_response(embed=self.build_embed(), view=self)
    
    @ui.button(label="Next ‚ñ∂", style=discord.ButtonStyle.secondary)
    async def next_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer()
        self.page = min(self.total_pages - 1, self.page + 1)
        
        # Update button states
        self.next_button.disabled = (self.page >= self.total_pages - 1)
        self.previous_button.disabled = False
        
        await interaction.edit_original_response(embed=self.build_embed(), view=self)

@property_group.command(name="marketplace", description="üè™ View all properties for sale")
async def marketplace(interaction: discord.Interaction):
    await interaction.response.send_message("üè™ Loading marketplace...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before heavy query
    await ensure_firestore()
    
    try:
        # Get all active listings
        listings = list(db.collection(PROPERTY_LISTINGS_COLLECTION).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream())
        
        if not listings:
            return await interaction.edit_original_response(content=
                "üè™ **Property Marketplace**\n\n"
                "No properties currently for sale.\n\n"
                "üí° List your property with `/property list_for_sale`"
            )
        
        # Create paginated view (3 properties per page for better visibility)
        view = MarketplaceView(listings, page=0, items_per_page=3)
        embed = view.build_embed()
        
        await interaction.edit_original_response(embed=embed, view=view)
        
    except Exception as e:
        print(f"[ERR] Marketplace failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="buy", description="Purchase a property from the marketplace")
@app_commands.describe(
    property_id="Property ID to purchase"
)
async def buy_property(interaction: discord.Interaction, property_id: str):
    await interaction.response.send_message(f"{DIAMOND_EMOJI} Processing purchase...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before complex atomic transaction
    await ensure_firestore()
    
    # Check if user is a citizen
    if not is_citizen(interaction.user.id):
        return await interaction.edit_original_response(content="‚ùå Only citizens can purchase property.")
    
    try:
        # Find the listing
        listings = db.collection(PROPERTY_LISTINGS_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        listing_doc = None
        listing_data = None
        
        for doc in listings:
            listing_doc = doc
            listing_data = doc.to_dict()
            break
        
        if not listing_data:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` is not listed for sale.\n\nüí° View available properties with `/property marketplace`")
        
        if listing_data.get('status') != 'active':
            return await interaction.edit_original_response(content="‚ùå This listing is no longer active.")
        
        # Prevent buying your own property
        if listing_data.get('sellerId') == interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå You cannot buy your own property!")
        
        price = listing_data.get('price', 0)
        seller_id = listing_data.get('sellerId')
        
        # Get buyer's bank account
        buyer_accounts = db.collection(BANK_ACCOUNTS_COLLECTION).where(
            filter=FieldFilter('userId', '==', interaction.user.id)
        ).limit(1).stream()
        
        buyer_account_doc = None
        buyer_account_data = None
        
        for doc in buyer_accounts:
            buyer_account_doc = doc
            buyer_account_data = doc.to_dict()
            break
        
        if not buyer_account_data:
            return await interaction.edit_original_response(content="‚ùå You don't have a bank account.\n\nüí° Use `/bank account` to create one.")
        
        buyer_balance = buyer_account_data.get('diamondBalance', buyer_account_data.get('balance', 0.0))
        
        # Check if buyer has enough diamonds
        if buyer_balance < price:
            return await interaction.edit_original_response(content=
                f"‚ùå **Insufficient Funds!**\n\n"
                f"**Required:** {DIAMOND_EMOJI} {price:,.2f}d\n"
                f"**Your Balance:** {DIAMOND_EMOJI} {buyer_balance:,.2f}d\n"
                f"**Short:** {DIAMOND_EMOJI} {price - buyer_balance:,.2f}d\n\n"
                f"üí° Deposit more diamonds to your bank account"
            )
        
        # Get seller's bank account
        seller_accounts = db.collection(BANK_ACCOUNTS_COLLECTION).where(
            filter=FieldFilter('userId', '==', seller_id)
        ).limit(1).stream()
        
        seller_account_doc = None
        seller_account_data = None
        
        for doc in seller_accounts:
            seller_account_doc = doc
            seller_account_data = doc.to_dict()
            break
        
        if not seller_account_data:
            return await interaction.edit_original_response(content="‚ùå Seller doesn't have a bank account. Transaction cannot proceed.")
        
        # Find the property
        properties = db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        property_doc = None
        property_data = None
        
        for doc in properties:
            property_doc = doc
            property_data = doc.to_dict()
            break
        
        if not property_data:
            return await interaction.edit_original_response(content="‚ùå Property record not found.")
        
        # ATOMIC TRANSACTION: Transfer diamonds and property ownership
        now_utc = datetime.now(timezone.utc)
        
        # Get document references for atomic transaction
        buyer_account_ref = buyer_account_doc.reference
        seller_account_ref = seller_account_doc.reference
        property_ref = property_doc.reference
        listing_ref = listing_doc.reference
        
        # Define atomic transaction function
        @firestore.transactional
        def execute_property_purchase(transaction):
            # Re-check listing status inside transaction (prevent double-sale)
            listing_snapshot = listing_ref.get(transaction=transaction)
            if not listing_snapshot.exists or listing_snapshot.to_dict().get('status') != 'active':
                raise ValueError("Listing is no longer active or was already sold")
            
            # Re-check buyer balance inside transaction (prevent insufficient funds race)
            buyer_snapshot = buyer_account_ref.get(transaction=transaction)
            current_buyer_balance = buyer_snapshot.to_dict().get('diamondBalance', buyer_snapshot.to_dict().get('balance', 0.0))
            if current_buyer_balance < price:
                raise ValueError(f"Insufficient funds: need {price}d, have {current_buyer_balance}d")
            
            # Re-check seller account exists
            seller_snapshot = seller_account_ref.get(transaction=transaction)
            if not seller_snapshot.exists:
                raise ValueError("Seller account no longer exists")
            current_seller_balance = seller_snapshot.to_dict().get('diamondBalance', seller_snapshot.to_dict().get('balance', 0.0))
            
            # Re-check property ownership (prevent double-transfer)
            property_snapshot = property_ref.get(transaction=transaction)
            if not property_snapshot.exists:
                raise ValueError("Property no longer exists")
            current_property_data = property_snapshot.to_dict()
            if current_property_data.get('ownerId') != seller_id:
                raise ValueError("Property ownership changed during transaction")
            
            # Calculate new balances
            new_buyer_balance = current_buyer_balance - price
            new_seller_balance = current_seller_balance + price
            
            # Atomically update all records
            transaction.update(buyer_account_ref, {'diamondBalance': new_buyer_balance})
            transaction.update(seller_account_ref, {'diamondBalance': new_seller_balance})
            transaction.update(property_ref, {
                'ownerId': interaction.user.id,
                'ownerName': str(interaction.user),
                'lastTransfer': now_utc,
                'previousOwner': seller_id,
                'purchasePrice': price
            })
            transaction.delete(listing_ref)
            
            return new_buyer_balance, new_seller_balance
        
        # Execute the atomic transaction
        try:
            new_buyer_balance, new_seller_balance = db.transaction(execute_property_purchase)
        except ValueError as ve:
            return await interaction.edit_original_response(content=f"‚ùå Transaction failed: {ve}")
        
        # Record transactions (outside atomic block since they're audit logs)
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': interaction.user.id,
            'type': 'property_purchase',
            'amount': -price,
            'commodity': 'diamonds',
            'timestamp': now_utc,
            'memo': f"Property purchase: {listing_data.get('propertyName')} ({property_id})",
            'balanceAfter': new_buyer_balance
        })
        
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': seller_id,
            'type': 'property_sale',
            'amount': price,
            'commodity': 'diamonds',
            'timestamp': now_utc,
            'memo': f"Property sale: {listing_data.get('propertyName')} ({property_id})",
            'balanceAfter': new_seller_balance
        })
        
        # Notify both parties
        property_name = property_data.get('name', 'Unknown')
        coords = property_data.get('coordinates', {})
        
        await interaction.edit_original_response(content=
            f"‚úÖ **PROPERTY PURCHASE COMPLETE!**\n\n"
            f"**Property:** {property_name} ({property_id})\n"
            f"**Location:** ({coords.get('x')}, {coords.get('y')}, {coords.get('z')})\n"
            f"**Purchase Price:** {DIAMOND_EMOJI} **{price:,.2f}d**\n"
            f"**Previous Owner:** <@{seller_id}>\n"
            f"**New Owner:** {interaction.user.mention}\n\n"
            f"**Your New Balance:** {DIAMOND_EMOJI} {new_buyer_balance:,.2f}d\n\n"
            f"üéâ Congratulations on your new property!"
        )
        
        # Try to notify seller
        try:
            seller = await bot.fetch_user(seller_id)
            if seller:
                await seller.send(
                    f"üí∞ **PROPERTY SOLD!**\n\n"
                    f"Your property **{property_name}** ({property_id}) has been sold!\n\n"
                    f"**Buyer:** {interaction.user.mention}\n"
                    f"**Sale Price:** {DIAMOND_EMOJI} **{price:,.2f}d**\n"
                    f"**Your New Balance:** {DIAMOND_EMOJI} {new_seller_balance:,.2f}d\n\n"
                    f"üíµ Diamonds have been deposited to your bank account."
                )
        except:
            pass  # Seller may have DMs disabled
        
        # Bancquero Financial Oversight: Log property sale
        if interaction.guild and BANCQUERO_ROLE_ID and price >= 100.0:
            # Check if Bancquero role exists before mentioning (prevents @unknown)
            bancquero_role = interaction.guild.get_role(BANCQUERO_ROLE_ID)
            if bancquero_role:
                # Notify Bancquero for significant property transactions (‚â•100d)
                try:
                    bancquero_channel = interaction.channel
                    await bancquero_channel.send(
                        f"üíº <@&{BANCQUERO_ROLE_ID}> **Property Sale Transaction**\n\n"
                        f"**Property:** {property_name} ({property_id})\n"
                        f"**Sale Price:** {DIAMOND_EMOJI} **{price:,.2f}d**\n"
                        f"**Seller:** <@{seller_id}> ‚Üí Balance: {new_seller_balance:,.2f}d\n"
                        f"**Buyer:** {interaction.user.mention} ‚Üí Balance: {new_buyer_balance:,.2f}d\n"
                        f"**Location:** ({coords.get('x')}, {coords.get('y')}, {coords.get('z')})\n\n"
                        f"*Automatic financial oversight notification*"
                    )
                except:
                    pass  # Channel might not allow messages
        
        print(f"[OK] Property {property_id} sold from User {seller_id} to {interaction.user} for {price}d")
        
    except Exception as e:
        print(f"[ERR] Property purchase failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

# ========================================
# HOUSING ECONOMY SYSTEM - Property Values, Boom/Bust Cycles, Mortgages
# ========================================

def get_current_economic_cycle():
    """Get the current economic cycle state (boom/stable/recession)"""
    if not db:
        return {'state': 'stable', 'multiplier': 1.0}
    
    try:
        cycles = list(db.collection(ECONOMIC_CYCLES_COLLECTION).order_by('timestamp', direction=firestore.Query.DESCENDING).limit(1).stream())
        
        if cycles:
            cycle_data = cycles[0].to_dict()
            return {
                'state': cycle_data.get('state', 'stable'),
                'multiplier': cycle_data.get('multiplier', 1.0),
                'startDate': cycle_data.get('timestamp'),
                'description': cycle_data.get('description', '')
            }
        else:
            return {'state': 'stable', 'multiplier': 1.0}
    except Exception as e:
        print(f"[ERR] Failed to get economic cycle: {e}")
        return {'state': 'stable', 'multiplier': 1.0}

def calculate_property_value(property_data, cycle_data=None):
    """Calculate current property value based on base value, improvements, and economic cycle"""
    if cycle_data is None:
        cycle_data = get_current_economic_cycle()
    
    base_value = property_data.get('baseValue', 100.0)
    improvements_value = property_data.get('improvementsValue', 0.0)
    
    cycle_multiplier = cycle_data.get('multiplier', 1.0)
    
    property_type = property_data.get('type', 'residential')
    type_multipliers = {
        'residential': 1.0,
        'commercial': 1.2,
        'industrial': 0.9,
        'agricultural': 0.8,
        'government': 1.5,
        'public': 1.1
    }
    type_multiplier = type_multipliers.get(property_type, 1.0)
    
    days_owned = 0
    if 'registeredAt' in property_data:
        registered_at = property_data['registeredAt']
        if hasattr(registered_at, 'timestamp'):
            registered_at = registered_at.replace(tzinfo=timezone.utc)
        else:
            registered_at = datetime.fromtimestamp(registered_at, tz=timezone.utc)
        days_owned = (datetime.now(timezone.utc) - registered_at).days
    
    appreciation_rate = 0.001
    appreciation_multiplier = 1.0 + (appreciation_rate * days_owned)
    
    current_value = (base_value + improvements_value) * type_multiplier * cycle_multiplier * appreciation_multiplier
    
    return max(current_value, base_value * 0.3)

@property_group.command(name="appraise", description="üìä Get current market value of a property")
@app_commands.describe(
    property_id="Property ID to appraise"
)
async def appraise_property(interaction: discord.Interaction, property_id: str):
    await interaction.response.send_message("üìä Appraising property...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before queries
    await ensure_firestore()
    
    try:
        properties = db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        property_doc = None
        property_data = None
        
        for doc in properties:
            property_doc = doc
            property_data = doc.to_dict()
            break
        
        if not property_data:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` not found.")
        
        cycle_data = get_current_economic_cycle()
        current_value = calculate_property_value(property_data, cycle_data)
        
        purchase_price = property_data.get('purchasePrice', property_data.get('baseValue', 100.0))
        value_change = current_value - purchase_price
        value_change_pct = (value_change / purchase_price) * 100 if purchase_price > 0 else 0
        
        value_history = list(db.collection(PROPERTY_VALUES_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).order_by('timestamp', direction=firestore.Query.DESCENDING).limit(10).stream())
        
        property_doc.reference.update({
            'currentValue': current_value,
            'lastAppraisal': datetime.now(timezone.utc)
        })
        
        cycle_indicator = {
            'boom': 'üìà BOOM (Prices Rising)',
            'stable': 'üìä STABLE (Normal Market)',
            'recession': 'üìâ RECESSION (Prices Falling)'
        }.get(cycle_data.get('state', 'stable'), 'üìä STABLE')
        
        change_indicator = "üìà" if value_change > 0 else "üìâ" if value_change < 0 else "‚û°Ô∏è"
        
        embed = discord.Embed(
            title=f"üìä Property Appraisal Report",
            description=f"**{property_data.get('name')}** ({property_id})",
            color=0x00C853 if value_change > 0 else 0xE53935 if value_change < 0 else 0x757575
        )
        
        embed.add_field(
            name=f"{DIAMOND_EMOJI} Current Market Value",
            value=f"**{DIAMOND_EMOJI} {current_value:,.2f}d**",
            inline=True
        )
        
        embed.add_field(
            name="üìÖ Purchase Price",
            value=f"{DIAMOND_EMOJI} {purchase_price:,.2f}d",
            inline=True
        )
        
        embed.add_field(
            name=f"{change_indicator} Value Change",
            value=f"{'+' if value_change > 0 else ''}{value_change:,.2f}d ({'+' if value_change_pct > 0 else ''}{value_change_pct:.1f}%)",
            inline=True
        )
        
        embed.add_field(
            name="üèòÔ∏è Property Details",
            value=(
                f"**Type:** {property_data.get('type', 'unknown').title()}\n"
                f"**Location:** ({property_data.get('coordinates', {}).get('x')}, "
                f"{property_data.get('coordinates', {}).get('y')}, "
                f"{property_data.get('coordinates', {}).get('z')})\n"
                f"**Owner:** <@{property_data.get('ownerId')}>"
            ),
            inline=False
        )
        
        embed.add_field(
            name="üìä Market Conditions",
            value=f"{cycle_indicator}\nMultiplier: {cycle_data.get('multiplier', 1.0):.2f}x",
            inline=False
        )
        
        if property_data.get('improvementsValue', 0) > 0:
            embed.add_field(
                name="üèóÔ∏è Improvements",
                value=f"+{DIAMOND_EMOJI} {property_data.get('improvementsValue'):,.2f}d value added",
                inline=False
            )
        
        if value_history:
            trend_text = ""
            for i, vh in enumerate(value_history[:5]):
                vh_data = vh.to_dict()
                vh_timestamp = vh_data.get('timestamp')
                if hasattr(vh_timestamp, 'strftime'):
                    date_str = vh_timestamp.strftime('%b %d')
                else:
                    date_str = "Unknown"
                trend_text += f"{date_str}: {DIAMOND_EMOJI} {vh_data.get('value', 0):,.1f}d\n"
            
            embed.add_field(
                name="üìà Recent Value History",
                value=trend_text or "No history available",
                inline=False
            )
        
        now_est = datetime.now(timezone.utc).astimezone(EST)
        embed.set_footer(text=f"Appraisal Date: {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
        
        await interaction.edit_original_response(content=None, embed=embed)
        
        print(f"[OK] Property appraised: {property_id} = {current_value}d")
        
    except Exception as e:
        print(f"[ERR] Property appraisal failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="improve", description="üèóÔ∏è Upgrade your property to increase its value")
@app_commands.describe(
    property_id="Property ID to improve",
    improvement_type="Type of improvement",
    cost="Cost of improvement in diamonds"
)
@app_commands.choices(improvement_type=[
    app_commands.Choice(name="Renovation (small improvement)", value="renovation"),
    app_commands.Choice(name="Expansion (medium improvement)", value="expansion"),
    app_commands.Choice(name="Development (major improvement)", value="development"),
    app_commands.Choice(name="Luxury Upgrade (premium improvement)", value="luxury")
])
async def improve_property(interaction: discord.Interaction, property_id: str, improvement_type: str, cost: float):
    await interaction.response.send_message("üèóÔ∏è Processing property improvement...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before improvements
    await ensure_firestore()
    
    if cost <= 0:
        return await interaction.edit_original_response(content="‚ùå Improvement cost must be positive.")
    
    try:
        properties = db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        property_doc = None
        property_data = None
        
        for doc in properties:
            property_doc = doc
            property_data = doc.to_dict()
            break
        
        if not property_data:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` not found.")
        
        if property_data.get('ownerId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå You don't own this property.")
        
        buyer_accounts = db.collection(BANK_ACCOUNTS_COLLECTION).where(
            filter=FieldFilter('userId', '==', interaction.user.id)
        ).limit(1).stream()
        
        buyer_account_doc = None
        buyer_account_data = None
        
        for doc in buyer_accounts:
            buyer_account_doc = doc
            buyer_account_data = doc.to_dict()
            break
        
        if not buyer_account_data:
            return await interaction.edit_original_response(content="‚ùå You don't have a bank account.\n\nüí° Use `/bank account` to create one.")
        
        buyer_balance = buyer_account_data.get('diamondBalance', buyer_account_data.get('balance', 0.0))
        
        if buyer_balance < cost:
            return await interaction.edit_original_response(content=
                f"‚ùå **Insufficient Funds!**\n\n"
                f"**Required:** {DIAMOND_EMOJI} {cost:,.2f}d\n"
                f"**Your Balance:** {DIAMOND_EMOJI} {buyer_balance:,.2f}d\n"
                f"**Short:** {DIAMOND_EMOJI} {cost - buyer_balance:,.2f}d"
            )
        
        improvement_multipliers = {
            'renovation': 0.8,
            'expansion': 1.0,
            'development': 1.3,
            'luxury': 1.5
        }
        
        value_multiplier = improvement_multipliers.get(improvement_type, 1.0)
        value_added = cost * value_multiplier
        
        new_balance = buyer_balance - cost
        current_improvements = property_data.get('improvementsValue', 0.0)
        new_improvements_value = current_improvements + value_added
        
        buyer_account_doc.reference.update({'diamondBalance': new_balance})
        
        property_doc.reference.update({
            'improvementsValue': new_improvements_value,
            'lastImprovement': datetime.now(timezone.utc)
        })
        
        db.collection(PROPERTY_IMPROVEMENTS_COLLECTION).add({
            'propertyId': property_id,
            'ownerId': interaction.user.id,
            'improvementType': improvement_type,
            'cost': cost,
            'valueAdded': value_added,
            'timestamp': datetime.now(timezone.utc)
        })
        
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': interaction.user.id,
            'username': str(interaction.user),
            'type': 'property_improvement',
            'commodity': 'diamonds',
            'amount': -cost,
            'balance': new_balance,
            'timestamp': datetime.now(timezone.utc),
            'memo': f"Property improvement: {property_data.get('name')} ({improvement_type})"
        })
        
        new_current_value = calculate_property_value(property_doc.reference.get().to_dict())
        property_doc.reference.update({'currentValue': new_current_value})
        
        db.collection(PROPERTY_VALUES_COLLECTION).add({
            'propertyId': property_id,
            'value': new_current_value,
            'timestamp': datetime.now(timezone.utc),
            'changeReason': f'improvement_{improvement_type}',
            'marketCondition': get_current_economic_cycle().get('state', 'stable')
        })
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Property Improvement Complete!**\n\n"
            f"**Property:** {property_data.get('name')} ({property_id})\n"
            f"**Improvement:** {improvement_type.title()}\n"
            f"**Cost:** {DIAMOND_EMOJI} {cost:,.2f}d\n"
            f"**Value Added:** +{DIAMOND_EMOJI} {value_added:,.2f}d\n"
            f"**New Property Value:** {DIAMOND_EMOJI} {new_current_value:,.2f}d\n"
            f"**Your New Balance:** {DIAMOND_EMOJI} {new_balance:,.2f}d\n\n"
            f"üèóÔ∏è Your property value has increased!"
        )
        
        print(f"[OK] Property {property_id} improved by {interaction.user}: {improvement_type} for {cost}d")
        
    except Exception as e:
        print(f"[ERR] Property improvement failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@bot.tree.command(name="set_market_cycle", description="[ADMIN] Set the real estate market economic cycle (boom/stable/recession)")
@app_commands.describe(
    cycle_state="Economic cycle state",
    multiplier="Price multiplier (1.0 = normal, >1.0 = boom, <1.0 = recession)",
    description="Description of the economic event"
)
@app_commands.choices(cycle_state=[
    app_commands.Choice(name="üìà BOOM - Prices Rising (+10% to +30%)", value="boom"),
    app_commands.Choice(name="üìä STABLE - Normal Market", value="stable"),
    app_commands.Choice(name="üìâ RECESSION - Prices Falling (-10% to -30%)", value="recession")
])
async def set_market_cycle(interaction: discord.Interaction, cycle_state: str, multiplier: float, description: str = ""):
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Only admins can set market cycles.", ephemeral=True)
    
    await interaction.response.send_message("üìä Setting market cycle...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if multiplier <= 0:
        return await interaction.edit_original_response(content="‚ùå Multiplier must be positive.")
    
    try:
        db.collection(ECONOMIC_CYCLES_COLLECTION).add({
            'state': cycle_state,
            'multiplier': multiplier,
            'description': description,
            'timestamp': datetime.now(timezone.utc),
            'setBy': interaction.user.id,
            'setByName': str(interaction.user)
        })
        
        properties = db.collection(PROPERTIES_COLLECTION).stream()
        updated_count = 0
        
        for prop_doc in properties:
            prop_data = prop_doc.to_dict()
            new_value = calculate_property_value(prop_data, {'state': cycle_state, 'multiplier': multiplier})
            
            prop_doc.reference.update({
                'currentValue': new_value,
                'lastAppraisal': datetime.now(timezone.utc)
            })
            
            db.collection(PROPERTY_VALUES_COLLECTION).add({
                'propertyId': prop_data.get('propertyId'),
                'value': new_value,
                'timestamp': datetime.now(timezone.utc),
                'changeReason': f'market_cycle_{cycle_state}',
                'marketCondition': cycle_state
            })
            
            updated_count += 1
        
        cycle_emoji = {'boom': 'üìà', 'stable': 'üìä', 'recession': 'üìâ'}.get(cycle_state, 'üìä')
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Market Cycle Updated!**\n\n"
            f"{cycle_emoji} **State:** {cycle_state.upper()}\n"
            f"**Price Multiplier:** {multiplier:.2f}x\n"
            f"**Properties Updated:** {updated_count}\n"
            f"{'**Event:** ' + description if description else ''}\n\n"
            f"All property values have been recalculated!"
        )
        
        if interaction.guild:
            try:
                await interaction.channel.send(
                    f"üèòÔ∏è **REAL ESTATE MARKET UPDATE** üèòÔ∏è\n\n"
                    f"{cycle_emoji} The housing market has entered a **{cycle_state.upper()}** cycle!\n"
                    f"**Price Multiplier:** {multiplier:.2f}x\n"
                    f"{description}\n\n"
                    f"üí° Use `/property appraise [property_id]` to see your property's new value"
                )
            except:
                pass
        
        print(f"[OK] Market cycle set to {cycle_state} ({multiplier}x) by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Set market cycle failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="mortgage", description="üè¶ Apply for a mortgage to buy property with financing")
@app_commands.describe(
    property_id="Property ID to finance",
    down_payment="Down payment amount in diamonds",
    term_months="Loan term in months (12-360)"
)
async def apply_mortgage(interaction: discord.Interaction, property_id: str, down_payment: float, term_months: int):
    await interaction.response.send_message("üè¶ Processing mortgage application...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before mortgage processing
    await ensure_firestore()
    
    if not is_citizen(interaction.user.id):
        return await interaction.edit_original_response(content="‚ùå Only citizens can apply for mortgages.")
    
    if down_payment < 0:
        return await interaction.edit_original_response(content="‚ùå Down payment must be positive.")
    
    if term_months < 12 or term_months > 360:
        return await interaction.edit_original_response(content="‚ùå Loan term must be between 12 and 360 months (1-30 years).")
    
    try:
        listings = db.collection(PROPERTY_LISTINGS_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        listing_doc = None
        listing_data = None
        
        for doc in listings:
            listing_doc = doc
            listing_data = doc.to_dict()
            break
        
        if not listing_data:
            return await interaction.edit_original_response(content=f"‚ùå Property `{property_id}` is not listed for sale.\n\nüí° View available properties with `/property marketplace`")
        
        if listing_data.get('status') != 'active':
            return await interaction.edit_original_response(content="‚ùå This listing is no longer active.")
        
        if listing_data.get('sellerId') == interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå You cannot mortgage your own property!")
        
        price = listing_data.get('price', 0)
        seller_id = listing_data.get('sellerId')
        
        if down_payment > price:
            return await interaction.edit_original_response(content=f"‚ùå Down payment ({down_payment}d) cannot exceed property price ({price}d).")
        
        loan_amount = price - down_payment
        
        if loan_amount <= 0:
            return await interaction.edit_original_response(content="‚ùå Loan amount must be positive. Use `/property buy` if paying full price.")
        
        buyer_accounts = db.collection(BANK_ACCOUNTS_COLLECTION).where(
            filter=FieldFilter('userId', '==', interaction.user.id)
        ).limit(1).stream()
        
        buyer_account_doc = None
        buyer_account_data = None
        
        for doc in buyer_accounts:
            buyer_account_doc = doc
            buyer_account_data = doc.to_dict()
            break
        
        if not buyer_account_data:
            return await interaction.edit_original_response(content="‚ùå You don't have a bank account.\n\nüí° Use `/bank account` to create one.")
        
        buyer_balance = buyer_account_data.get('diamondBalance', buyer_account_data.get('balance', 0.0))
        
        if buyer_balance < down_payment:
            return await interaction.edit_original_response(content=
                f"‚ùå **Insufficient Funds for Down Payment!**\n\n"
                f"**Required:** {DIAMOND_EMOJI} {down_payment:,.2f}d\n"
                f"**Your Balance:** {DIAMOND_EMOJI} {buyer_balance:,.2f}d\n"
                f"**Short:** {DIAMOND_EMOJI} {down_payment - buyer_balance:,.2f}d"
            )
        
        interest_rate = 0.05
        monthly_rate = interest_rate / 12
        monthly_payment = (loan_amount * monthly_rate * (1 + monthly_rate)**term_months) / ((1 + monthly_rate)**term_months - 1)
        total_paid = monthly_payment * term_months
        total_interest = total_paid - loan_amount
        
        seller_accounts = db.collection(BANK_ACCOUNTS_COLLECTION).where(
            filter=FieldFilter('userId', '==', seller_id)
        ).limit(1).stream()
        
        seller_account_doc = None
        seller_account_data = None
        
        for doc in seller_accounts:
            seller_account_doc = doc
            seller_account_data = doc.to_dict()
            break
        
        if not seller_account_data:
            return await interaction.edit_original_response(content="‚ùå Seller doesn't have a bank account. Transaction cannot proceed.")
        
        properties = db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('propertyId', '==', property_id)
        ).limit(1).stream()
        
        property_doc = None
        property_data = None
        
        for doc in properties:
            property_doc = doc
            property_data = doc.to_dict()
            break
        
        if not property_data:
            return await interaction.edit_original_response(content="‚ùå Property record not found.")
        
        now_utc = datetime.now(timezone.utc)
        
        buyer_account_ref = buyer_account_doc.reference
        seller_account_ref = seller_account_doc.reference
        property_ref = property_doc.reference
        listing_ref = listing_doc.reference
        
        @firestore.transactional
        def execute_mortgage_purchase(transaction):
            listing_snapshot = listing_ref.get(transaction=transaction)
            if not listing_snapshot.exists or listing_snapshot.to_dict().get('status') != 'active':
                raise ValueError("Listing is no longer active or was already sold")
            
            buyer_snapshot = buyer_account_ref.get(transaction=transaction)
            current_buyer_balance = buyer_snapshot.to_dict().get('diamondBalance', buyer_snapshot.to_dict().get('balance', 0.0))
            if current_buyer_balance < down_payment:
                raise ValueError(f"Insufficient funds for down payment: need {down_payment}d, have {current_buyer_balance}d")
            
            seller_snapshot = seller_account_ref.get(transaction=transaction)
            if not seller_snapshot.exists:
                raise ValueError("Seller account no longer exists")
            current_seller_balance = seller_snapshot.to_dict().get('diamondBalance', seller_snapshot.to_dict().get('balance', 0.0))
            
            property_snapshot = property_ref.get(transaction=transaction)
            if not property_snapshot.exists:
                raise ValueError("Property no longer exists")
            current_property_data = property_snapshot.to_dict()
            if current_property_data.get('ownerId') != seller_id:
                raise ValueError("Property ownership changed during transaction")
            
            new_buyer_balance = current_buyer_balance - down_payment
            new_seller_balance = current_seller_balance + price
            
            transaction.update(buyer_account_ref, {'diamondBalance': new_buyer_balance})
            transaction.update(seller_account_ref, {'diamondBalance': new_seller_balance})
            
            transaction.update(property_ref, {
                'ownerId': interaction.user.id,
                'ownerName': str(interaction.user),
                'purchasePrice': price,
                'purchaseDate': now_utc,
                'previousOwner': seller_id
            })
            
            transaction.update(listing_ref, {
                'status': 'sold',
                'soldAt': now_utc,
                'soldTo': interaction.user.id
            })
            
            return new_buyer_balance, new_seller_balance
        
        new_buyer_balance, new_seller_balance = db.transaction(execute_mortgage_purchase)
        
        import random
        import string
        mortgage_id = f"MORT-{''.join(random.choices(string.ascii_uppercase + string.digits, k=8))}"
        
        db.collection(MORTGAGES_COLLECTION).add({
            'mortgageId': mortgage_id,
            'propertyId': property_id,
            'borrowerId': interaction.user.id,
            'borrowerName': str(interaction.user),
            'lenderId': STATE_USER_ID,
            'lenderName': 'Florab√≠s State Bank',
            'propertyPrice': price,
            'downPayment': down_payment,
            'loanAmount': loan_amount,
            'interestRate': interest_rate,
            'termMonths': term_months,
            'monthlyPayment': monthly_payment,
            'totalPaid': 0.0,
            'remainingBalance': loan_amount,
            'nextPaymentDue': now_utc + timedelta(days=30),
            'jurisdiction': jurisdiction,
            'status': 'active',
            'createdAt': now_utc
        })
        
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': interaction.user.id,
            'username': str(interaction.user),
            'type': 'mortgage_down_payment',
            'commodity': 'diamonds',
            'amount': -down_payment,
            'balance': new_buyer_balance,
            'timestamp': now_utc,
            'memo': f"Mortgage down payment: {listing_data.get('propertyName')} ({property_id})"
        })
        
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': seller_id,
            'username': listing_data.get('sellerName', 'Unknown'),
            'type': 'property_sale_mortgage',
            'commodity': 'diamonds',
            'amount': price,
            'balance': new_seller_balance,
            'timestamp': now_utc,
            'memo': f"Property sale (mortgage): {listing_data.get('propertyName')} ({property_id})"
        })
        
        property_name = listing_data.get('propertyName', 'Unknown')
        coords = property_data.get('coordinates', {})
        
        await interaction.edit_original_response(content=
            f"‚úÖ **MORTGAGE APPROVED & PROPERTY PURCHASED!**\n\n"
            f"**Property:** {property_name} ({property_id})\n"
            f"**Location:** ({coords.get('x')}, {coords.get('y')}, {coords.get('z')})\n"
            f"**Total Price:** {DIAMOND_EMOJI} {price:,.2f}d\n"
            f"**Down Payment:** {DIAMOND_EMOJI} {down_payment:,.2f}d\n"
            f"**Loan Amount:** {DIAMOND_EMOJI} {loan_amount:,.2f}d\n"
            f"**Interest Rate:** {interest_rate*100:.1f}% APR\n"
            f"**Loan Term:** {term_months} months ({term_months//12} years)\n"
            f"**Monthly Payment:** {DIAMOND_EMOJI} {monthly_payment:,.2f}d\n"
            f"**Total Interest:** {DIAMOND_EMOJI} {total_interest:,.2f}d\n"
            f"**Your New Balance:** {DIAMOND_EMOJI} {new_buyer_balance:,.2f}d\n\n"
            f"üè¶ **Mortgage ID:** {mortgage_id}\n"
            f"üìÖ First payment due in 30 days\n\n"
            f"You are now the owner of this property!"
        )
        
        try:
            seller = await bot.fetch_user(seller_id)
            await seller.send(
                f"üí∞ **PROPERTY SOLD (MORTGAGE)!**\n\n"
                f"**Property:** {property_name} ({property_id})\n"
                f"**Buyer:** {interaction.user.mention}\n"
                f"**Sale Price:** {DIAMOND_EMOJI} **{price:,.2f}d**\n"
                f"**Your New Balance:** {DIAMOND_EMOJI} {new_seller_balance:,.2f}d\n\n"
                f"üíµ Full payment has been deposited to your bank account."
            )
        except:
            pass
        
        if interaction.guild and BANCQUERO_ROLE_ID and price >= 100.0:
            bancquero_role = interaction.guild.get_role(BANCQUERO_ROLE_ID)
            if bancquero_role:
                try:
                    bancquero_channel = interaction.channel
                    await bancquero_channel.send(
                        f"üíº <@&{BANCQUERO_ROLE_ID}> **Mortgage Transaction**\n\n"
                        f"**Property:** {property_name} ({property_id})\n"
                        f"**Mortgage ID:** {mortgage_id}\n"
                        f"**Total Price:** {DIAMOND_EMOJI} **{price:,.2f}d**\n"
                        f"**Down Payment:** {DIAMOND_EMOJI} {down_payment:,.2f}d\n"
                        f"**Loan Amount:** {DIAMOND_EMOJI} {loan_amount:,.2f}d\n"
                        f"**Borrower:** {interaction.user.mention} ‚Üí Balance: {new_buyer_balance:,.2f}d\n"
                        f"**Seller:** <@{seller_id}> ‚Üí Balance: {new_seller_balance:,.2f}d\n"
                        f"**Monthly Payment:** {DIAMOND_EMOJI} {monthly_payment:,.2f}d for {term_months} months\n\n"
                        f"*Automatic financial oversight notification*"
                    )
                except:
                    pass
        
        print(f"[OK] Mortgage approved: {mortgage_id} for property {property_id} by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Mortgage application failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="my_mortgages", description="üè¶ View your active mortgages and payment status")
async def view_my_mortgages(interaction: discord.Interaction):
    await interaction.response.send_message("üè¶ Loading your mortgages...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before querying
    await ensure_firestore()
    
    try:
        mortgages = list(db.collection(MORTGAGES_COLLECTION).where(
            filter=FieldFilter('borrowerId', '==', interaction.user.id)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream())
        
        if not mortgages:
            return await interaction.edit_original_response(content=
                "üè¶ **Your Mortgages**\n\n"
                "You don't have any active mortgages.\n\n"
                "üí° Use `/property mortgage` to finance a property purchase"
            )
        
        embed = discord.Embed(
            title="üè¶ Your Active Mortgages",
            description=f"*{len(mortgages)} mortgage(s) in your portfolio*",
            color=0x1E88E5
        )
        
        total_debt = 0.0
        total_monthly = 0.0
        
        for mort_doc in mortgages:
            mort_data = mort_doc.to_dict()
            
            mortgage_id = mort_data.get('mortgageId', 'Unknown')
            property_id = mort_data.get('propertyId', 'Unknown')
            loan_amount = mort_data.get('loanAmount', 0.0)
            remaining = mort_data.get('remainingBalance', loan_amount)
            monthly_payment = mort_data.get('monthlyPayment', 0.0)
            total_paid = mort_data.get('totalPaid', 0.0)
            term_months = mort_data.get('termMonths', 0)
            interest_rate = mort_data.get('interestRate', 0.05) * 100
            next_payment = mort_data.get('nextPaymentDue')
            
            payments_made = int(total_paid / monthly_payment) if monthly_payment > 0 else 0
            payments_left = term_months - payments_made
            
            total_debt += remaining
            total_monthly += monthly_payment
            
            next_payment_str = "Due now"
            if next_payment:
                if hasattr(next_payment, 'strftime'):
                    next_payment_est = next_payment.replace(tzinfo=timezone.utc).astimezone(EST)
                    next_payment_str = next_payment_est.strftime('%b %d, %Y')
            
            progress_pct = ((loan_amount - remaining) / loan_amount * 100) if loan_amount > 0 else 0
            
            embed.add_field(
                name=f"üè† Mortgage: {mortgage_id}",
                value=(
                    f"**Property:** {property_id}\n"
                    f"**Remaining:** {DIAMOND_EMOJI} {remaining:,.2f}d / {loan_amount:,.2f}d ({progress_pct:.1f}% paid)\n"
                    f"**Monthly Payment:** {DIAMOND_EMOJI} {monthly_payment:,.2f}d\n"
                    f"**Interest Rate:** {interest_rate:.1f}% APR\n"
                    f"**Payments Left:** {payments_left} of {term_months} months\n"
                    f"**Next Payment:** {next_payment_str}"
                ),
                inline=False
            )
        
        embed.add_field(
            name="üí∞ Portfolio Summary",
            value=(
                f"**Total Debt:** {DIAMOND_EMOJI} {total_debt:,.2f}d\n"
                f"**Total Monthly Payments:** {DIAMOND_EMOJI} {total_monthly:,.2f}d"
            ),
            inline=False
        )
        
        now_est = datetime.now(timezone.utc).astimezone(EST)
        embed.set_footer(text=f"Updated: {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
        
        await interaction.edit_original_response(content=None, embed=embed)
        
        print(f"[OK] Mortgages viewed by {interaction.user}: {len(mortgages)} active")
        
    except Exception as e:
        print(f"[ERR] View mortgages failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="pay_mortgage", description="üíµ Make a mortgage payment")
@app_commands.describe(
    mortgage_id="Mortgage ID to pay",
    amount="Payment amount in diamonds (defaults to monthly payment)"
)
async def pay_mortgage(interaction: discord.Interaction, mortgage_id: str, amount: float = None):
    await interaction.response.send_message("üíµ Processing mortgage payment...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before payment
    await ensure_firestore()
    
    try:
        mortgages = db.collection(MORTGAGES_COLLECTION).where(
            filter=FieldFilter('mortgageId', '==', mortgage_id)
        ).limit(1).stream()
        
        mort_doc = None
        mort_data = None
        
        for doc in mortgages:
            mort_doc = doc
            mort_data = doc.to_dict()
            break
        
        if not mort_data:
            return await interaction.edit_original_response(content=f"‚ùå Mortgage `{mortgage_id}` not found.")
        
        if mort_data.get('borrowerId') != interaction.user.id:
            return await interaction.edit_original_response(content="‚ùå This is not your mortgage.")
        
        if mort_data.get('status') != 'active':
            return await interaction.edit_original_response(content="‚ùå This mortgage is not active.")
        
        monthly_payment = mort_data.get('monthlyPayment', 0.0)
        remaining_balance = mort_data.get('remainingBalance', 0.0)
        
        if amount is None:
            payment_amount = monthly_payment
        else:
            payment_amount = amount
        
        if payment_amount <= 0:
            return await interaction.edit_original_response(content="‚ùå Payment amount must be positive.")
        
        if payment_amount > remaining_balance:
            payment_amount = remaining_balance
        
        buyer_accounts = db.collection(BANK_ACCOUNTS_COLLECTION).where(
            filter=FieldFilter('userId', '==', interaction.user.id)
        ).limit(1).stream()
        
        buyer_account_doc = None
        buyer_account_data = None
        
        for doc in buyer_accounts:
            buyer_account_doc = doc
            buyer_account_data = doc.to_dict()
            break
        
        if not buyer_account_data:
            return await interaction.edit_original_response(content="‚ùå You don't have a bank account.\n\nüí° Use `/bank account` to create one.")
        
        buyer_balance = buyer_account_data.get('diamondBalance', buyer_account_data.get('balance', 0.0))
        
        if buyer_balance < payment_amount:
            return await interaction.edit_original_response(content=
                f"‚ùå **Insufficient Funds!**\n\n"
                f"**Required:** {DIAMOND_EMOJI} {payment_amount:,.2f}d\n"
                f"**Your Balance:** {DIAMOND_EMOJI} {buyer_balance:,.2f}d\n"
                f"**Short:** {DIAMOND_EMOJI} {payment_amount - buyer_balance:,.2f}d"
            )
        
        new_balance = buyer_balance - payment_amount
        new_remaining = remaining_balance - payment_amount
        new_total_paid = mort_data.get('totalPaid', 0.0) + payment_amount
        
        buyer_account_doc.reference.update({'diamondBalance': new_balance})
        
        if new_remaining <= 0:
            mort_doc.reference.update({
                'remainingBalance': 0.0,
                'totalPaid': new_total_paid,
                'status': 'paid_off',
                'paidOffAt': datetime.now(timezone.utc)
            })
            status_msg = "‚úÖ **MORTGAGE PAID OFF!** üéâ"
        else:
            next_payment_due = datetime.now(timezone.utc) + timedelta(days=30)
            mort_doc.reference.update({
                'remainingBalance': new_remaining,
                'totalPaid': new_total_paid,
                'nextPaymentDue': next_payment_due
            })
            status_msg = "‚úÖ **Payment Successful!**"
        
        db.collection(BANK_TRANSACTIONS_COLLECTION).add({
            'userId': interaction.user.id,
            'username': str(interaction.user),
            'type': 'mortgage_payment',
            'commodity': 'diamonds',
            'amount': -payment_amount,
            'balance': new_balance,
            'timestamp': datetime.now(timezone.utc),
            'memo': f"Mortgage payment: {mortgage_id}"
        })
        
        property_id = mort_data.get('propertyId', 'Unknown')
        
        await interaction.edit_original_response(content=
            f"{status_msg}\n\n"
            f"**Mortgage ID:** {mortgage_id}\n"
            f"**Property:** {property_id}\n"
            f"**Payment Amount:** {DIAMOND_EMOJI} {payment_amount:,.2f}d\n"
            f"**Remaining Balance:** {DIAMOND_EMOJI} {new_remaining:,.2f}d\n"
            f"**Total Paid:** {DIAMOND_EMOJI} {new_total_paid:,.2f}d\n"
            f"**Your New Balance:** {DIAMOND_EMOJI} {new_balance:,.2f}d\n\n"
            f"{'üè† Congratulations! You now own this property free and clear!' if new_remaining <= 0 else f'üìÖ Next payment due in 30 days'}"
        )
        
        print(f"[OK] Mortgage payment: {mortgage_id} - {payment_amount}d by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Mortgage payment failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@property_group.command(name="portfolio_value", description="üí∞ View your total real estate portfolio value")
async def view_portfolio_value(interaction: discord.Interaction):
    await interaction.response.send_message("üí∞ Calculating portfolio value...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Ensure Firestore connection before calculations
    await ensure_firestore()
    
    try:
        properties = list(db.collection(PROPERTIES_COLLECTION).where(
            filter=FieldFilter('ownerId', '==', interaction.user.id)
        ).stream())
        
        if not properties:
            return await interaction.edit_original_response(content=
                "üí∞ **Real Estate Portfolio**\n\n"
                "You don't own any properties yet.\n\n"
                "üí° Browse available properties with `/property marketplace`"
            )
        
        cycle_data = get_current_economic_cycle()
        
        total_value = 0.0
        total_purchase_price = 0.0
        total_improvements = 0.0
        
        property_details = []
        
        for prop_doc in properties:
            prop_data = prop_doc.to_dict()
            current_value = calculate_property_value(prop_data, cycle_data)
            purchase_price = prop_data.get('purchasePrice', prop_data.get('baseValue', 100.0))
            improvements = prop_data.get('improvementsValue', 0.0)
            
            total_value += current_value
            total_purchase_price += purchase_price
            total_improvements += improvements
            
            value_change = current_value - purchase_price
            value_change_pct = (value_change / purchase_price * 100) if purchase_price > 0 else 0
            
            property_details.append({
                'name': prop_data.get('name', 'Unknown'),
                'id': prop_data.get('propertyId', 'Unknown'),
                'type': prop_data.get('type', 'unknown'),
                'value': current_value,
                'purchase': purchase_price,
                'change': value_change,
                'change_pct': value_change_pct
            })
        
        property_details.sort(key=lambda x: x['value'], reverse=True)
        
        total_gain = total_value - total_purchase_price
        total_roi = (total_gain / total_purchase_price * 100) if total_purchase_price > 0 else 0
        
        mortgages = list(db.collection(MORTGAGES_COLLECTION).where(
            filter=FieldFilter('borrowerId', '==', interaction.user.id)
        ).where(
            filter=FieldFilter('status', '==', 'active')
        ).stream())
        
        total_debt = sum(m.to_dict().get('remainingBalance', 0.0) for m in mortgages)
        net_equity = total_value - total_debt
        
        embed = discord.Embed(
            title="üí∞ Real Estate Portfolio",
            description=f"*{len(properties)} propert{'y' if len(properties) == 1 else 'ies'} in your portfolio*",
            color=0x00C853 if total_gain > 0 else 0xE53935 if total_gain < 0 else 0x757575
        )
        
        embed.add_field(
            name="üìä Portfolio Summary",
            value=(
                f"**Total Market Value:** {DIAMOND_EMOJI} **{total_value:,.2f}d**\n"
                f"**Total Purchase Price:** {DIAMOND_EMOJI} {total_purchase_price:,.2f}d\n"
                f"**Total Improvements:** {DIAMOND_EMOJI} {total_improvements:,.2f}d\n"
                f"**Unrealized Gain/Loss:** {'+' if total_gain > 0 else ''}{DIAMOND_EMOJI} {total_gain:,.2f}d ({'+' if total_roi > 0 else ''}{total_roi:.1f}%)"
            ),
            inline=False
        )
        
        if total_debt > 0:
            embed.add_field(
                name="üè¶ Debt & Equity",
                value=(
                    f"**Outstanding Mortgages:** {DIAMOND_EMOJI} {total_debt:,.2f}d\n"
                    f"**Net Equity:** {DIAMOND_EMOJI} **{net_equity:,.2f}d**\n"
                    f"**Loan-to-Value:** {(total_debt/total_value*100):.1f}%"
                ),
                inline=False
            )
        
        properties_text = ""
        for i, prop in enumerate(property_details[:5]):
            change_emoji = "üìà" if prop['change'] > 0 else "üìâ" if prop['change'] < 0 else "‚û°Ô∏è"
            properties_text += (
                f"{change_emoji} **{prop['name']}** ({prop['type'].title()})\n"
                f"Value: {DIAMOND_EMOJI} {prop['value']:,.2f}d ({'+' if prop['change'] > 0 else ''}{prop['change_pct']:.1f}%)\n\n"
            )
        
        if len(property_details) > 5:
            properties_text += f"*...and {len(property_details) - 5} more*"
        
        embed.add_field(
            name="üèòÔ∏è Top Properties",
            value=properties_text or "No properties",
            inline=False
        )
        
        cycle_emoji = {'boom': 'üìà', 'stable': 'üìä', 'recession': 'üìâ'}.get(cycle_data.get('state', 'stable'), 'üìä')
        embed.add_field(
            name="üìä Market Conditions",
            value=f"{cycle_emoji} {cycle_data.get('state', 'stable').upper()} (Multiplier: {cycle_data.get('multiplier', 1.0):.2f}x)",
            inline=False
        )
        
        now_est = datetime.now(timezone.utc).astimezone(EST)
        embed.set_footer(text=f"Valuation Date: {now_est.strftime('%b %d, %Y at %I:%M %p EST')}")
        
        await interaction.edit_original_response(content=None, embed=embed)
        
        print(f"[OK] Portfolio value viewed by {interaction.user}: {total_value}d across {len(properties)} properties")
        
    except Exception as e:
        print(f"[ERR] Portfolio value failed: {e}")
        import traceback
        traceback.print_exc()
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

# ========================================
# GOVERNMENT CONTRACTS SYSTEM (#5)
# ========================================

@contract_group.command(name="create", description="[ADMIN] Create a government contract for public works")
@app_commands.describe(
    project_name="Name of the project",
    description="Detailed description of the work",
    budget="Budget in diamonds",
    deadline_days="Days until deadline"
)
async def create_contract(interaction: discord.Interaction, project_name: str, description: str, budget: float, deadline_days: int):
    # Admin check
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Only admins can create government contracts.", ephemeral=True)
    
    await interaction.response.send_message("üìã Creating government contract...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    if budget <= 0 or deadline_days <= 0:
        return await interaction.edit_original_response(content="‚ùå Budget and deadline must be positive numbers.")
    
    try:
        # Generate contract ID
        import random
        import string
        contract_id = f"CONTRACT-{''.join(random.choices(string.ascii_uppercase + string.digits, k=6))}"
        
        deadline = datetime.now(timezone.utc) + timedelta(days=deadline_days)
        
        # Create the contract
        _, contract_ref = db.collection(CONTRACTS_COLLECTION).add({
            'contractId': contract_id,
            'projectName': project_name,
            'description': description,
            'budget': budget,
            'deadline': deadline,
            'createdAt': datetime.now(timezone.utc),
            'createdBy': interaction.user.id,
            'status': 'open',  # open, awarded, in_progress, completed, cancelled
            'bids': [],
            'awardedTo': None
        })
        
        deadline_est = deadline.astimezone(EST)
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Government Contract Created!**\n\n"
            f"**Contract ID:** {contract_id}\n"
            f"**Project:** {project_name}\n"
            f"**Budget:** {budget:.2f}d\n"
            f"**Deadline:** {deadline_est.strftime('%B %d, %Y at %I:%M %p EST')}\n\n"
            f"üìù **Description:**\n{description}\n\n"
            f"Citizens can now bid on this contract using `/contract bid {contract_id}`!"
        )
        
        print(f"[OK] Contract created: {contract_id} - {project_name} ({budget}d)")
        
    except Exception as e:
        print(f"[ERR] Contract creation failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@contract_group.command(name="bid", description="üìã Submit a bid on a government contract")
@app_commands.describe(
    contract_id="Contract ID",
    bid_amount="Your bid amount in diamonds (must be ‚â§ budget)",
    completion_days="Days you need to complete the project",
    proposal="Your proposal for completing the work"
)
async def bid_on_contract(interaction: discord.Interaction, contract_id: str, bid_amount: float, completion_days: int, proposal: str):
    await interaction.response.send_message("üìã Submitting bid...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    # Check if user is a citizen
    if not is_citizen(interaction.user.id):
        return await interaction.edit_original_response(content="‚ùå Only citizens can bid on government contracts.")
    
    try:
        # Find the contract
        contracts = db.collection(CONTRACTS_COLLECTION).where(
            filter=FieldFilter('contractId', '==', contract_id)
        ).limit(1).stream()
        
        contract_doc = None
        contract_data = None
        
        for doc in contracts:
            contract_doc = doc
            contract_data = doc.to_dict()
            break
        
        if not contract_data:
            return await interaction.edit_original_response(content=f"‚ùå Contract `{contract_id}` not found.")
        
        if contract_data.get('status') != 'open':
            return await interaction.edit_original_response(content="‚ùå This contract is no longer accepting bids.")
        
        budget = contract_data.get('budget', 0)
        if bid_amount > budget:
            return await interaction.edit_original_response(content=f"‚ùå Your bid ({bid_amount:.2f}d) exceeds the budget ({budget:.2f}d).")
        
        # Generate bid ID
        import random
        import string
        bid_id = f"BID-{''.join(random.choices(string.ascii_uppercase + string.digits, k=6))}"
        
        # Submit the bid
        _, bid_ref = db.collection(CONTRACT_BIDS_COLLECTION).add({
            'bidId': bid_id,
            'contractId': contract_id,
            'bidderId': interaction.user.id,
            'bidderName': str(interaction.user),
            'bidAmount': bid_amount,
            'completionDays': completion_days,
            'proposal': proposal,
            'submittedAt': datetime.now(timezone.utc),
            'status': 'pending'  # pending, accepted, rejected
        })
        
        project_name = contract_data.get('projectName', 'Unknown')
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Bid Submitted Successfully!**\n\n"
            f"**Bid ID:** {bid_id}\n"
            f"**Contract:** {project_name}\n"
            f"**Your Bid:** {bid_amount:.2f}d\n"
            f"**Completion Time:** {completion_days} days\n\n"
            f"üìã Your bid is now pending review by administrators."
        )
        
        print(f"[OK] Bid submitted: {bid_id} on {contract_id} by {interaction.user} ({bid_amount}d)")
        
    except Exception as e:
        print(f"[ERR] Bid submission failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@contract_group.command(name="list", description="üìã View all active government contracts")
async def list_contracts(interaction: discord.Interaction):
    await interaction.response.send_message("üìã Loading contracts...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        contracts = list(db.collection(CONTRACTS_COLLECTION).where(
            filter=FieldFilter('status', '==', 'open')
        ).stream())
        
        if not contracts:
            return await interaction.edit_original_response(content="üìã No active government contracts available.\n\nüí° Admins can create contracts using `/contract create`!")
        
        contract_list = []
        
        for contract_doc in contracts[:10]:  # Show first 10
            contract = contract_doc.to_dict()
            deadline = contract.get('deadline')
            if deadline:
                deadline_est = deadline.astimezone(EST)
                deadline_str = deadline_est.strftime('%b %d, %Y')
            else:
                deadline_str = 'No deadline'
            
            # Get bid count
            bids = list(db.collection(CONTRACT_BIDS_COLLECTION).where(
                filter=FieldFilter('contractId', '==', contract.get('contractId'))
            ).stream())
            
            contract_list.append(
                f"üìã **{contract.get('projectName')}** ({contract.get('contractId')})\n"
                f"   üí∞ Budget: {contract.get('budget', 0):.2f}d\n"
                f"   üìÖ Deadline: {deadline_str}\n"
                f"   üìä Bids: {len(bids)}"
            )
        
        embed = discord.Embed(
            title="üìã ACTIVE GOVERNMENT CONTRACTS",
            description="\n\n".join(contract_list),
            color=0xe67e22
        )
        
        embed.add_field(
            name="üí° HOW TO BID",
            value="Use `/contract bid <contract_id>` to submit your bid on any contract!",
            inline=False
        )
        
        if len(contracts) > 10:
            embed.set_footer(text=f"Showing 10 of {len(contracts)} active contracts")
        else:
            embed.set_footer(text=f"{len(contracts)} active {'contract' if len(contracts) == 1 else 'contracts'}")
        
        await interaction.edit_original_response(embed=embed)
        
    except Exception as e:
        print(f"[ERR] List contracts failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@contract_group.command(name="award", description="[ADMIN] Award a contract to a bidder")
@app_commands.describe(
    bid_id="Bid ID to award"
)
async def award_contract(interaction: discord.Interaction, bid_id: str):
    # Admin check
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Only admins can award contracts.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Processing contract award...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Find the bid
        bids = db.collection(CONTRACT_BIDS_COLLECTION).where(
            filter=FieldFilter('bidId', '==', bid_id)
        ).limit(1).stream()
        
        bid_doc = None
        bid_data = None
        
        for doc in bids:
            bid_doc = doc
            bid_data = doc.to_dict()
            break
        
        if not bid_data:
            return await interaction.edit_original_response(content=f"‚ùå Bid `{bid_id}` not found.")
        
        # Get the contract
        contract_id = bid_data.get('contractId')
        contracts = db.collection(CONTRACTS_COLLECTION).where(
            filter=FieldFilter('contractId', '==', contract_id)
        ).limit(1).stream()
        
        contract_doc = None
        contract_data = None
        
        for doc in contracts:
            contract_doc = doc
            contract_data = doc.to_dict()
            break
        
        if not contract_data:
            return await interaction.edit_original_response(content="‚ùå Contract not found.")
        
        # Award the contract
        contract_doc.reference.update({
            'status': 'awarded',
            'awardedTo': bid_data.get('bidderId'),
            'awardedBidId': bid_id,
            'awardedAmount': bid_data.get('bidAmount'),
            'awardedAt': datetime.now(timezone.utc)
        })
        
        # Update bid status
        bid_doc.reference.update({
            'status': 'accepted'
        })
        
        # Reject other bids
        other_bids = db.collection(CONTRACT_BIDS_COLLECTION).where(
            filter=FieldFilter('contractId', '==', contract_id)
        ).stream()
        
        for other_bid_doc in other_bids:
            if other_bid_doc.id != bid_doc.id:
                other_bid_doc.reference.update({'status': 'rejected'})
        
        bidder = bid_data.get('bidderName', 'Unknown')
        bidder_id = bid_data.get('bidderId')
        project_name = contract_data.get('projectName', 'Unknown')
        amount = bid_data.get('bidAmount', 0)
        
        # BANK INTEGRATION: Credit winner's bank account
        bank_msg = ""
        try:
            winner_account = get_or_create_bank_account(bidder_id)
            if winner_account and winner_account.exists:
                account_data = winner_account.to_dict()
                old_balance = account_data.get('balance', 0.0)
                new_balance = old_balance + amount
                
                # Update balance
                winner_account.reference.update({'balance': new_balance})
                
                # Record transaction
                db.collection(BANK_TRANSACTIONS_COLLECTION).add({
                    'userId': bidder_id,
                    'userTag': f"<@{bidder_id}>",
                    'type': 'contract_payment',
                    'amount': amount,
                    'balanceBefore': old_balance,
                    'balanceAfter': new_balance,
                    'memo': f"Government Contract: {project_name} (ID: {contract_id})",
                    'processedBy': interaction.user.id,
                    'processedByTag': interaction.user.mention,
                    'timestamp': datetime.now(timezone.utc)
                })
                
                bank_msg = f"\nüí∞ **{amount:,.2f}d** deposited to contractor's bank account"
                print(f"[BANK] Contract payment: {amount:.2f}d deposited to {bidder_id}'s account (contract {contract_id})")
        except Exception as bank_err:
            print(f"[WARN] Failed to process bank payment for contract {contract_id}: {bank_err}")
            bank_msg = f"\n‚ö†Ô∏è Bank payment failed - admin must manually credit {amount:.2f}d"
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Contract Awarded!**\n\n"
            f"**Project:** {project_name}\n"
            f"**Contractor:** {bidder}\n"
            f"**Award Amount:** {amount:.2f}d{bank_msg}\n\n"
            f"The contractor has been notified and work can begin!"
        )
        
        print(f"[OK] Contract {contract_id} awarded to {bidder} ({amount}d)")
        
    except Exception as e:
        print(f"[ERR] Contract award failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")

@contract_group.command(name="complete", description="[ADMIN] Mark a contract as completed")
@app_commands.describe(
    contract_id="Contract ID to complete"
)
async def complete_contract(interaction: discord.Interaction, contract_id: str):
    # Admin check
    if not has_admin_role(interaction):
        return await interaction.response.send_message("‚ùå Only admins can complete contracts.", ephemeral=True)
    
    await interaction.response.send_message("‚è≥ Marking contract as complete...", ephemeral=True)
    
    if not db:
        return await interaction.edit_original_response(content="‚ùå Database not available.")
    
    try:
        # Find the contract
        contracts = db.collection(CONTRACTS_COLLECTION).where(
            filter=FieldFilter('contractId', '==', contract_id)
        ).limit(1).stream()
        
        contract_doc = None
        contract_data = None
        
        for doc in contracts:
            contract_doc = doc
            contract_data = doc.to_dict()
            break
        
        if not contract_data:
            return await interaction.edit_original_response(content=f"‚ùå Contract `{contract_id}` not found.")
        
        if contract_data.get('status') != 'awarded':
            current_status = contract_data.get('status', 'unknown')
            return await interaction.edit_original_response(
                content=f"‚ùå Contract must be in 'awarded' status to complete. Current status: `{current_status}`"
            )
        
        # Mark as completed
        contract_doc.reference.update({
            'status': 'completed',
            'completedAt': datetime.now(timezone.utc),
            'completedBy': interaction.user.id
        })
        
        project_name = contract_data.get('projectName', 'Unknown')
        contractor_id = contract_data.get('awardedTo')
        amount = contract_data.get('awardedAmount', 0)
        
        # Try to get contractor name
        contractor_name = "Unknown"
        if contractor_id:
            try:
                contractor_user = await bot.fetch_user(contractor_id)
                contractor_name = contractor_user.display_name
            except:
                contractor_name = f"User {contractor_id}"
        
        await interaction.edit_original_response(content=
            f"‚úÖ **Contract Marked Complete!**\n\n"
            f"**Project:** {project_name}\n"
            f"**Contractor:** {contractor_name}\n"
            f"**Contract Amount:** {amount:.2f}d\n"
            f"**Completed:** {datetime.now(timezone.utc).strftime('%b %d, %Y')}\n\n"
            f"üéâ Project successfully delivered!"
        )
        
        print(f"[OK] Contract {contract_id} marked complete by {interaction.user}")
        
    except Exception as e:
        print(f"[ERR] Contract completion failed: {e}")
        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")


# ---------- GLOBAL EXCEPTION HANDLERS ----------
def handle_exception(exc_type, exc_value, exc_traceback):
    """Global exception handler for unhandled exceptions"""
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    
    logger.critical("Unhandled exception", exc_info=(exc_type, exc_value, exc_traceback))

def handle_asyncio_exception(loop, context):
    """Handler for asyncio exceptions"""
    exception = context.get('exception')
    if exception:
        logger.error(f"Asyncio exception: {exception}", exc_info=exception)
    else:
        logger.error(f"Asyncio error: {context['message']}")

# Install global exception handlers
sys.excepthook = handle_exception


# =============== QUICK THREAD ACCESS COMMAND ===============
@bot.tree.command(name="thread_add", description="[ADMIN] Quickly add a user to a court case thread")
@app_commands.describe(
    case_id="Case ID (e.g. CV-02FC3A)",
    user="User to add",
    view_only="If True, user can view but not send messages (default: False)"
)
async def quick_thread_add(interaction: discord.Interaction, case_id: str, user: discord.Member, view_only: bool = False):
    """Fast command to add user to thread"""
    try:
        await interaction.response.send_message("‚è≥ Adding...", ephemeral=True)
        
        if not any(r.id in [ADMIN_ROLE_ID, MAGISTRATE_ROLE_ID] for r in interaction.user.roles):
            await interaction.edit_original_response(content="‚ùå Admin/Magistrate only.")
            return
        
        db = await ensure_firestore()
        doc = await asyncio.to_thread(lambda: db.collection('florabi_court_cases').document(case_id.strip().upper()).get())
        if not doc.exists:
            await interaction.edit_original_response(content=f"‚ùå Case {case_id} not found.")
            return
        
        thread_id = doc.to_dict().get('courtroomThreadId')
        if not thread_id:
            await interaction.edit_original_response(content=f"‚ùå No thread for {case_id}. Use /court create_thread first.")
            return
        
        print(f"[DEBUG] Thread ID from DB: {thread_id}")
        thread = interaction.guild.get_thread(thread_id)
        if not thread:
            try:
                thread = await interaction.guild.fetch_channel(thread_id)
            except Exception as fetch_err:
                await interaction.edit_original_response(content=f"‚ùå Cannot access thread {thread_id}: {fetch_err}")
                return
        
        print(f"[DEBUG] Found thread: {thread.name}, type: {thread.type}")
        
        # Check bot permissions in parent channel
        parent = thread.parent
        if parent:
            bot_perms = parent.permissions_for(interaction.guild.me)
            print(f"[DEBUG] Bot perms in {parent.name}: manage_threads={bot_perms.manage_threads}, send_in_threads={bot_perms.send_messages_in_threads}")
        
        try:
            await thread.join()
            print(f"[DEBUG] Bot joined thread")
        except Exception as join_err:
            print(f"[DEBUG] Join failed: {join_err}")
        
        # Try add_user first
        try:
            await thread.add_user(user)
        except discord.Forbidden:
            # Fallback: mention user in thread to invite them
            print(f"[DEBUG] add_user failed, trying mention approach")
            invite_msg = await thread.send(f"{user.mention} has been invited to this courtroom.", delete_after=5)
            await asyncio.sleep(1)
        
        # Handle view-only mode - post message in thread about restrictions
        mode_str = ""
        if view_only:
            mode_str = " as **view-only** (observer)"
            await thread.send(f"üëÅÔ∏è {user.mention} has been added as a **view-only observer**. Please do not send messages in this courtroom.", delete_after=30)
        
        await interaction.edit_original_response(content=f"‚úÖ Added {user.mention} to {case_id} thread{mode_str}!")
        print(f"[OK] {interaction.user} added {user} to thread for {case_id} (view_only={view_only})")
    except Exception as e:
        print(f"[ERR] thread_add failed: {e}")
        try:
            await interaction.edit_original_response(content=f"‚ùå Failed: {e}")
        except:
            pass

# ---------- RUN ----------
def main():
    load_dotenv()
    if DISCORD_BOT_TOKEN == "YOUR_DISCORD_BOT_TOKEN":
        print("\n" + "=" * 60)
        print("‚ùå DISCORD BOT TOKEN NOT CONFIGURED")
        print("=" * 60)
        print("\nTo run this bot, you need to set up your secrets:")
        print("\n1. Go to Tools ‚Üí Secrets in Replit")
        print("2. Add DISCORD_BOT_TOKEN with your Discord bot token")
        print("3. Add FIREBASE_KEY_JSON with your Firebase credentials")
        print("\nFor detailed setup instructions, see replit.md")
        print("=" * 60 + "\n")
        exit(1)

    # Set up asyncio exception handler
    loop = asyncio.get_event_loop()
    loop.set_exception_handler(handle_asyncio_exception)

    print("\nü§ñ Starting Royal Council Discord Bot...")
    print("üìù Bot will sync commands on first connection\n")
    print(f"üìÅ Crash logs will be saved to: /tmp/bot_logs/bot_crash.log\n")

    try:
        bot.run(DISCORD_BOT_TOKEN)
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.critical(f"FATAL: Bot crashed with exception: {e}", exc_info=True)
        print(f"\n‚ùå FATAL ERROR - Bot crashed! Check /tmp/bot_logs/bot_crash.log for details\n")
        raise

if __name__ == "__main__":
    main()
